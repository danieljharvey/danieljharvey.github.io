<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Compiling a functional language to LLVM, part 1</title>
    <link rel="stylesheet" href="../css/default.css" />

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Compiling a functional language to LLVM, part 1</h1>
        <article>
    <section class="header">
        Posted on February  8, 2023
        
        <div class="info">
          
          Tags: <a title="All pages tagged 'plt'." href="../tags/plt.html" rel="tag">plt</a>, <a title="All pages tagged 'mimsa'." href="../tags/mimsa.html" rel="tag">mimsa</a>, <a title="All pages tagged 'typechecker'." href="../tags/typechecker.html" rel="tag">typechecker</a>, <a title="All pages tagged 'llvm'." href="../tags/llvm.html" rel="tag">llvm</a>
          
        </div>
    </section>
    <section>
        <p>Recently I thought it would be good to start compiling the small functional
language <a href="https://github.com/danieljharvey/mimsa">mimsa</a> I’ve been messing
around with for the last few years to LLVM. There’s a few really helpful
resources - Joseph Morag’s <a href="https://blog.josephmorag.com/posts/mcc0/">Micro-C</a>
series, and <a href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/">Mapping High Level Concepts to LLVM
IR</a> in
particular, but neither go into converting functional programming paradigms
such as pattern matching, lambdas and ADTs in much depth.</p>
<p>So, here we’re going to give it a go. The plan is that we start with an
entirely working but tiny language, get it all working, and then as we add
features to the language, we’ll also add a typechecker and introduce more LLVM
concepts. The source code for the whole working calculator, along with a basic repl, can be found
at <a href="https://github.com/danieljharvey/llvm-calc/tree/trunk/llvm-calc">llvm-calc</a>.</p>
<h2 id="our-language">Our language</h2>
<p>The first iteration of our language is going to be the most basic of
calculators. Here is a valid program in our language:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">1</span> + 2 <span class="pp">*</span> <span class="er">(</span><span class="ex">1</span> + 100<span class="kw">)</span> <span class="ex">-</span> 100</span></code></pre></div>
<p>Here are the datatypes for our language. We will use this to represent our
programs internally.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> ann</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="co">-- | An integer value</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">EPrim</span> ann <span class="dt">Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="co">-- | Two values combined with an operator</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">EInfix</span> ann <span class="dt">Op</span> (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Operators for combining integers</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Op</span> <span class="ot">=</span> <span class="dt">OpAdd</span> <span class="op">|</span> <span class="dt">OpMultiply</span> <span class="op">|</span> <span class="dt">OpSubtract</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>Here’s some example values:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | the number `1`</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">one ::</span> <span class="dt">Expr</span> ()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>one <span class="ot">=</span> <span class="dt">EPrim</span> () <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | the expression `2 + 3`</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">twoPlusTwo ::</span> <span class="dt">Expr</span> ()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>twoPlusTwo <span class="ot">=</span> <span class="dt">EInfix</span> () <span class="dt">OpAdd</span> (<span class="dt">EPrim</span> () <span class="dv">2</span>) (<span class="dt">EPrim</span> () <span class="dv">3</span>)</span></code></pre></div>
<p>We call datatypes like <code>Expr</code> <em>Abstract Syntax Trees</em> (or ASTs).</p>
<p>You may notice the <code>ann</code> type variable. We’ll use this to “decorate” items in
our AST. For now, we’ll just use <code>()</code>.</p>
<h2 id="parsing-text-into-ast-terms">Parsing text into AST terms</h2>
<p>Although we could provide our compiler as a Haskell library and ask our users
to manually create <code>Expr</code> values for us, it’d be much nicer to be able to read
input from a user.</p>
<p>This process is called <em>parsing</em>, and looks something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseInput ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> (<span class="dt">Expr</span> ())</span></code></pre></div>
<p>Given some user input, parsing returns either a valid <code>Expr</code> or a (hopefully)
helpful error.</p>
<p>The whole parser can be seen
<a href="https://github.com/danieljharvey/llvm-calc/tree/trunk/llvm-calc/src/Calc/Parser">here</a>. We’ll not go into too much depth as there are already lots of great references
on parsing, but a few details are worth noting:</p>
<h3 id="which-library">Which library?</h3>
<p>We’ll be using a library called
<a href="https://hackage.haskell.org/package/megaparsec">megaparsec</a>. It’s fast, it’s got a <a href="https://markkarpov.com/tutorial/megaparsec.html">great
tutorial</a>, and it generates errors that we can render nicely with the <a href="https://github.com/Mesabloo/diagnose">diagnose</a> library.</p>
<figure>
<img src="../images/llvm-1-parse-error.png" title="A megaparsec parse error made nice with diagnose" alt="A megaparsec parse error made nice with diagnose" />
<figcaption aria-hidden="true">A megaparsec parse error made nice with diagnose</figcaption>
</figure>
<h3 id="dealing-with-whitespace">Dealing with whitespace</h3>
<p>Although some languages make whitespace meaningful, we won’t be bothering with
any of that for now. However we would like to allow our users some flexibility
with how they lay out their code. <code>1+1</code> and <code>1    + 1</code> should mean the same thing. That means we either need a lot of code like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseInfix ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>parseInfix <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> space0 <span class="co">-- this accepts 0 or more spaces </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> parseInt</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> space0 <span class="co">-- space between number and operator</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  op <span class="ot">&lt;-</span> parseOp</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">&lt;-</span> <span class="ot">&lt;-</span> space0 <span class="co">-- space between operator and second number</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> parseInt</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">Infix</span> op a b)</span></code></pre></div>
<p>…or we need a neat way of automating this. <code>megaparsec</code> has a handy thing
called a <code>lexeme</code>. This is a sort of rule that says
“when eating this value, also eat all the whitespace before it”. When you see
<code>myLexeme</code> in the code, this means we’re wrapping a parser with
whitespace-eating powers. This is
covered in much better detail in the
<a href="https://markkarpov.com/tutorial/megaparsec.html#white-space">megaparsec tutorial</a>.</p>
<h3 id="parsing-infixes">Parsing infixes</h3>
<p>One problem with parser combinator libraries is that it’s easy to get into an
infinite loop. <code>megaparsec</code> has a bunch of useful helpers for this, in
particular, support for <code>Operator</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | to make infix stuff like easier, `megaparsec` provides</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- the `Operator` type</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">table ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="dt">Annotation</span>)]]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>table <span class="ot">=</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  [ [binary <span class="st">&quot;*&quot;</span> (<span class="dt">EInfix</span> <span class="fu">mempty</span> <span class="dt">OpMultiply</span>)],</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    [ binary <span class="st">&quot;+&quot;</span> (<span class="dt">EInfix</span> <span class="fu">mempty</span> <span class="dt">OpAdd</span>),</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>      binary <span class="st">&quot;-&quot;</span> (<span class="dt">EInfix</span> <span class="fu">mempty</span> <span class="dt">OpSubtract</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>A nice part of the the above code is that by putting <code>*</code> in a group before <code>+</code>
and <code>-</code>, we have defined operator precidence and so <code>6 * 1 + 1</code> equals <code>7</code> rather
than <code>12</code> (which we’d get from <code>6 * (1 + 1)</code>).</p>
<h3 id="source-code-location">Source code location</h3>
<p>You may have noticed the <code>ann</code> type variable in our <code>Expr</code> type. This allows us
to “decorate” our AST nodes. In parsing, it’s useful to decorate each node with
it’s location in the code.</p>
<p>We use the following datatype for this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Annotation</span> <span class="ot">=</span> <span class="dt">Location</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>The two <code>Int</code> values are “character number we start at” and “length of the
string”. Therefore parsing ” 100” should return:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseResult ::</span> <span class="dt">Expr</span> <span class="dt">Annotation</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>parseResult <span class="ot">=</span> <span class="dt">EPrim</span> (<span class="dt">Location</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="dv">100</span></span></code></pre></div>
<p>We won’t be using these values today as our language is so limited that it’s
pretty difficult to break, but as we add multiple types (and thus, the
possibility of type errors) we’ll use them to show the user where they did a
boo boo.</p>
<h2 id="a-simple-interpreter">A simple interpreter</h2>
<p>Before we get stuck into <code>LLVM</code>, it’s good to be able to evaluate our language
internally. Although it’s pretty clear how this calculator should work, it
will be useful to compare our own simple interpreter with the LLVM output as
things get more complicated.</p>
<p>You can view the full code
<a href="https://github.com/danieljharvey/llvm-calc/blob/trunk/llvm-calc/src/Calc/Interpreter.hs">here</a>.
As you can see, there isn’t very much of it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpret ::</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">EPrim</span> ann p) <span class="ot">=</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- don't do anything with these</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EPrim</span> ann p</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">EInfix</span> ann op a b) <span class="ot">=</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- attempt to simplify these </span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  interpretInfix ann op a b</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">interpretInfix ::</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  ann <span class="ot">-&gt;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Op</span> <span class="ot">-&gt;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpAdd</span> (<span class="dt">EPrim</span> _ a) (<span class="dt">EPrim</span> _ b) <span class="ot">=</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- add the int values</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EPrim</span> ann (a <span class="op">+</span> b)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpSubtract</span> (<span class="dt">EPrim</span> _ a) (<span class="dt">EPrim</span> _ b) <span class="ot">=</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- subtract the int values</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EPrim</span> ann (a <span class="op">-</span> b)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpMultiply</span> (<span class="dt">EPrim</span> _ a) (<span class="dt">EPrim</span> _ b) <span class="ot">=</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- multiply the int values</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EPrim</span> ann (a <span class="op">*</span> b)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>interpretInfix ann op a b <span class="ot">=</span> </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- one of our arguments isn't yet a number</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- so simplify the leaves and try again</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  interpretInfix ann op (interpret a) (interpret b)</span></code></pre></div>
<p>When we see an <code>EInfix</code> value, we look for <code>EPrim</code> values inside and <code>add</code> / <code>subtract</code> / <code>multiply</code> them. If they’re
not <code>EPrim</code> values yet, then they must be nested expressions, so we <code>interpret</code> them
and try again.</p>
<figure>
<img src="../images/llvm-1-giant-calculator.jpg" title="A big calculator" alt="A big calculator" />
<figcaption aria-hidden="true">A big calculator</figcaption>
</figure>
<h2 id="enough-nonsense-lets-do-some-compiling">Enough nonsense, let’s do some compiling</h2>
<p>Hopefully we understand what our small language is now, so let’s get down to
the business of turning it into real life native code.</p>
<h3 id="what-is-llvm">What is LLVM</h3>
<p>LLVM stands for Low Level Virtual Machine. The idea is that higher level languages compile into LLVM, and then LLVM is turned into whatever local version of assembly is required. This means that by using LLVM, your programs will work on lots of architectures without you needing to understand a tremendous amount about them. As somebody who understands pretty much nothing about any processor architecture, this is very appealing indeed. If you need further persuading, <code>Rust</code>, <code>Swift</code> and <code>GHC</code> can all compile to
LLVM.</p>
<p>LLVM is part of the <code>clang</code> C compiler, and as a result, it’s very C shaped.
It’s got a bunch of number types, structs, and arrays, functions, and enough pointers to have a
very bad time.</p>
<h3 id="our-runtime">Our “runtime”</h3>
<p>In order to <em>do things</em> our language will need a runtime, This is a bunch of helper code written in something that be compiled to the target
language. Because we’ll be compiling using <code>clang</code>, we’ll use <code>C</code>. I don’t know much about <code>C</code>, but what I can tell you is that this file contains a single function called <code>printint</code>, that takes an <code>int</code> and prints
it to <code>stdout</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printint<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is the only <code>C</code> you’ll need to see today. I’m sorry about that. Onwards!</p>
<h3 id="our-first-llvm-module">Our first LLVM module</h3>
<p>LLVM is organised in <a href="https://llvm.org/docs/LangRef.html#module-structure">modules</a>.</p>
<p>To start us off, here is the IR (Intermediate Representation) for printing the number <code>42</code> to <code>stdout</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'calc'</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@printint</span>(<span class="dt">i32</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@main</span>()    {</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> =  <span class="kw">call</span> <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@printint</span>(<span class="dt">i32</span>  <span class="dv">42</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Let’s take this apart line by line:</p>
<hr />
<div class="sourceCode" id="cb12"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'calc'</span></span></code></pre></div>
<p>This is a comment. See, LLVM is easy.</p>
<hr />
<div class="sourceCode" id="cb13"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@printint</span>(<span class="dt">i32</span>)</span></code></pre></div>
<p>This declares an external function we’d like to use. In this case it’s the
<code>printint</code> function from our standard library defined above. It
takes a single argument, an <code>i32</code>, and returns an <code>i32</code>.</p>
<hr />
<div class="sourceCode" id="cb14"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@main</span>() {</span></code></pre></div>
<p>This defines a function called <code>main</code> that takes no arguments and returns a
single <code>i32</code>.</p>
<p>The <code>ccc</code> part is the “calling convention”. This defines the manner in which
LLVM will generate the function code. There are <a href="https://llvm.org/docs/LangRef.html#calling-conventions">absolutely loads of these</a>, many
designs to optimise specific languages. We’ll keep to <code>ccc</code> for now, but may
want to change our minds when we start doing tail calls.</p>
<hr />
<div class="sourceCode" id="cb15"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">%1</span> =  <span class="kw">call</span> <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@printint</span>(<span class="dt">i32</span>  <span class="dv">42</span>)</span></code></pre></div>
<p>This line of defines a variable <code>%1</code>, and sets it the result of calling the
<code>printint</code> function we imported above. We pass the <code>printint</code> function a single
argument, an <code>i32</code> value of <code>42</code>. This will print the number <code>42</code> to stdout.</p>
<hr />
<div class="sourceCode" id="cb16"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span></code></pre></div>
<p>Functions in <code>LLVM</code> must return something (although that thing can be <code>null</code>).
This line returns an <code>i32</code> value of <code>0</code>. Because this is the <code>main</code> function of
our program, this is what will be returned to the operating system as our exit
code. <code>0</code> means “great job, everything went fine”.</p>
<hr />
<div class="sourceCode" id="cb17"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This is a closing curly brace. <code>LLVM</code> is like <code>C</code>, we have to specifically
end our functions. No great hardship though.</p>
<hr />
<h3 id="compiling-and-running-our-hand-baked-module">Compiling and running our hand-baked module</h3>
<p>To check that the code above does what we say it does, and to check we’ve got
everything installed that we need, let’s write the LLVM to a file called
<code>module.ll</code>, the C code to <code>runtime.c</code>, and then compile it using <code>clang</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clang</span> <span class="at">-Wno-override-module</span> <span class="at">-lm</span> module.ll runtime.c <span class="at">-o</span> a.out </span></code></pre></div>
<p>This should output an executable called <code>a.out</code>. If we run it, we should see
this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./a.out</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">42</span></span></code></pre></div>
<p>Hooray!</p>
<h2 id="compiling-our-programming-language-to-llvm">Compiling our programming language to LLVM</h2>
<p>OK. So now we’ve had a taste of the raw power available to us, let’s get down
to business. Although we could just create raw LLVM IR by hand, instead we will use the following
libraries:</p>
<p><a href="https://hackage.haskell.org/package/llvm-hs-pure">llvm-hs-pure</a> - a set of
types for LLVM IR, along with some helpful building functions.</p>
<p><a href="https://hackage.haskell.org/package/llvm-hs-pretty">llvm-hs-pretty</a> - a
prettyprinter for <code>llvm-hs-pure</code>.</p>
<p>We’ll use the datatypes in <code>llvm-hs-pure</code> to create modules, then use <code>llvm-hs-pretty</code> to render these to files and then compile by hand. This means that when we
invariably generate LLVM errors, we’ll at least we able to look at the error
and reference the code we’ve given it to try and work out what went wrong.</p>
<h3 id="shut-up-and-show-me-some-haskell-code">Shut up and show me some Haskell code</h3>
<p>The whole module can be seen
<a href="https://github.com/danieljharvey/llvm-calc/blob/trunk/llvm-calc/src/Calc/Compile/ToLLVM.hs">here</a>, but let’s look at the highlights:</p>
<hr />
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primToLLVM ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">LLVM.Operand</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>primToLLVM i <span class="ot">=</span> LLVM.int32 (<span class="fu">fromIntegral</span> i)</span></code></pre></div>
<p>This function creates integer literals from our <code>EPrim</code> constructors, using
the <a href="https://hackage.haskell.org/package/llvm-hs-pure-9.0.0/docs/LLVM-IRBuilder-Constant.html#v:int32">int32</a> function.
This returns an <code>Operand</code> (an LLVM value, broadly) that we can pass to other LLVM functions. We’ll
expand this function to include more types as we need them.</p>
<hr />
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exprToLLVM ::</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">LLVM.MonadIRBuilder</span> m,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LLVM.MonadModuleBuilder</span> m</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  m <span class="dt">LLVM.Operand</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>exprToLLVM (<span class="dt">EPrim</span> _ prim) <span class="ot">=</span> </span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> primToLLVM prim</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>exprToLLVM (<span class="dt">EInfix</span> _ <span class="dt">OpAdd</span> a b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  lhs <span class="ot">&lt;-</span> exprToLLVM a</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  rhs <span class="ot">&lt;-</span> exprToLLVM b</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  LLVM.add lhs rhs</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>exprToLLVM (<span class="dt">EInfix</span> _ <span class="dt">OpSubtract</span> a b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  lhs <span class="ot">&lt;-</span> exprToLLVM a</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  rhs <span class="ot">&lt;-</span> exprToLLVM b</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>  LLVM.sub lhs rhs</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>exprToLLVM (<span class="dt">EInfix</span> _ <span class="dt">OpMultiply</span> a b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  lhs <span class="ot">&lt;-</span> exprToLLVM a</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>  rhs <span class="ot">&lt;-</span> exprToLLVM b</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>  LLVM.mul lhs rhs</span></code></pre></div>
<p>Here we compile our <code>Expr</code> into and take care of adding /
subtracting / multiplying integers.</p>
<p>Because we’re using the <code>MonadIRBuilder</code>
and <code>MonadModuleBuilder</code>, it’s almost as if we’re writing code to do the
interpreting by hand, as all the actual code output is plumbed away in the
monad. If you squint, it looks very similar to the interpreter we wrote earlier, so if you
understand that, you pretty much understand this.</p>
<hr />
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | given our `Expr` type, turn it into an LLVM module</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">toLLVM ::</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">LLVM.Module</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>toLLVM expr <span class="ot">=</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  LLVM.buildModule <span class="st">&quot;example&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- import `printint` from our standard library</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- it takes an `i32` and returns an `i32`</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    printInt <span class="ot">&lt;-</span> LLVM.extern <span class="st">&quot;printint&quot;</span> [LLVM.i32] LLVM.i32</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- create a function called `main` that will be the entry point to our</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- program</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    LLVM.function <span class="st">&quot;main&quot;</span> [] LLVM.i32 <span class="op">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- build the LLVM AST for our expression</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>      ourExpression <span class="ot">&lt;-</span> exprToLLVM expr</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- print our result to stdout</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">&lt;-</span> LLVM.call printInt [(ourExpression, [])]</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- return success exit code of `0`</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>      LLVM.ret (LLVM.int32 <span class="dv">0</span>)</span></code></pre></div>
<p>Finally, we wrap up our compiled <code>Expr</code> and turn it into a
module. We are going to import <code>printint</code> from our standard library, output the
response of our computation to stdout, and then return exit code <code>0</code>.</p>
<p>Let’s look at the generated LLVM for <code>6 * 8 - 3</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'example'</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@printint</span>(<span class="dt">i32</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span> <span class="dt">i32</span> <span class="fu">@main</span>() {</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> = <span class="kw">mul</span>   <span class="dt">i32</span> <span class="dv">6</span>, <span class="dv">8</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%2</span> = <span class="kw">sub</span>   <span class="dt">i32</span> <span class="fu">%1</span>, <span class="dv">3</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%3</span> =  <span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">i32</span>  <span class="fu">@printint</span>(<span class="dt">i32</span>  <span class="fu">%2</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Hopefully, nothing too surprising.</p>
<h2 id="running-our-code">Running our code</h2>
<p>As with earlier, our little compiler works by pretty printing the LLVM module
we created, then running <code>clang</code> to compile it into an executable. I pretty
much stole the compiling code from
<a href="https://blog.josephmorag.com/posts/mcc3/">Micro-C</a> (thanks/sorry, Joseph!).
You can see our slightly tattered version
<a href="https://github.com/danieljharvey/llvm-calc/blob/trunk/llvm-calc/src/Calc/Compile/RunLLVM.hs">here</a> if for some reason you don’t believe any of this actually works.</p>
<h3 id="well-thats-that">Well that’s that</h3>
<p>Congratulations, you are all low-level compiler experts now. Hopefully that was
somewhat helpful. Next time we’ll be adding the equality operator and some basic control flow.
Exciting!</p>
<p>Make sense? If not, <a href="../contact.html">get in touch</a>!</p>
<p>Further reading:</p>
<p><a href="https://llvm.org/docs/LangRef.html">llvm reference</a></p>
<p><a href="https://github.com/danieljharvey/llvm-calc">llvm-calc</a></p>
    </section>
</article>

    </main>

    <footer>
      <p>Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
      <p>Links for nerds:
        <a href="../atom.xml">atom</a>
        <a href="../rss.xml">rss</a></p>

    </footer>
</body>

</html>
