<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Datatypes - Maybe</title>
    <link rel="stylesheet" href="../css/default.css" />
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Datatypes - Maybe</h1>
        <article>
    <section class="header">
        Posted on February 11, 2019
        
        <div class="info">
          
          Tags: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/datatype.html">datatype</a>, <a href="../tags/maybe.html">maybe</a>
          
        </div>
    </section>
    <section>
        <p>It’s one thing to understand typeclasses individually, but another to see them in context. Let’s take at one of the simplest, <code>Maybe</code>, define it’s instances, and get a feel for how it acts.</p>
<p>Let’s start with a definition. We have used <code>deriving</code> to auto-generate instances of the <code>Eq</code>, <code>Ord</code> and <code>Show</code> typeclasses as we don’t need anything special going on with them.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Just</span> a <span class="fu">|</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>As is hopefully apparently, <code>Maybe</code> can either be a <code>Just</code> with an <code>a</code> wrapped inside, or <code>Nothing</code> which holds no value.</p>
<h3 id="functor">Functor</h3>
<p>Next we’ll define a <code>functor</code> instance for <code>Maybe</code>. Essentially, if there is a value inside, let’s run the provided function over it, and if not, return the same <code>Nothing</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="fu">fmap</span> f (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dt">Just</span> (f a)</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">one ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" title="2">one <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">-- one == Just 2</span></a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">two ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-2" title="2">two <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">-- two == Nothing</span></a></code></pre></div>
<h3 id="applicative">Applicative</h3>
<p>The <code>applicative</code> instance for <code>Maybe</code> has two functions, <code>pure</code> and <code>&lt;*&gt;</code> (also called <code>ap</code>). We use <code>pure</code> to define a default instance of the datatype, so we just take the value and wrap it in <code>Just</code>. The <code>&lt;*&gt;</code> function is used to apply a function inside a <code>Just</code> to a value wrapped in another <code>Just</code>. Therefore, if either of those are a <code>Nothing</code>, that’s not going to work, so we return <code>Nothing</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">pure</span> a <span class="fu">=</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb5-3" title="3">  (<span class="dt">Just</span> f) <span class="fu">&lt;*&gt;</span> (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dt">Just</span> (f a)</a>
<a class="sourceLine" id="cb5-4" title="4">  _        <span class="fu">&lt;*&gt;</span> _        <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">three ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-2" title="2">three <span class="fu">=</span> <span class="fu">pure</span> <span class="dv">1</span> </a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">-- three == Just 1</span></a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">four ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" title="2">four <span class="fu">=</span> <span class="dt">Just</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">-- four == Just 2</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">five ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" title="2">five <span class="fu">=</span> <span class="dt">Just</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">&lt;*&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">-- five == Nothing</span></a></code></pre></div>
<h3 id="monad">Monad</h3>
<p>The <code>monad</code> instance for <code>Maybe</code> has only one additional function, <code>&gt;&gt;=</code> (or <code>bind</code>). The most important thing in the <code>Maybe</code> case is that if we start with a <code>Nothing</code>, then we don’t bother doing anything, allowing the computation to be shortcircuited, as such.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" title="2">  (<span class="dt">Just</span> a) <span class="fu">&gt;&gt;=</span> k   <span class="fu">=</span> k a</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _   <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">six ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-2" title="2">six <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">1</span> <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> <span class="dt">Just</span> (a <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">-- six == Just 2</span></a></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">seven ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-2" title="2">seven <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> <span class="dt">Just</span> (a <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">-- seven == Nothing</span></a></code></pre></div>
<h3 id="semigroup">Semigroup</h3>
<p>The <code>semigroup</code> instance for <code>Maybe</code> is used to combine multiple <code>Maybe</code> values together. An important thing to note is the constraint <code>Semigroup a</code> - this means that for two <code>Maybe</code> values to be combined, the values inside must also have a <code>semigroup</code> instance, allowing them to be combined as well.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">instance</span> (<span class="dt">Semigroup</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" title="2">  (<span class="dt">Just</span> a) <span class="fu">&lt;&gt;</span> (<span class="dt">Just</span> b) <span class="fu">=</span> <span class="dt">Just</span> (a <span class="fu">&lt;&gt;</span> b)</a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="dt">Nothing</span>  <span class="fu">&lt;&gt;</span> a        <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb12-4" title="4">  a        <span class="fu">&lt;&gt;</span> <span class="dt">Nothing</span>  <span class="fu">=</span> a</a></code></pre></div>
<h3 id="monoid">Monoid</h3>
<p>Notice that when a <code>Just</code> is combined with a <code>Nothing</code>, we still get a <code>Just</code> value. This is because <code>Nothing</code> is our <code>empty</code> element, meaning that when it is combined to any value it does not change it. Defining this upgrades our <code>semigroup</code> instance into an exciting <code>Monoid</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">instance</span> (<span class="dt">Semigroup</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="fu">mempty</span> <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<h3 id="foldable">Foldable</h3>
<p>Now carrying all these wrapped values around is great, but at some point we may want to extract values from these <code>Maybe</code> values, so we use <code>foldable</code>. Note the <code>a</code> in the <code>Nothing</code> version of the function - this makes the user of the typeclass provide a default value so that we don’t end up without a value for <code>Nothing</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="fu">foldr</span> _ a <span class="dt">Nothing</span>  <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="fu">foldr</span> f a (<span class="dt">Just</span> b) <span class="fu">=</span> f b a</a></code></pre></div>
<h3 id="alternative">Alternative</h3>
<p>A good intuition for the <code>Alternative</code> typeclass is that it’s a like the <code>or</code> operator <code>||</code>. Therefore it can be used to return the first out of a list of values that is wrapped in <code>Just</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">  empty                 <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb15-3" title="3">  (<span class="dt">Just</span> a) <span class="fu">&lt;|&gt;</span> _        <span class="fu">=</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="dt">Nothing</span>  <span class="fu">&lt;|&gt;</span> (<span class="dt">Just</span> b) <span class="fu">=</span> <span class="dt">Just</span> b</a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="dt">Nothing</span>  <span class="fu">&lt;|&gt;</span> <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<h3 id="monadplus">MonadPlus</h3>
<p>Since we’re on a roll with defining typeclasses, let’s plop in a quick instance of <code>MonadPlus</code>, which is basically <code>Alternative</code> with a different name, with <code>mzero</code> replacing <code>empty</code> and <code>mplus</code> replacing <code>&lt;|&gt;</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" title="2">  mzero <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4">  mplus (<span class="dt">Just</span> a) _ <span class="fu">=</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb16-5" title="5">  mplus (<span class="dt">Nothing</span>) (<span class="dt">Just</span> b) <span class="fu">=</span> <span class="dt">Just</span> b</a>
<a class="sourceLine" id="cb16-6" title="6">  mplus _ _ <span class="fu">=</span> <span class="dt">Nothing</span>  </a></code></pre></div>
<h3 id="traversable">Traversable</h3>
<p>The <code>traversable</code> instance for <code>Maybe</code> isn’t too unusual, if <code>traverse</code> is run on a <code>Nothing</code> it wraps a <code>Nothing</code> inside whichever <code>Applicative</code> it is used with (the <code>pure</code> function coming from the other type rather than from <code>Maybe</code>). If we <code>traverse</code> a <code>Just</code> value then the provided function <code>f</code> is run on the value inside <code>Just</code> which wraps the <code>a</code> in an <code>applicative</code> functor, and we then use <code>fmap</code> to make the value inside a <code>Just</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">instance</span> <span class="dt">Traversable</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="fu">traverse</span> _ <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="fu">pure</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="fu">traverse</span> f (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="fu">fmap</span> <span class="dt">Just</span> (f a)</a></code></pre></div>
<h3 id="monadfail">MonadFail</h3>
<p>The <code>MonadFail</code> typeclass hasn’t come up before, but it’s a very generic way of allowing all computations to fail in a similar way. The <code>fail</code> function has the type signature <code>String -&gt; m a</code>. However because we cannot carry around any values inside <code>Nothing</code> we simply discard the <code>String</code> and return <code>Nothing</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">instance</span> <span class="dt">MonadFail</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="fu">fail</span> _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<pre><code>   it &quot;Maybe Semigroup with Just&quot; $
  Just [1,2,3] &lt;&gt; Just [4,5,6] `shouldBe` Just [1,2,3,4,5,6]
it &quot;Maybe Semigroup with Nothing&quot; $
  Nothing &lt;&gt; Just [1,2,3] `shouldBe` Just [1,2,3]
it &quot;Maybe Semigroup with other Nothing&quot; $
  Just [1,2,3] &lt;&gt; Nothing `shouldBe` Just [1,2,3]
it &quot;Maybe Semigroup with all Nothing&quot; $
  Nothing &lt;&gt; Nothing `shouldBe` (Nothing :: Maybe [Int])
it &quot;Maybe Monoid&quot; $
  mempty `shouldBe` (Nothing :: Maybe [Int])
it &quot;Foldable Maybe with Nothing&quot; $
  foldr (+) 1 Nothing `shouldBe` 1
it &quot;Foldable Maybe with Just&quot; $
  foldr (+) 1 (Just 10) `shouldBe` 11
it &quot;Alternative ending in nothing&quot; $
  (Nothing &lt;|&gt; Nothing) `shouldBe` (Nothing :: Maybe Int)
it &quot;Alternative first&quot; $
  (Just 1 &lt;|&gt; Just 2) `shouldBe` Just 1
it &quot;Alternative second&quot; $
  (Nothing &lt;|&gt; Just 2) `shouldBe` Just 2
it &quot;Traverses list Nothing&quot; $
  traverse (\a -&gt; [a,a]) (Nothing :: Maybe Int) `shouldBe` [Nothing]
it &quot;Traverses list and Just 1&quot; $
    (traverse (\a -&gt; [a,a]) $ Just 10) `shouldBe` [Just 10, Just 10]
it &quot;Monad fail returns Nothing&quot; $
  (Just &quot;yes&quot; &gt;&gt;= fail) `shouldBe` (Nothing :: Maybe String)
it &quot;MonadPlus append Nothings&quot; $
  (Nothing `mplus` Nothing) `shouldBe` (Nothing :: Maybe Int)
it &quot;MonadPlus append first Just&quot; $
  (Just 1 `mplus` Nothing) `shouldBe` Just 1
it &quot;MonadPlus append second Just&quot; $
  (Nothing `mplus` Just 2) `shouldBe` Just 2
it &quot;MonadPlus empty&quot; $
  (mzero :: Maybe Int) `shouldBe` Nothing
it &quot;MonadZip mzipWith&quot; $
  mzip (Just 1) (Just 2) `shouldBe` Just (1,2)
it &quot;MonadZip mzipWith fail&quot; $
  mzip (Just 1) Nothing `shouldBe` (Nothing :: Maybe (Int, Int))</code></pre>
    </section>
</article>

    </main>

    <footer>
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
</body>

</html>
