<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Compiling a functional language to LLVM, part 2</title>
    <link rel="stylesheet" href="../css/default.css" />

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Compiling a functional language to LLVM, part 2</h1>
        <article>
    <section class="header">
        Posted on February 23, 2023
        
        <div class="info">
          
          Tags: <a title="All pages tagged 'plt'." href="../tags/plt.html">plt</a>, <a title="All pages tagged 'mimsa'." href="../tags/mimsa.html">mimsa</a>, <a title="All pages tagged 'typechecker'." href="../tags/typechecker.html">typechecker</a>, <a title="All pages tagged 'llvm'." href="../tags/llvm.html">llvm</a>
          
        </div>
    </section>
    <section>
        <p>Welcome to part 2 of this series in compiling functional languages to LLVM. In
<a href="../posts/2023-02-08-llvm-compiler-part-1.html">part 1</a> we created a very simple
calculator that let us add, subtract and multiply integers like <code>1 + 1</code> or <code>6 * (5 - 2)</code>.</p>
<p>Today we’re going to spice things up a touch by adding some basic control flow.
By the end of today we’re going to be writing sweet syntax such as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">2</span> + 2 == 5</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="ex">6</span> == 6 then False else True</span></code></pre></div>
<h2 id="whats-new-then">What’s new then?</h2>
<p>To make our dreams come true, we’re going to two new
syntactic features:</p>
<ul>
<li><p><code>if</code> expressions</p></li>
<li><p>an <code>==</code> infix operator</p></li>
</ul>
<p>Let’s do that now!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | operators for combining expressions</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Op</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">OpAdd</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OpMultiply</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OpSubtract</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OpEquals</span> <span class="co">-- this is new! </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Expressions, decorated with some unknown `ann`</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> ann</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">EPrim</span> ann <span class="dt">Prim</span> <span class="co">-- this `Prim` used to always be `Int`</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EInfix</span> ann <span class="dt">Op</span> (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EIf</span> ann (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann) <span class="co">-- this is new!</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<p>Our <code>EIf</code> constructor takes three <code>Expr ann</code> as arguments. The first is the
<code>predicate</code>, ie, the thing that must evaluate to <code>True</code> or <code>False</code>, and the
other two are expressions to be evaluated on the <code>then</code> and <code>else</code> branches.
For all of this to make any sense, these will need to be the same type.</p>
<h2 id="types">Types?</h2>
<p>Previously we sort of glossed over the idea of types, because every value in
our calculator was either an <code>Integer</code> (ie, <code>1</code>, <code>42</code>) or an expression that would eventually
evaluate into an <code>Integer</code> (like <code>1 + 1</code>, <code>6 * 12</code>).</p>
<p>However, the expression <code>1 == 1</code> doesn’t resolve to an <code>Integer</code>, it can only
be <code>True</code> or <code>False</code>, ie a <code>Boolean</code> type. (it is true that we could express
this with an <code>Integer</code> but if we start cutting corners this early in the game
we’ll never get anywhere). This means we’ll need to extend our <code>Prim</code> type to also describe <code>Boolean</code> values as
well as <code>Integer</code>s.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | types of basic values</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Prim</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">PInt</span> <span class="dt">Integer</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PBool</span> <span class="dt">Bool</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>However this means we are in danger of our users being able to make silly mistakes like <code>if 27 then False else 6</code>? How can we stop this? This can only mean one thing: we are going to need
to write a bidirectional type checker.</p>
<h3 id="bidirect-what">Bidirect what?</h3>
<p>A bidirectional type checker is a way of working which types parts of an
expression has, and identifying parts that don’t make sense. What makes it
“bidirectional” is that it works in two “modes”:</p>
<ul>
<li><code>infer</code> mode: given an expression, give me the type</li>
<li><code>check</code> mode: given an expression and the type we think it has, give me the
type</li>
</ul>
<p>The broad idea is when we don’t know anything about an expression, we <code>infer</code>
what types it has, but as we learn more, we use that information to help us
work the rest out. Although we could arguably get away with just an <code>infer</code> mode for a language
this simple, we will need this special two-way magic in future.</p>
<p>Enough waffle, let’s see some code, and then talk about it.</p>
<h3 id="code">Code</h3>
<p>Firstly, we need a type for types. We’ll call it <code>Type</code>. We are adding an <code>ann</code>
type argument to it, so that we can attach source code locations etc. This will
be helpful for showing our user helpful errors, which we will be doing today:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypePrim</span> <span class="ot">=</span> <span class="dt">TBool</span> <span class="op">|</span> <span class="dt">TInt</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- the `ann` is used to attach source code location etc</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span> ann</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TPrim</span> ann <span class="dt">TypePrim</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<h3 id="things-go-wrong">Things go wrong</h3>
<p>Any old typechecker can tell you when things are going well, but the ones that
are really worth their salt are the ones that tell you helpfully what is going
wrong. We will need these ones:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeError</span> ann</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">PredicateIsNotBoolean</span> ann (<span class="dt">Type</span> ann)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">InfixTypeMismatch</span> <span class="dt">Op</span> [(<span class="dt">Type</span> ann, <span class="dt">Type</span> ann)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TypeMismatch</span> (<span class="dt">Type</span> ann) (<span class="dt">Type</span> ann)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<h3 id="the-meat-of-the-thing">The meat of the thing</h3>
<p>Therefore, the point of the typechecker is to take <code>Expr ann</code> (ie, an <code>Expr</code>
carrying around some <code>ann</code> that does not concern us), and turn it into either
<code>TypeError ann</code> or <code>Expr (Type ann)</code>.</p>
<p><code>Expr (Type ann)</code> means that we’ll have “decorated” each part of the <code>Expr</code>
with it’s type. We’ll take whatever <code>ann</code> was in there and put it in the <code>Type</code>
instead. For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">oneWhichIsAnInteger ::</span> <span class="dt">Expr</span> (<span class="dt">Type</span> ())</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>oneWhichIsAnInteger <span class="ot">=</span> <span class="dt">EPrim</span> (<span class="dt">TPrim</span> () <span class="dt">TInt</span>) (<span class="dt">PInt</span> <span class="dv">1</span>)</span></code></pre></div>
<p>The entire typechecker lives
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc2/src/Calc/Typecheck/Elaborate.hs">here</a>.
Let’s go through the key parts:</p>
<hr />
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | this is the function we run</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">elaborate ::</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">TypeError</span> ann) (<span class="dt">Expr</span> (<span class="dt">Type</span> ann))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>elaborate <span class="ot">=</span> infer <span class="co">-- start with `infer` because we know nothing</span></span></code></pre></div>
<p><code>elaborate</code> is the function the typechecker exports. It takes an untypechecked
<code>Expr ann</code> and returns either <code>Expr (Type ann)</code> or an excuse. It starts by
running <code>infer</code>, which we’ll see shortly.</p>
<hr />
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeFromPrim ::</span> ann <span class="ot">-&gt;</span> <span class="dt">Prim</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> ann</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>typeFromPrim ann (<span class="dt">PInt</span> _) <span class="ot">=</span> <span class="dt">TPrim</span> ann <span class="dt">TInt</span> <span class="co">-- It's an Integer!</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>typeFromPrim ann (<span class="dt">PBool</span> _) <span class="ot">=</span> <span class="dt">TPrim</span> ann <span class="dt">TBool</span> <span class="co">-- It's a Boolean!</span></span></code></pre></div>
<p>The most basic type inference we can do is looking at a primitive value. As it
stands in our language, there is one number type and one boolean type, so we
can unambiguously work out the type just by looking at the value.</p>
<hr />
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inferIf ::</span> ann <span class="ot">-&gt;</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">TypeError</span> ann) (<span class="dt">Expr</span> (<span class="dt">Type</span> ann))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>inferIf ann predExpr thenExpr elseExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  predA <span class="ot">&lt;-</span> infer predExpr</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> getOuterAnnotation predA <span class="kw">of</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TPrim</span> _ <span class="dt">TBool</span>) <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    otherType <span class="ot">-&gt;</span> throwError (<span class="dt">PredicateIsNotBoolean</span> ann otherType)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  thenA <span class="ot">&lt;-</span> infer thenExpr</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  elseA <span class="ot">&lt;-</span> check (getOuterAnnotation thenA) elseExpr</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">EIf</span> (getOuterAnnotation elseA) predA thenA elseA)</span></code></pre></div>
<p>This is how <code>if</code> works. We <code>infer</code> the type of the predicate, then use
<code>getOuterAnnotation</code> to get the <code>Type ann</code> out of it. We then case match on it
to see if it’s a <code>Boolean</code> or not, “throwing” an error if not.</p>
<hr />
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inferInfix ::</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  ann <span class="ot">-&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Op</span> <span class="ot">-&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Either</span> (<span class="dt">TypeError</span> ann) (<span class="dt">Expr</span> (<span class="dt">Type</span> ann))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>inferInfix ann <span class="dt">OpEquals</span> a b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  elabA <span class="ot">&lt;-</span> infer a</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  elabB <span class="ot">&lt;-</span> infer b</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  ty <span class="ot">&lt;-</span> <span class="kw">case</span> (getOuterAnnotation elabA, getOuterAnnotation elabB) <span class="kw">of</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TPrim</span> _ tA, <span class="dt">TPrim</span> _ tB)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> tA <span class="op">==</span> tB <span class="ot">-&gt;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- if the types are the same, then great! it's a bool!</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> (<span class="dt">TPrim</span> ann <span class="dt">TBool</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    (otherA, otherB) <span class="ot">-&gt;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- otherwise, error!</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      throwError (<span class="dt">TypeMismatch</span> otherA otherB)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">EInfix</span> ty <span class="dt">OpEquals</span> elabA elabB)</span></code></pre></div>
<p>When typechecking <code>==</code>, we want to make sure both sides have the same type,
“throwing” an error if not.</p>
<hr />
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>inferInfix ann op a b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  elabA <span class="ot">&lt;-</span> infer a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  elabB <span class="ot">&lt;-</span> infer b</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- all the other infix operators need to be Int -&gt; Int -&gt; Int</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  ty <span class="ot">&lt;-</span> <span class="kw">case</span> (getOuterAnnotation elabA, getOuterAnnotation elabB) <span class="kw">of</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TPrim</span> _ <span class="dt">TInt</span>, <span class="dt">TPrim</span> _ <span class="dt">TInt</span>) <span class="ot">-&gt;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- if the types are the same, then great! it's an int!</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> (<span class="dt">TPrim</span> ann <span class="dt">TInt</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TPrim</span> _ <span class="dt">TInt</span>, other) <span class="ot">-&gt;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>      throwError</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        ( <span class="dt">InfixTypeMismatch</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            op</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            [ ( <span class="dt">TPrim</span> (getOuterTypeAnnotation other) <span class="dt">TInt</span>,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                other</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    (other, <span class="dt">TPrim</span> _ <span class="dt">TInt</span>) <span class="ot">-&gt;</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>      throwError</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        ( <span class="dt">InfixTypeMismatch</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            op</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            [ ( <span class="dt">TPrim</span> (getOuterTypeAnnotation other) <span class="dt">TInt</span>,</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>                other</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    (otherA, otherB) <span class="ot">-&gt;</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- otherwise, error!</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>      throwError</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        ( <span class="dt">InfixTypeMismatch</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>            op</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>            [ (<span class="dt">TPrim</span> (getOuterTypeAnnotation otherA) <span class="dt">TInt</span>, otherA),</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>              (<span class="dt">TPrim</span> (getOuterTypeAnnotation otherB) <span class="dt">TInt</span>, otherB)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">EInfix</span> ty op elabA elabB)</span></code></pre></div>
<p>Here are the other operators. Both the arguments should be <code>Integer</code> and the
return type is <code>Integer</code>, otherwise we construct and return an error type. It
seems like a lot of work to be so specific, but look how helpful our errors
are!</p>
<figure>
<img src="../images/llvm-2-type-error-1.png" title="Nice!" alt="Nice!" />
<figcaption aria-hidden="true">Nice!</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-2.png" title="Great!" alt="Great!" />
<figcaption aria-hidden="true">Great!</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-3.png" title="Tremendous!" alt="Tremendous!" />
<figcaption aria-hidden="true">Tremendous!</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-4.png" title="Whoa!" alt="Whoa!" />
<figcaption aria-hidden="true">Whoa!</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-5.png" title="What?" alt="What?" />
<figcaption aria-hidden="true">What?</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-6.png" title="Absolutely!" alt="Absolutely!" />
<figcaption aria-hidden="true">Absolutely!</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-7.png" title="Surely not?" alt="Surely not?" />
<figcaption aria-hidden="true">Surely not?</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-8.png" title="Ridiculous!" alt="Ridiculous!" />
<figcaption aria-hidden="true">Ridiculous!</figcaption>
</figure>
<figure>
<img src="../images/llvm-2-type-error-9.png" title="Huh?" alt="Huh?" />
<figcaption aria-hidden="true">Huh?</figcaption>
</figure>
<p>You can see all the error rendering code
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc2/src/Calc/Typecheck/Error.hs">here</a>.</p>
<hr />
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">infer ::</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">TypeError</span> ann) (<span class="dt">Expr</span> (<span class="dt">Type</span> ann))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>infer (<span class="dt">EPrim</span> ann prim) <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">EPrim</span> (typeFromPrim ann prim) prim)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>infer (<span class="dt">EIf</span> ann predExpr thenExpr elseExpr) <span class="ot">=</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  inferIf ann predExpr thenExpr elseExpr</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>infer (<span class="dt">EInfix</span> ann op a b) <span class="ot">=</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  inferInfix ann op a b</span></code></pre></div>
<p>That’s how we put <code>infer</code> together, easy!</p>
<hr />
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">check ::</span> <span class="dt">Type</span> ann <span class="ot">-&gt;</span> <span class="dt">Expr</span> ann <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">TypeError</span> ann) (<span class="dt">Expr</span> (<span class="dt">Type</span> ann))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>check ty expr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  exprA <span class="ot">&lt;-</span> infer expr</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> void (getOuterAnnotation exprA) <span class="op">==</span> void ty</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="fu">pure</span> (expr <span class="op">$&gt;</span> ty)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> throwError (<span class="dt">TypeMismatch</span> ty (getOuterAnnotation exprA))</span></code></pre></div>
<p>Lastly, here’s <code>check</code>. We only use it when comparing arms of <code>if</code> statements,
but soon this will become more interesting.</p>
<p>You can see all of the typechecker code
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc2/src/Calc/Typecheck/Elaborate.hs">here</a>.</p>
<hr />
<h2 id="interpreting-our-new-friends">Interpreting our new friends</h2>
<p>Before heading back into LLVM land, let’s update our manual interpreter so we
can understand what’s needed here.</p>
<p>Firstly, it’s now possible that our interpreter can fail. This will only happen
if our typechecker is not working as expected, but we should make a proper
error type for it anyway because we are good programmers who care about our
users.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">InterpreterError</span> ann</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">NonBooleanPredicate</span> ann (<span class="dt">Expr</span> ann)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>Interpreting infix expressions is a little bit more complicated, as our pattern
matches have to make sure we’re looking at the right <code>Prim</code> values. The
eagle-eyed may notice that a broken typechecker could send this into a loop.
Can you see where?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpretInfix ::</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">MonadError</span> (<span class="dt">InterpreterError</span> ann) m) <span class="ot">=&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  ann <span class="ot">-&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Op</span> <span class="ot">-&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  m (<span class="dt">Expr</span> ann)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpAdd</span> (<span class="dt">EPrim</span> _ (<span class="dt">PInt</span> a)) (<span class="dt">EPrim</span> _ (<span class="dt">PInt</span> b)) <span class="ot">=</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EPrim</span> ann (<span class="dt">PInt</span> <span class="op">$</span> a <span class="op">+</span> b)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpSubtract</span> (<span class="dt">EPrim</span> _ (<span class="dt">PInt</span> a)) (<span class="dt">EPrim</span> _ (<span class="dt">PInt</span> b)) <span class="ot">=</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EPrim</span> ann (<span class="dt">PInt</span> <span class="op">$</span> a <span class="op">-</span> b)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpMultiply</span> (<span class="dt">EPrim</span> _ (<span class="dt">PInt</span> a)) (<span class="dt">EPrim</span> _ (<span class="dt">PInt</span> b)) <span class="ot">=</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EPrim</span> ann (<span class="dt">PInt</span> <span class="op">$</span> a <span class="op">*</span> b)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>interpretInfix ann <span class="dt">OpEquals</span> (<span class="dt">EPrim</span> _ a) (<span class="dt">EPrim</span> _ b) <span class="ot">=</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EPrim</span> ann (<span class="dt">PBool</span> <span class="op">$</span> a <span class="op">==</span> b)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>interpretInfix ann op a b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  iA <span class="ot">&lt;-</span> interpret a</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  iB <span class="ot">&lt;-</span> interpret b</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  interpretInfix ann op iA iB</span></code></pre></div>
<p>We ended up with a <code>MonadError</code> constraint above - why’s that? It’s because the
main <code>interpret</code> function can now “explode” if we try and match a non-predicate
in an if statement. Our typechecker <em>should</em> stop this happening of course.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | just keep reducing the thing until the smallest thing</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">interpret ::</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">MonadError</span> (<span class="dt">InterpreterError</span> ann) m</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> ann <span class="ot">-&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  m (<span class="dt">Expr</span> ann)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">EPrim</span> ann p) <span class="ot">=</span> <span class="fu">pure</span> (<span class="dt">EPrim</span> ann p)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">EInfix</span> ann op a b) <span class="ot">=</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  interpretInfix ann op a b</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">EIf</span> ann predExpr thenExpr elseExpr) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  predA <span class="ot">&lt;-</span> interpret predExpr</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> predA <span class="kw">of</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">EPrim</span> _ (<span class="dt">PBool</span> <span class="dt">True</span>)) <span class="ot">-&gt;</span> interpret thenExpr</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">EPrim</span> _ (<span class="dt">PBool</span> <span class="dt">False</span>)) <span class="ot">-&gt;</span> interpret elseExpr</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    other <span class="ot">-&gt;</span> throwError (<span class="dt">NonBooleanPredicate</span> ann other)</span></code></pre></div>
<p>We interpret if statements by reducing the predicate down to a boolean, then
taking a peek, and then interpreting the appropriate branch. If we don’t need a
branch, there’s no need to interpret it!</p>
<p>You can see all of the interpreter code
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc2/src/Calc/Interpreter.hs">here</a>.</p>
<h2 id="ok-llvm-time">OK, LLVM time</h2>
<p>I feel like I’m rushing through all this, and maybe copy pasta-ing an entire
typechecker in the preamble was somewhat undisclined of me.</p>
<p>BUT, here we go.</p>
<h3 id="digression">Digression</h3>
<p>Firstly, we’ll add a new function to our C “standard library”:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printbool<span class="op">(</span><span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span>b <span class="op">?</span> <span class="st">&quot;True&quot;</span> <span class="op">:</span> <span class="st">&quot;False&quot;</span><span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It will take an LLVM boolean, and print either <code>True</code> or <code>False</code> depending on
whether it is <code>0</code> or not.</p>
<h3 id="to-the-ir">To the IR!</h3>
<p>We’re going to start by looking at the LLVM IR for the following arbitrary
expression:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="ex">2</span> == 1 then True else False </span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'example'</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span>  <span class="dt">void</span> <span class="fu">@printbool</span>(<span class="dt">i1</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">i32</span> <span class="fu">@main</span>()    {</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> = <span class="kw">icmp</span> <span class="kw">eq</span> <span class="dt">i32</span> <span class="dv">2</span>, <span class="dv">1</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%2</span> = <span class="kw">alloca</span> <span class="dt">i1</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">i1</span> <span class="fu">%1</span>, <span class="dt">label</span> <span class="fu">%then_0</span>, <span class="dt">label</span> <span class="fu">%else_0</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="fu">then_0:</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">store</span>   <span class="dt">i1</span> <span class="dv">1</span>, <span class="dt">i1</span>* <span class="fu">%2</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%done_0</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="fu">else_0:</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">store</span>   <span class="dt">i1</span> <span class="dv">0</span>, <span class="dt">i1</span>* <span class="fu">%2</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%done_0</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="fu">done_0:</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%3</span> = <span class="kw">load</span>   <span class="dt">i1</span>, <span class="dt">i1</span>* <span class="fu">%2</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>   <span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">void</span>  <span class="fu">@printbool</span>(<span class="dt">i1</span>  <span class="fu">%3</span>)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>What a ride! Let’s take it line by line.</p>
<hr />
<div class="sourceCode" id="cb20"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'example'</span></span></code></pre></div>
<p>Once again, let’s ease ourselves in with a code comment.</p>
<hr />
<div class="sourceCode" id="cb21"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span>  <span class="dt">void</span> <span class="fu">@printbool</span>(<span class="dt">i1</span>)</span></code></pre></div>
<p>Declaration for the new function in our standard library. It takes an <code>i1</code> (a
boolean, stored as <code>0</code> or <code>1</code>) and returns <code>void</code>.</p>
<hr />
<div class="sourceCode" id="cb22"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">i32</span> <span class="fu">@main</span>()    {</span></code></pre></div>
<p>We define the <code>main</code> function, which is the entry point of our program. It
takes no arguments, and returns an <code>i32</code> integer value (which becomes the exit
code).</p>
<hr />
<div class="sourceCode" id="cb23"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">%1</span> = <span class="kw">icmp</span> <span class="kw">eq</span> <span class="dt">i32</span> <span class="dv">2</span>, <span class="dv">1</span></span></code></pre></div>
<p>Here we are making a new variable, <code>%1</code>, by comparing two integers, <code>2</code> and
<code>1</code>, using <code>eq</code>. This is our <code>2 == 1</code> expression, and maps across quite neatly.</p>
<hr />
<div class="sourceCode" id="cb24"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">%2</span> = <span class="kw">alloca</span> <span class="dt">i1</span></span></code></pre></div>
<p>To make control flow works, we are going to need to jump to different places.
However, LLVM has no way of passing a value back between sections. Therefore,
we are going to create a mutable placeholder for the result, and each branch
will be responsible for storing the result here. <code>alloca</code> is broadly “allocate
memory” and <code>i1</code> is the LLVM type for a <code>Boolean</code>.</p>
<hr />
<div class="sourceCode" id="cb25"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">br</span> <span class="dt">i1</span> <span class="fu">%1</span>, <span class="dt">label</span> <span class="fu">%then_0</span>, <span class="dt">label</span> <span class="fu">%else_0</span></span></code></pre></div>
<p>This is where we do the branching. <code>br</code> takes an <code>i1</code> value for the predicate,
and then two labels for blocks that we’ll jump to depending on the value of the predicate.
Therefore if <code>%1</code> is <code>1</code> we’ll jump to <code>then_0</code>, otherwise we’ll jump to
<code>else_0</code>. We’ll define these shortly.</p>
<hr />
<div class="sourceCode" id="cb26"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">then_0:</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">store</span>   <span class="dt">i1</span> <span class="dv">1</span>, <span class="dt">i1</span>* <span class="fu">%2</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%done_0</span></span></code></pre></div>
<p>This defines a block labelled <code>then_0</code>. We will “jump” here in the “then” case
of the if statement. We store <code>1</code> in the <code>%2</code> variable, and then jump to the
<code>done_0</code> block.</p>
<hr />
<div class="sourceCode" id="cb27"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">else_0:</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">store</span>   <span class="dt">i1</span> <span class="dv">0</span>, <span class="dt">i1</span>* <span class="fu">%2</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%done_0</span></span></code></pre></div>
<p>This defines a block labelled <code>else_0</code>. We will “jump” here in the “else” case.
Once again, we store <code>0</code> in the <code>%2</code> variable, and then jump to <code>done_0</code>.</p>
<hr />
<div class="sourceCode" id="cb28"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">done_0:</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%3</span> = <span class="kw">load</span>   <span class="dt">i1</span>, <span class="dt">i1</span>* <span class="fu">%2</span></span></code></pre></div>
<p>This introduces a new block called <code>done_0</code>. As our if construct is an
expression, we always need to return something, so ee jump here when the
<code>then</code> or <code>expr</code> branches are finishing doing their business, and load whatever
they stored in <code>%2</code>.</p>
<hr />
<div class="sourceCode" id="cb29"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">void</span>  <span class="fu">@printbool</span>(<span class="dt">i1</span>  <span class="fu">%3</span>)</span></code></pre></div>
<p>Call the <code>printbool</code> function from our standard library with the loaded value.</p>
<hr />
<div class="sourceCode" id="cb30"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span></code></pre></div>
<p>As our program succeeded, we return a <code>0</code>, this becomes our exit code.</p>
<hr />
<div class="sourceCode" id="cb31"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As a little palette cleanser, a nice closing brace.</p>
<h3 id="generating-it-from-haskell">Generating it from Haskell</h3>
<p>Now we have <code>Boolean</code> as well as <code>Integer</code> values, we’ll need to represent them
in LLVM. We’ll use a <code>bit</code> which is a 1-bit LLVM number to represent
<code>Boolean</code>s.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primToLLVM ::</span> <span class="dt">Prim</span> <span class="ot">-&gt;</span> <span class="dt">LLVM.Operand</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>primToLLVM (<span class="dt">PInt</span> i) <span class="ot">=</span> LLVM.int32 (<span class="fu">fromIntegral</span> i)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>primToLLVM (<span class="dt">PBool</span> <span class="dt">True</span>) <span class="ot">=</span> LLVM.bit <span class="dv">1</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>primToLLVM (<span class="dt">PBool</span> <span class="dt">False</span>) <span class="ot">=</span> LLVM.bit <span class="dv">0</span></span></code></pre></div>
<p>Now we’ll need to choose the right printing function:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- import the correct output function from our standard library</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- depending on the output type of our expression</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">printFunction ::</span> (<span class="dt">LLVM.MonadModuleBuilder</span> m) <span class="ot">=&gt;</span> <span class="dt">Type</span> ann <span class="ot">-&gt;</span> m <span class="dt">LLVM.Operand</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>printFunction (<span class="dt">TPrim</span> _ <span class="dt">TInt</span>) <span class="ot">=</span> LLVM.extern <span class="st">&quot;printint&quot;</span> [LLVM.i32] LLVM.void</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>printFunction (<span class="dt">TPrim</span> _ <span class="dt">TBool</span>) <span class="ot">=</span> LLVM.extern <span class="st">&quot;printbool&quot;</span> [LLVM.i1] LLVM.void</span></code></pre></div>
<p>The most interesting part is <code>if</code> expressions. We use the <code>RecursiveDo</code>
extension, which gives us the <code>mdo</code> syntax. This lets us use bindings before
they are created. This will allow us to use <code>thenBlock</code> and <code>elseBlock</code> before
they’re defined. We create IR for the <code>predExpr</code>, then pass it to
<code>LLVM.condBr</code>, which will then jump to the appropriate block depending on the
value.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ifToLLVM ::</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">LLVM.MonadIRBuilder</span> m, <span class="dt">LLVM.MonadModuleBuilder</span> m, <span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Type</span> ann <span class="ot">-&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> (<span class="dt">Type</span> ann) <span class="ot">-&gt;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> (<span class="dt">Type</span> ann) <span class="ot">-&gt;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Expr</span> (<span class="dt">Type</span> ann) <span class="ot">-&gt;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  m <span class="dt">LLVM.Operand</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>ifToLLVM tyReturn predExpr thenExpr elseExpr <span class="ot">=</span> mdo</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create IR for predicate</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  irPred <span class="ot">&lt;-</span> exprToLLVM predExpr</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- make variable for return value</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>  irReturnValue <span class="ot">&lt;-</span> LLVM.alloca (typeToLLVM tyReturn) <span class="dt">Nothing</span> <span class="dv">0</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- this does the switching</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- we haven't created these blocks yet but RecursiveDo lets us do this with</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- MonadFix magic</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>  LLVM.condBr irPred thenBlock elseBlock</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create a block for the 'then` branch</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>  thenBlock <span class="ot">&lt;-</span> LLVM.block <span class="ot">`LLVM.named`</span> <span class="st">&quot;then&quot;</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create ir for the then branch</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>  irThen <span class="ot">&lt;-</span> exprToLLVM thenExpr</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- store the result in irResultValue</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>  LLVM.store irReturnValue <span class="dv">0</span> irThen</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- branch back to the 'done' block</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>  LLVM.br doneBlock</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create a block for the 'else' branch</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>  elseBlock <span class="ot">&lt;-</span> LLVM.block <span class="ot">`LLVM.named`</span> <span class="st">&quot;else&quot;</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create ir for the else branch</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>  irElse <span class="ot">&lt;-</span> exprToLLVM elseExpr</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- store the result in irReturnValue</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>  LLVM.store irReturnValue <span class="dv">0</span> irElse</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- branch back to the `done` block</span></span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>  LLVM.br doneBlock</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create a block for 'done' that we always branch to</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>  doneBlock <span class="ot">&lt;-</span> LLVM.block <span class="ot">`LLVM.named`</span> <span class="st">&quot;done&quot;</span></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- load the result and return it</span></span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>  LLVM.load irReturnValue <span class="dv">0</span></span></code></pre></div>
<p>To work out which kind of type to <code>alloca</code>, we take the return type and use it
to work which LLVM type to use.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeToLLVM ::</span> <span class="dt">Type</span> ann <span class="ot">-&gt;</span> <span class="dt">LLVM.Type</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>typeToLLVM (<span class="dt">TPrim</span> _ <span class="dt">TBool</span>) <span class="ot">=</span> LLVM.i1</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>typeToLLVM (<span class="dt">TPrim</span> _ <span class="dt">TInt</span>) <span class="ot">=</span> LLVM.i32</span></code></pre></div>
<p>You can see all of the LLVM conversion code
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc2/src/Calc/Compile/ToLLVM.hs">here</a>.</p>
<hr />
<h3 id="well-thats-that">Well that’s that</h3>
<p>Congratulations, you are all bidirectional type checking experts now. Hopefully that was
somewhat helpful. Next time we’ll be adding basic functions and variables.
Great!</p>
<p>Make sense? If not, <a href="../contact.html">get in touch</a>!</p>
<p>Further reading:</p>
<p><a href="https://llvm.org/docs/LangRef.html">llvm reference</a></p>
<p><a href="https://github.com/danieljharvey/mimsa">mimsa</a></p>
    </section>
</article>

    </main>

    <footer>
      <p>Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
      <p>Links for nerds:
        <a href="../atom.xml">atom</a>
        <a href="../rss.xml">rss</a></p>

    </footer>
</body>

</html>
