<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Monoid, Mate</title>
    <link rel="stylesheet" href="../css/default.css" />
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../about.html">About</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Monoid, Mate</h1>
        <article>
    <section class="header">
        Posted on October 22, 2018
        
    </section>
    <section>
        <p>The thing I have found the most difficult to get my head around in the world of Haskell and categories etc is when I spend some time finding about a subject only to realise it’s describing something I already understand in some way. I feel cheated! Why must I learn new words for this! And you’re being so vague about it!</p>
<p>One such notion is that of the <code>Monoid</code> and it’s weaker cousin <code>Semigroup</code> (Weaker? What? We’ll come to it…)</p>
<p>I’ll explain Monoid first, as although it’s more complicated, it’s way easier to find usable examples for it. Let’s start with a couple of those, and then work out what the generalisation is.</p>
<p>A good one is strings.</p>
<p>Let’s say we have two string: <code>&quot;nice&quot;</code> and <code>&quot;dog&quot;</code>. We can combine them using something like <code>concat</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">concat</span><span class="ot"> ::</span> string <span class="ot">-&gt;</span> string <span class="ot">-&gt;</span> string</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">concat</span> a b <span class="fu">=</span> a <span class="fu">++</span> b</a></code></pre></div>
<p>This can be used thus: <code>concat &quot;nice&quot; &quot;dog&quot;</code> and will produce <code>&quot;nicedog&quot;</code>.</p>
<p>That’s great for two strings, but what if we have a whole list of strings that we want to smash together into one giant magnificent string?</p>
<p>Enter foldr (fold right). The signature is a bit of beast, so let’s break it down.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="fu">foldr</span> f z [] <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="fu">foldr</span> f z (x <span class="fu">:</span> xs) <span class="fu">=</span> x <span class="ot">`f`</span> <span class="fu">foldr</span> f z xs</a></code></pre></div>
<p>It actually takes three arguments:</p>
<ol type="1">
<li>A function with the type <code>a -&gt; b -&gt; b</code>.</li>
<li>The starting value for the fold of type <code>b</code>.</li>
<li>A list of values we wish to add together of type <code>[a]</code> - in our example this could be <code>[&quot;hot&quot;, &quot;dog&quot;, &quot;jumping&quot;, &quot;frog&quot;, &quot;albuquerque&quot;]</code>.</li>
</ol>
<p>If you squint, you’re pretty much looking at the <code>array.reduce</code> function in Javascript.</p>
<p>(What is important to note when looking at signatures for functions like this is that <code>a</code> and <code>b</code> may happen to be the same type - the important thing here is that they don’t have to be. When using a list of strings like we are, the type is actually <code>(string -&gt; string -&gt; string) -&gt; string -&gt; [string] -&gt; string</code> which is simultaneously more and less confusing.)</p>
<p>Let’s trying using it with our string <code>concat</code> function from earlier.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">stringList ::</span> [string]</a>
<a class="sourceLine" id="cb3-2" title="2">stringList <span class="fu">=</span> [<span class="st">&quot;hot&quot;</span>,<span class="st">&quot;dog&quot;</span>,<span class="st">&quot;jumping&quot;</span>,<span class="st">&quot;frog&quot;</span>,<span class="st">&quot;albuquerque&quot;</span>]</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">output ::</span> string</a>
<a class="sourceLine" id="cb3-5" title="5">output <span class="fu">=</span> <span class="fu">foldr</span> <span class="fu">concat</span> <span class="st">&quot;&quot;</span> stringList</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co">-- output = &quot;hotdogjumpingfrogalbuquerque&quot;</span></a></code></pre></div>
<p>Great! Hopefully this all makes sense - we passed <code>foldr</code> a function for combining strings and a starting value of an empty string. Why the starting value? Well, what would happen if we folded over an empty list?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">output2 <span class="fu">=</span> <span class="fu">foldr</span> <span class="fu">concat</span> <span class="st">&quot;&quot;</span> []</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">-- output2 = &quot;&quot;</span></a></code></pre></div>
<p>Here, the starting value also doubles up as a default for empty lists. Could we use just anything though? It would be kind of nice to have a sort of error value as a default, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">output2 <span class="fu">=</span> <span class="fu">foldr</span> <span class="fu">concat</span> <span class="st">&quot;sorry, no value&quot;</span> []</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">-- output2 = &quot;sorry, no value&quot;</span></a></code></pre></div>
<p>However this wouldn’t work when we DO have values:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">stringList ::</span> [string]</a>
<a class="sourceLine" id="cb6-2" title="2">stringList <span class="fu">=</span> [<span class="st">&quot;hot&quot;</span>,<span class="st">&quot;dog&quot;</span>,<span class="st">&quot;jumping&quot;</span>,<span class="st">&quot;frog&quot;</span>,<span class="st">&quot;albuquerque&quot;</span>]</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">output ::</span> string</a>
<a class="sourceLine" id="cb6-5" title="5">output <span class="fu">=</span> <span class="fu">foldr</span> <span class="fu">concat</span> <span class="st">&quot;sorry, no value&quot;</span> stringList</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">-- output = &quot;sorry, no valuehotdogjumpingfrogalbuquerque&quot;</span></a></code></pre></div>
<p>I guess we need empty values that don’t mess up the result then. Let’s stick to <code>&quot;&quot;</code> for strings.</p>
<h2 id="whats-monoid-then">What’s Monoid then?</h2>
<h4 id="a-monoid-is-a-way-of-generalising-over-the-idea-of-combining-things">A Monoid is a way of generalising over the idea of combining things</h4>
<p>It needs two things:</p>
<ol type="1">
<li>An operation for combining two values (called <code>mappend</code> - Monoid Append, I guess)</li>
<li>An empty value to start from (called <code>mempty</code> - Monoid Empty..?)</li>
</ol>
<p>For strings the combining operation is our <code>concat</code> and our empty value is <code>&quot;&quot;</code>. The key observation here is that adding <code>&quot;&quot;</code> to the start or end of a string changes nothing about the string.</p>
<p>String isn’t the only Monoid in our example either. The other could be the list itself, which has the following types:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">mappend</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">mempty</span><span class="ot"> ::</span> []</a></code></pre></div>
<p>Using <code>concat</code> on two lists will smash one after the other, ie <code>concat [1,2,3,4] [5,6,7]</code> would make <code>[1,2,3,4,5,6,7]</code>. The key to identifying a good empty element is this:</p>
<h4 id="if-you-concat-the-empty-element-onto-a-monoid-the-monoid-remains-the-same">If you concat the empty element onto a Monoid, the Monoid remains the same</h4>
<p>Some other more straightforward Monoids apply to numbers. Integers, for instance, can form two Monoids. One is addition:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">mappend</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="fu">mappend</span> a b <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="fu">mempty</span> <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>Adding <code>0</code> onto a number achieves nothing whatsoever.</p>
<p>However, for multiplication, things are similar but a bit different:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">mappend</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="fu">mappend</span> a b <span class="fu">=</span> a <span class="fu">*</span> b</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="fu">mempty</span> <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>Multiplying something by zero would make it into zero, and that’s certainly not ‘doing nothing’ - therefore here our empty value is <code>1</code>.</p>
<p>Anyhow - what does this information get us then?</p>
<p>It gets us <code>fold</code>!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">fold ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> [m] <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb10-2" title="2">fold <span class="fu">=</span> <span class="fu">foldMap</span> <span class="fu">id</span></a></code></pre></div>
<p>OK, that’s great, <code>id</code> is the function that does nothing, but what’s that <code>foldMap</code> doing? Good question:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="fu">foldMap</span><span class="ot"> ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="fu">foldMap</span> f as <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">mappend</span> <span class="fu">.</span> f) <span class="fu">mempty</span> as</a></code></pre></div>
<p>It’s our old pal <code>foldr</code> from a few paragraphs back, but using whichever <code>mappend</code> and <code>mempty</code> are attached to the Monoid <code>m</code>.</p>
<p>It also allows passing a function <code>f</code> which we can use to turn an non-Monoid <code>Int</code> into a Monoid <code>Sum</code> or <code>Product</code>, but more on that later, <code>id</code> is fine for now.</p>
<p>(A quick interlude for the confused, the <code>Monoid m =&gt;</code> part of the type signature is not the first function argument, but rather a constraint saying ‘all <code>m</code> in this type signature must be of the typeclass Monoid. The <code>f</code> is the function of type <code>(a -&gt; m)</code>, and <code>as</code> are the array of Monoid values we are working on. The key here is the <code>=&gt;</code> meaning ’constraint’, rather than <code>-&gt;</code>, meaning function application. I know, I’m sorry.)</p>
<p>Therefore, we can just combine our list of strings like thus: <code>fold [&quot;horse&quot;,&quot;time&quot;,&quot;great&quot;]</code> to make <code>&quot;horsetimegreat&quot;</code>.</p>
<p>Wonderful!</p>
<p>So. The question on everybody’s lips…what is the point in this?</p>
<p>ell, when doing something simple like this, perhaps not much. We have saved typing around ten letters in exchange for making the function of our code less opaque, perhaps not a great compromise. But now any other function could request a Monoid, and by doing so will automatically be able to combine it in some way, without really needing any deeper understanding of the datatype itself. And combining doesn’t have to mean just concatenating - it could be combining a bunch of <code>Maybe</code>s, collapsing a tree or <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html">many other things</a>. The important thing is that the other function doesn’t really need to care how it works, that’s <code>Monoid</code>’s job.</p>
<p>Anyway, that’s quite enough for now I feel.</p>
<p>Further reading:</p>
<p><a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html">Data.Monoid on Hackage</a> <a href="https://medium.com/@sjsyrek/five-minutes-to-monoid-fe6f364d0bba">5 minutes to Monoids</a></p>
    </section>
</article>
    </main>

    <footer>
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
</body>

</html>