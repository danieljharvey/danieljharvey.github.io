<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Total Recall</title>
    <link rel="stylesheet" href="../css/default.css" />
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../about.html">About</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Total Recall</h1>
        <article>
    <section class="header">
        Posted on October 21, 2018
        
    </section>
    <section>
        <p>I recently read a piece of useful advice on Twitter about total functions which I enjoyed. A total function is a function that a) always returns some valid data (rather than just when it feels like doing so) b) does not go into an infinite loop. The advice (which I will definitely accurately source at some point in the future, lol) goes something like this:</p>
<h3 id="you-start-making-your-functions-total-by-adding-maybe-but-then-you-move-onto-removing-maybe.">You start making your functions total by adding Maybe, but then you move onto removing Maybe.</h3>
<p>Like all my favourite advice this sounds like it doesn’t make any sense, so I figured I’d try and get to the bottom of this.</p>
<p>Let’s start with a non-total function. The canonical example is Head from the Haskell Prelude, which returns you the first item in a list, and looks something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">head</span> (x<span class="fu">:</span> xs) <span class="fu">=</span> x</a></code></pre></div>
<p>If we pass along a list like <code>[1,2,3]</code>, we get <code>1</code> back, all great.</p>
<p>But what if we pass it <code>[]</code> (ie, an empty list)?</p>
<p>That’s right! A big error! Exactly the type of thing we were told would never ever happen again once we submitted to a life of functional purity. So what’s the deal here?</p>
<p>Well, firstly, this function was there when Haskell was still growing up and learning what to do in the world, and it’s very difficult to go and change something that is used in a million libraries. However, the Proper Way To Do Things is to use a total version of the function, which looks something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">safeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">safeHead [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-3" title="3">safeHead (x<span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Just</span> x</a></code></pre></div>
<p>Now what happens? If we pass it <code>[1,2,3]</code> we get ’Just 1` back (the first item wrapped in a Maybe type). Great!</p>
<p>What about</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">NonEmptySteve</span> a <span class="fu">=</span> <span class="dt">Steve</span> <span class="dt">String</span> a [a]</a></code></pre></div>
    </section>
</article>
    </main>

    <footer>
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
</body>

</html>