<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Compiling a functional language to LLVM, part 3</title>
    <link rel="stylesheet" href="../css/default.css" />

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Compiling a functional language to LLVM, part 3</h1>
        <article>
    <section class="header">
        Posted on April 11, 2023
        
        <div class="info">
          
          Tags: <a title="All pages tagged 'plt'." href="../tags/plt.html">plt</a>, <a title="All pages tagged 'mimsa'." href="../tags/mimsa.html">mimsa</a>, <a title="All pages tagged 'typechecker'." href="../tags/typechecker.html">typechecker</a>, <a title="All pages tagged 'llvm'." href="../tags/llvm.html">llvm</a>
          
        </div>
    </section>
    <section>
        <p>Welcome to part 3 of this series in compiling functional languages to LLVM. In
<a href="../posts/2023-02-23-llvm-compiler-part-2.html">part 1</a> we added basic control
flow to our langauge with an <code>if / then / else</code> construct.</p>
<p>Today we’re going to get one important step towards a functional programming
language by adding functions and variables.</p>
<p>By the end of today we’ll be able to make small modules such as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> add</span><span class="kw">(</span><span class="ex">a:</span> integer, b: integer<span class="kw">)</span> <span class="kw">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">a</span> + b</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> increment</span><span class="kw">(</span><span class="ex">a:</span> integer<span class="kw">)</span> <span class="kw">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">a</span> + 1</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ex">add</span><span class="er">(</span><span class="ex">increment</span><span class="er">(</span><span class="ex">1</span><span class="kw">)</span><span class="ex">,</span> add<span class="er">(</span><span class="ex">2,</span> 3<span class="kw">))</span></span></code></pre></div>
<p>However, there are quite a few things our functions <em>won’t</em> do.</p>
<ul>
<li>They can’t call themselves recursively (ie, <code>function factorial(a: Integer) { if a == 0 then 1 else a * factorial(a - 1) }</code>. This is to simplify the typechecker
implementation for the time being rather than any limitation in LLVM - we’ll come back round to making this
possible.</li>
<li>We must define all function arguments up front (ie, <code>a: Integer, b:   Boolean</code>). It is possible to infer these, but let’s keep things simple for
now.</li>
<li>Functions can only call functions defined before them. This can be solved by
doing some dependency analysis before typechecking (ie, move things around to
typecheck them in a sensible order). We avoid this for now, but will come
back to it.</li>
<li>Functions can’t return other functions, they can only be defined at the top
level. This is a limitation of LLVM, however in future chapters we’ll work around this by
implementing closures.</li>
</ul>
<h2 id="ok-lets-get-concrete">OK, lets get concrete</h2>
<p>We’re going to need some new datatypes to express all the new things we want to
do.</p>
<h3 id="function">Function</h3>
<p>Firstly, we have a <code>Function</code> type.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Function</span> ann <span class="ot">=</span> <span class="dt">Function</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fnAnn ::</span> ann,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    fnArgs ::</span> [(<span class="dt">ArgumentName</span>, <span class="dt">Type</span> ann)],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    fnFunctionName ::</span> <span class="dt">FunctionName</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    fnBody ::</span> <span class="dt">Expr</span> ann</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>This lets us describe something like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> add</span><span class="kw">(</span><span class="ex">a:</span> Integer, b: Integer<span class="kw">)</span> <span class="kw">{</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">a</span> + b </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>Note that the function body is a single <code>Expr</code>, and that it can use variables
<code>a</code> and <code>b</code> introduced as function arguments.</p>
<p>The <code>ann</code> type will contain file location information
after parsing, and then will contain the type of the function after
typechecking.</p>
<p>Our function implementation is very limited - we can only
use variables passed into the function as arguments, and must explicitly
annotate each function argument with it’s type.</p>
<h3 id="module">Module</h3>
<p>A <code>Module</code> lets us combine multiple functions and a <code>main</code> expression.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Module</span> ann <span class="ot">=</span> <span class="dt">Module</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> mdFunctions ::</span> [<span class="dt">Function</span> ann],</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mdExpr ::</span> <span class="dt">Expr</span> ann</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>This lets us write code like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> increment</span><span class="kw">(</span><span class="ex">a:</span> Integer<span class="kw">)</span> <span class="kw">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">a</span> + 1</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> decrement</span><span class="kw">(</span><span class="ex">a:</span> Integer<span class="kw">)</span> <span class="kw">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">a</span> <span class="at">-</span> 1</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ex">increment</span><span class="er">(</span><span class="ex">decrement</span><span class="er">(</span><span class="ex">1</span><span class="kw">))</span> <span class="ex">==</span> 1</span></code></pre></div>
<p>As mentioned earlier, functions can only be used in the order
they are defined. Therefore <code>decrement</code> could call <code>increment</code>, but not the
other way round. We can improve this in future with some basic dependency
analysis.</p>
<h3 id="expr">Expr</h3>
<p>Our <code>Expr</code> needs a couple of new constructors.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> ann</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">EPrim</span> ann <span class="dt">Prim</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EInfix</span> ann <span class="dt">Op</span> (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EIf</span> ann (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann) (<span class="dt">Expr</span> ann)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EVar</span> ann <span class="dt">Identifier</span> <span class="co">-- new!</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EApply</span> ann <span class="dt">FunctionName</span> [<span class="dt">Expr</span> ann] <span class="co">-- new!</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<p><code>EVar</code> represents a variable such as <code>a</code>, and <code>EApply</code> represents function application (<code>add(1,2)</code>).</p>
<figure>
<img src="../images/horse3.jpg" title="Horse break" alt="Horse break" />
<figcaption aria-hidden="true">Horse break</figcaption>
</figure>
<h2 id="typechecker-changes">Typechecker changes</h2>
<p>After a rather sizable swerve into bidirectional typechecking in the previous
part, we are going to focus less on the changes here.</p>
<h3 id="adding-state">Adding state</h3>
<p>The most important part is that it’s become stateful, as we will be learning
about both functions and variables as we typecheck. We have created a
<code>TypecheckM</code> newtype that we use, that contains both a <code>ReaderT</code> and a
<code>StateT</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">TypecheckEnv</span> ann <span class="ot">=</span> <span class="dt">TypecheckEnv</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tceVars ::</span> <span class="dt">HashMap</span> <span class="dt">Identifier</span> (<span class="dt">Type</span> ann)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">TypecheckState</span> ann <span class="ot">=</span> <span class="dt">TypecheckState</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  {<span class="ot">tcsFunctions ::</span> <span class="dt">HashMap</span> <span class="dt">FunctionName</span> (<span class="dt">Type</span> ann)}</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">TypecheckM</span> ann a <span class="ot">=</span> <span class="dt">TypecheckM</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getTypecheckM ::</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ReaderT</span> (<span class="dt">TypecheckEnv</span> ann)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">StateT</span> (<span class="dt">TypecheckState</span> ann) </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">Either</span> (<span class="dt">TypeError</span> ann))) a</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">Functor</span>,</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Applicative</span>,</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Monad</span>,</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>      <span class="dt">MonadReader</span> (<span class="dt">TypecheckEnv</span> ann),</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>      <span class="dt">MonadError</span> (<span class="dt">TypeError</span> ann),</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">MonadState</span> (<span class="dt">TypecheckState</span> ann)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p>The reasons for separate <code>Reader</code> and <code>State</code> are the nature of the state in
them. Variables only live for the life of a function that are defined in, so
they live in the <code>TypecheckEnv</code> used by <code>Reader</code>, and disappear after the
function definition is typechecked (<a href="https://blog.cofree.coffee/2021-08-13-that-one-cool-reader-trick/">more information on this technique
here</a>).</p>
<p>The trick is using the <code>local</code> function from <code>Control.Monad.Reader</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withFunctionArgs ::</span> [(<span class="dt">Identifier</span>, <span class="dt">Type</span> ann)] <span class="ot">-&gt;</span> <span class="dt">TypecheckM</span> ann a <span class="ot">-&gt;</span> <span class="dt">TypecheckM</span> ann a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>withFunctionArgs args computation <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  local</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    ( \tce <span class="ot">-&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        tce</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>          { tceVars <span class="ot">=</span> tceVars tce <span class="op">&lt;&gt;</span> HM.fromList args</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    computation</span></code></pre></div>
<p>We pass in some <code>args</code>, which are the function arguments and their types, and
<code>computation</code>, which is whatever typechecking we’d like do. Then throughout
running <code>computation</code>, we’ll have extra variables in scope, and then they’ll
disappear again. This is helpful for typechecking functions, where the vars
only exist inside.</p>
<h3 id="inference-changes">Inference changes</h3>
<p>We have two new <code>infer</code> cases, <code>EVar</code> and <code>EApply</code>. <code>EVar</code> is pretty
straightforward:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>infer (<span class="dt">EVar</span> ann var) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  ty <span class="ot">&lt;-</span> lookupVar ann var</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">EVar</span> ty var)</span></code></pre></div>
<p>We lookup the type for <code>var</code>, and decorate the type with it. If <code>lookupVar</code>
fails, it “throws” a <code>TypeError ann</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | look up a saved identifier &quot;in the environment&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupVar ::</span> ann <span class="ot">-&gt;</span> <span class="dt">Identifier</span> <span class="ot">-&gt;</span> <span class="dt">TypecheckM</span> ann (<span class="dt">Type</span> ann)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>lookupVar ann identifier <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  maybeType <span class="ot">&lt;-</span> asks (HM.lookup identifier <span class="op">.</span> tceVars)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeType <span class="kw">of</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> found <span class="ot">-&gt;</span> <span class="fu">pure</span> found</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>      allIdentifiers <span class="ot">&lt;-</span> asks (HM.keysSet <span class="op">.</span> tceVars)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      throwError (<span class="dt">VarNotFound</span> ann identifier allIdentifiers)</span></code></pre></div>
<p>The other new <code>infer</code> case is <code>EApply</code>. This is used to get the type of an
applied function.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>infer (<span class="dt">EApply</span> ann fnName args) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- lookup function by name in State</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">&lt;-</span> lookupFunction ann fnName</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  (ty, elabArgs) <span class="ot">&lt;-</span> <span class="kw">case</span> fn <span class="kw">of</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">TFunction</span> _ tArgs tReturn <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- check the arguments length match the function </span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>      when</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">length</span> args <span class="op">/=</span> <span class="fu">length</span> tArgs)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        (throwError <span class="op">$</span> </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">FunctionArgumentLengthMismatch</span> ann </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>              (<span class="fu">length</span> tArgs) </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>              (<span class="fu">length</span> args)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- check each arg against type</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>      elabArgs <span class="ot">&lt;-</span> zipWithM check tArgs args      </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- return type and elaborated arguments</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> (tReturn, elabArgs)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">NonFunctionTypeFound</span> ann fn</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">EApply</span> (ty <span class="op">$&gt;</span> ann) fnName elabArgs)</span></code></pre></div>
<p>Note how we use <code>check</code> here to check each argument against the expected type in the
function. This is where the bidirectional type checking approach really starts
to shine, as any problems become immediately apparent.</p>
<p>The <code>lookupFunction</code> helper is very similar to <code>lookupVar</code>, except it looks in
the <code>State</code> instead of <code>Reader</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | look up a saved identifier &quot;in the environment&quot;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupFunction ::</span> ann <span class="ot">-&gt;</span> <span class="dt">FunctionName</span> <span class="ot">-&gt;</span> <span class="dt">TypecheckM</span> ann (<span class="dt">Type</span> ann)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>lookupFunction ann fnName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  maybeType <span class="ot">&lt;-</span> gets (HM.lookup fnName <span class="op">.</span> tcsFunctions)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeType <span class="kw">of</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> found <span class="ot">-&gt;</span> <span class="fu">pure</span> found</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      allFunctions <span class="ot">&lt;-</span> gets (HM.keysSet <span class="op">.</span> tcsFunctions)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      throwError (<span class="dt">FunctionNotFound</span> ann fnName allFunctions)</span></code></pre></div>
<p>These types, and the functions used to store / fetch variables and functions
are defined
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc3/src/Calc/Typecheck/Types.hs">here</a>.</p>
<h3 id="elaborating-a-function">Elaborating a function</h3>
<p>Our functions have types for the arguments, so we push them into the <code>Reader</code>
environment, and then elaborate the expression inside.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elaborateFunction ::</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Function</span> ann <span class="ot">-&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TypecheckM</span> ann (<span class="dt">Function</span> (<span class="dt">Type</span> ann))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>elaborateFunction (<span class="dt">Function</span> ann args name expr) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- with the `args` added to the Reader, infer the type of `expr`</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  exprA <span class="ot">&lt;-</span> withFunctionArgs args (infer expr)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- adjust the types of the arguments</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> argsA ::</span> [(<span class="dt">ArgumentName</span>, <span class="dt">Type</span> (<span class="dt">Type</span> ann))]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      argsA <span class="ot">=</span> <span class="fu">fmap</span> (second (\ty <span class="ot">-&gt;</span> <span class="fu">fmap</span> (<span class="fu">const</span> ty) ty)) args</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create type of function</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tyFn <span class="ot">=</span> <span class="dt">TFunction</span> ann (<span class="fu">snd</span> <span class="op">&lt;$&gt;</span> args) (getOuterAnnotation exprA)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- wrap it all back up again</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">Function</span> tyFn argsA name exprA)</span></code></pre></div>
<p>We’ve extended the <code>Type</code> datatype to add a <code>TFunction</code> constructor, which
contains the types of all the arguments, and the return type. All functions
will have a <code>TFunction</code> type.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span> ann</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TPrim</span> ann <span class="dt">TypePrim</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TFunction</span> ann [<span class="dt">Type</span> ann] (<span class="dt">Type</span> ann) <span class="co">-- new!</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<h3 id="elaborating-a-module">Elaborating a module</h3>
<p>Elaborating a module involves:</p>
<ul>
<li>Elaborate each function</li>
<li>Push it’s type into the <code>State</code></li>
<li>Elaborate the <code>main</code> expression</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elaborateModule ::</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> ann<span class="op">.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Module</span> ann <span class="ot">-&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Either</span> (<span class="dt">TypeError</span> ann) (<span class="dt">Module</span> (<span class="dt">Type</span> ann))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>elaborateModule (<span class="dt">Module</span> {mdFunctions, mdExpr}) <span class="ot">=</span> runTypecheckM (<span class="dt">TypecheckEnv</span> <span class="fu">mempty</span>) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- typecheck all functions...</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  fns <span class="ot">&lt;-</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">traverse</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      ( \fn <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- typecheck function</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>          elabFn <span class="ot">&lt;-</span> elaborateFunction fn</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- add it to State</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>          storeFunction (fnFunctionName elabFn) (fnAnn elabFn)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- return it</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> elabFn</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>      mdFunctions</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- typecheck `expr`, and wrap everything back together</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Module</span> fns <span class="op">&lt;$&gt;</span> infer mdExpr</span></code></pre></div>
<figure>
<img src="../images/horse1.jpg" title="Horse break" alt="Horse break" />
<figcaption aria-hidden="true">Horse break</figcaption>
</figure>
<h2 id="updating-the-interpreter">Updating the interpreter</h2>
<p>We won’t go into the interpreter changes today, they work in the same way as
the typechecker,
storing variables in the <code>Reader</code> env and functions in the <code>State</code>. <a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc3/src/Calc/Interpreter.hs">The code
lives
here</a>.</p>
<h2 id="to-the-ir">To the IR!</h2>
<p>Here is an expression:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="fu"> sum</span><span class="kw">(</span><span class="ex">a:</span> Integer, b: Integer<span class="kw">)</span> <span class="kw">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">a</span> + b</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="er">(</span><span class="ex">20,</span> 22<span class="kw">)</span></span></code></pre></div>
<p>Here is the LLVN output for it. Hopefully it’s not too brutal.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'example'</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span>  <span class="dt">void</span> <span class="fu">@printint</span>(<span class="dt">i32</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">i32</span> <span class="fu">@sum</span>(<span class="dt">i32</span>  <span class="fu">%a_0</span>, <span class="dt">i32</span>  <span class="fu">%b_0</span>)    {</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> = <span class="kw">add</span>   <span class="dt">i32</span> <span class="fu">%a_0</span>, <span class="fu">%b_0</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="fu">%1</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">i32</span> <span class="fu">@main</span>()    {</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> =  <span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">i32</span>  <span class="fu">@sum</span>(<span class="dt">i32</span>  <span class="dv">20</span>, <span class="dt">i32</span>  <span class="dv">22</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">void</span>  <span class="fu">@printint</span>(<span class="dt">i32</span>  <span class="fu">%1</span>)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = 'example'</span></span></code></pre></div>
<p>A comment, lol.</p>
<hr />
<div class="sourceCode" id="cb19"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> external <span class="kw">ccc</span>  <span class="dt">void</span> <span class="fu">@printint</span>(<span class="dt">i32</span>)</span></code></pre></div>
<p>We define our output function from our standard library.</p>
<hr />
<div class="sourceCode" id="cb20"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">i32</span> <span class="fu">@sum</span>(<span class="dt">i32</span>  <span class="fu">%a_0</span>, <span class="dt">i32</span>  <span class="fu">%b_0</span>)    {</span></code></pre></div>
<p>Define the function. The first <code>i32</code> is the return type. <code>%a_0</code> is the first
argument with type <code>i32</code>, and <code>%b_0</code> is the second argument, with type <code>i32</code>.</p>
<hr />
<div class="sourceCode" id="cb21"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> = <span class="kw">add</span>   <span class="dt">i32</span> <span class="fu">%a_0</span>, <span class="fu">%b_0</span></span></code></pre></div>
<p>Body of the <code>sum</code> function, add <code>%a_0</code> and <code>%b_0</code> and assign the result to
<code>%1</code>.</p>
<hr />
<div class="sourceCode" id="cb22"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="fu">%1</span></span></code></pre></div>
<p>Return <code>%1</code> from the function.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>End of <code>sum</code> function.</p>
<hr />
<div class="sourceCode" id="cb24"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">i32</span> <span class="fu">@main</span>()    {</span></code></pre></div>
<p>This defines the <code>main</code> function, the entry point to our application.</p>
<hr />
<div class="sourceCode" id="cb25"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">%1</span> =  <span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">i32</span>  <span class="fu">@sum</span>(<span class="dt">i32</span>  <span class="dv">20</span>, <span class="dt">i32</span>  <span class="dv">22</span>)</span></code></pre></div>
<p>Body of the <code>main</code> function - this calls the <code>sum</code> function, passing it <code>20</code>
amd <code>22</code> as args. The result is stored in <code>%1</code>.</p>
<hr />
<div class="sourceCode" id="cb26"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">call</span> <span class="kw">ccc</span>  <span class="dt">void</span>  <span class="fu">@printint</span>(<span class="dt">i32</span>  <span class="fu">%1</span>)</span></code></pre></div>
<p>Pass the result (<code>%1</code>) to the <code>printint</code> function in our standard library.</p>
<hr />
<div class="sourceCode" id="cb27"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></span></code></pre></div>
<p>Return the value <code>0</code> to show the program successfully completed.</p>
<hr />
<div class="sourceCode" id="cb28"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Nice closing bracket. Time for a rest.</p>
<hr />
<figure>
<img src="../images/horse2.jpg" title="Horse break" alt="Horse break" />
<figcaption aria-hidden="true">Horse break</figcaption>
</figure>
<h2 id="generating-ir-from-haskell">Generating IR from Haskell</h2>
<p>Adding functions and variables means that our IR generation also becomes
stateful. We’re going to define a couple more types:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OutputState</span> <span class="ot">=</span> <span class="dt">OutputState</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> osFunctions ::</span> <span class="dt">Map</span> <span class="dt">FunctionName</span> <span class="dt">LLVM.Operand</span>,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    osVars ::</span> <span class="dt">Map</span> <span class="dt">Identifier</span> <span class="dt">LLVM.Operand</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>It also means something can go wrong:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OutputError</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">CantFindVar</span> <span class="dt">Identifier</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CantFindFunction</span> <span class="dt">FunctionName</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NonFunctionType</span> (<span class="dt">Type</span> ())</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>Both these errors <em>shouldn’t</em> happen if the typechecking is working, however
it’s nice to capture them properly rather than just throwing with <code>error</code>.</p>
<p>It means we also need a similar set of functions for adding and looking up
functions and variables, which can be found
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc3/src/Calc/Compile/ToLLVM.hs#L38">here</a> and are hopefully unsurprising.</p>
<p>A lot of our implementation are various “turn things into LLVM” functions:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeToLLVM ::</span> <span class="dt">Type</span> ann <span class="ot">-&gt;</span> <span class="dt">LLVM.Type</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>typeToLLVM (<span class="dt">TPrim</span> _ <span class="dt">TBool</span>) <span class="ot">=</span> LLVM.i1</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>typeToLLVM (<span class="dt">TPrim</span> _ <span class="dt">TInt</span>) <span class="ot">=</span> LLVM.i32</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>typeToLLVM (<span class="dt">TFunction</span> _ tyArgs tyRet) <span class="ot">=</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LLVM.FunctionType</span> (typeToLLVM tyRet) (typeToLLVM <span class="op">&lt;$&gt;</span> tyArgs) <span class="dt">False</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">functionNameToLLVM ::</span> <span class="dt">FunctionName</span> <span class="ot">-&gt;</span> <span class="dt">LLVM.Name</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>functionNameToLLVM (<span class="dt">FunctionName</span> fnName) <span class="ot">=</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LLVM.Name</span> (fromString (T.unpack fnName))</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">functionArgToLLVM ::</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ArgumentName</span>, <span class="dt">Type</span> (<span class="dt">Type</span> ann)) <span class="ot">-&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">LLVM.Type</span>, <span class="dt">LLVM.ParameterName</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>functionArgToLLVM (<span class="dt">ArgumentName</span> argName, ty) <span class="ot">=</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> llvmType <span class="ot">=</span> typeToLLVM (getOuterTypeAnnotation ty)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>      paramName <span class="ot">=</span> <span class="dt">LLVM.ParameterName</span> (fromString (T.unpack argName))</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> (llvmType, paramName)</span></code></pre></div>
<p>Now we can create IR for each function in our module. We put each function
variable in <code>State</code> so that we can look them up when generating expressions:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">functionToLLVM ::</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">LLVM.MonadModuleBuilder</span> m,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MonadFix</span> m,</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MonadState</span> <span class="dt">OutputState</span> m,</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MonadError</span> <span class="dt">OutputError</span> m</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Function</span> (<span class="dt">Type</span> ann) <span class="ot">-&gt;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  m ()</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>functionToLLVM (<span class="dt">Function</span> {fnAnn, fnFunctionName, fnBody, fnArgs}) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- get llvm type of function</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  retType <span class="ot">&lt;-</span> <span class="kw">case</span> fnAnn <span class="kw">of</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">TFunction</span> _ _ tyRet <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> typeToLLVM tyRet</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> throwError (<span class="dt">NonFunctionType</span> (fnAnn <span class="op">$&gt;</span> ()))</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> argTypes <span class="ot">=</span> functionArgToLLVM <span class="op">&lt;$&gt;</span> fnArgs</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>      functionName <span class="ot">=</span> functionNameToLLVM fnFunctionName</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create the LLVM function</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>  llvmFunction <span class="ot">&lt;-</span> LLVM.function functionName argTypes retType <span class="op">$</span> \args <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- save the args in the environment</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    saveArgs</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>      ( M.fromList <span class="op">$</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>          <span class="fu">zipWith</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>            ( \(<span class="dt">ArgumentName</span> argName, _) arg <span class="ot">-&gt;</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>                (<span class="dt">Identifier</span> argName, arg)</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>            fnArgs</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>            args</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- build the LLVM AST for our expression</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>    ourExpression <span class="ot">&lt;-</span> exprToLLVM fnBody</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- return result</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>    LLVM.ret ourExpression</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- save reference to this function in our State to lookup in other</span></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- expressions</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>  saveFunction fnFunctionName llvmFunction</span></code></pre></div>
<p>We have two new cases in <code>exprToLLVM</code>, for <code>EVar</code> and <code>EApply</code>. These somewhat
echo the implementation in the typechecker above. For <code>EVar</code>, we lookup the
LLVM IR in our <code>State</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>exprToLLVM (<span class="dt">EVar</span> _ var) <span class="ot">=</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  lookupArg var</span></code></pre></div>
<p>And for <code>EApply</code>, we lookup the function in <code>State</code>, then use LLVM’s <code>call</code> to
pass all the arguments to it.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>exprToLLVM (<span class="dt">EApply</span> _ fnName args) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  irFunc <span class="ot">&lt;-</span> lookupFunction fnName</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  irArgs <span class="ot">&lt;-</span> <span class="fu">traverse</span> exprToLLVM args</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  LLVM.call irFunc ((,[]) <span class="op">&lt;$&gt;</span> irArgs)</span></code></pre></div>
<p>Finally, we bring it all together in the top level <code>moduleToLLVM</code> function,
which takes our typechecked <code>Module</code> and creates an LLVM module.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | given our `Module` type, turn it into an LLVM module</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ot">moduleToLLVM ::</span> <span class="dt">Module</span> (<span class="dt">Type</span> ann) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">OutputError</span> <span class="dt">LLVM.Module</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>moduleToLLVM (<span class="dt">Module</span> {mdExpr <span class="ot">=</span> expr, mdFunctions}) <span class="ot">=</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">flip</span> evalStateT (<span class="dt">OutputState</span> <span class="fu">mempty</span> <span class="fu">mempty</span>) <span class="op">$</span> LLVM.buildModuleT <span class="st">&quot;example&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- get the printing function for our `expr`'s return type</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    printFn <span class="ot">&lt;-</span> printFunction (getOuterAnnotation expr)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- create all our functions</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    traverse_ functionToLLVM mdFunctions</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- create a function called `main` that will be the entry point to our</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- program</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    LLVM.function <span class="st">&quot;main&quot;</span> [] LLVM.i32 <span class="op">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- build the LLVM AST for our expression</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>      ourExpression <span class="ot">&lt;-</span> exprToLLVM expr</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- print our result to stdout</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">&lt;-</span> LLVM.call printFn [(ourExpression, [])]</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- return success exit code of `0`</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>      LLVM.ret (LLVM.int32 <span class="dv">0</span>)</span></code></pre></div>
<p>You can see all of the LLVM generation code
<a href="https://github.com/danieljharvey/mimsa/blob/trunk/llvm-calc3/src/Calc/Compile/ToLLVM.hs">here</a>.</p>
<hr />
<h3 id="well-well-well-if-its-not-the-end-of-the-article">Well, well, well, if it’s not the end of the article</h3>
<p>Congratulations, you are all functional programming language implementation experts now. Hopefully you found that somewhat interesting and/or useful.
Next time we’ll be adding basic product types and pattern matching. Great!</p>
<p>Make sense? If not, <a href="../contact.html">get in touch</a>!</p>
<p>Further reading:</p>
<p><a href="https://llvm.org/docs/LangRef.html">llvm reference</a></p>
<p><a href="https://github.com/danieljharvey/mimsa">mimsa</a></p>
    </section>
</article>

    </main>

    <footer>
      <p>Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
      <p>Links for nerds:
        <a href="../atom.xml">atom</a>
        <a href="../rss.xml">rss</a></p>

    </footer>
</body>

</html>
