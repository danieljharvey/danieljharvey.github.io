<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Mr Migration</title>
    <link rel="stylesheet" href="../css/default.css" />

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="../">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../contact.html">Contact</a>
            <a href="../archive.html">Archive</a>
        </nav>
    </header>

    <main role="main">
        <h1>Mr Migration</h1>
        <article>
    <section class="header">
        Posted on July 14, 2019
        
        <div class="info">
          
          Tags: <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a>, <a title="All pages tagged 'migratable'." href="../tags/migratable.html">migratable</a>
          
        </div>
    </section>
    <section>
        <p>A few weeks ago I gave a talk at London Haskell that was basically an advert for a data migrating library I haven’t even finished yet. However, I managed on the whole to hide this fact and some people even came up afterwards and asked me how the library was performing in production to which of course I said “very well indeed, because of course i am very good at computers” and quickly changed the subject.</p>
<p>What follows is basically the crap from my slides, occasionally turned from bullet lists into sentences where I realised I had overused that particular presentation device a little much.</p>
<p>Sitting comfortable? Then we shall begin…</p>
<h3 id="in-the-beginning">In The Beginning…</h3>
<p>…we had server side applications.</p>
<ul>
<li><p>If the code agrees with the DB schema…</p></li>
<li><p>Deploy!</p></li>
<li><p><strong>Great!</strong></p></li>
</ul>
<h3 id="then-came-javascript">Then Came Javascript…</h3>
<ul>
<li><p>Suddenly all our data was spread around the place</p></li>
<li><p>Things didn’t necessarily agree with one another</p></li>
<li><p>There was sometimes <em>JQuery</em>.</p></li>
</ul>
<p>And at some point we land at</p>
<h3 id="the-traditional-backend-frontend-monolith">The Traditional Backend / Frontend Monolith</h3>
<ul>
<li><p>When the back end changes…</p></li>
<li><p>Change the front end too.</p></li>
<li><p><strong>Deploy everything together</strong></p></li>
<li><p>(did you forget to update the DB schema?)</p></li>
<li><p><strong>DO THAT QUICKLY</strong></p></li>
<li><p>Forget about the past</p></li>
<li><p><strong>YOLO</strong></p></li>
</ul>
<h3 id="so">So…</h3>
<p>What could possibly go wrong with this?</p>
<figure>
<img src="../images/migrate-1.png" title="A relatable picture that was not in the presentation to break things up a bit." alt="A relatable picture that was not in the presentation to break things up a bit." />
<figcaption aria-hidden="true">A relatable picture that was not in the presentation to break things up a bit.</figcaption>
</figure>
<h3 id="problem-one">Problem One</h3>
<p><code>Company A</code> have found that DB schema changes make changing the application more difficult than they would like. Therefore they choose to use <strong>event sourcing</strong>. As the application changes, the DB schemas keep up, but they are soon left with an event table full of various historical versions of JSON data.</p>
<ul>
<li><em>What is this data? Do they still understand it?</em></li>
</ul>
<h3 id="problem-two">Problem Two</h3>
<p><code>Company B</code> decide their code is so good that they are going to create a <strong>public API</strong>. Other companies decide to use this API, and annoyingly want it not to change at random. Therefore the API owners make promises not to change their API (even though they bloody love changing their API because they are 10x hackers who just can’t stop delivering business value).</p>
<ul>
<li><em>How can they make changes to this without breaking everything?</em></li>
</ul>
<h3 id="problem-three">Problem Three</h3>
<p><code>Company C</code> have noticed that <em>large monoliths take ages to deploy</em>. They would also like to decouple teams to maximise parallelisation of work. They adopt a <strong>microservice architecture</strong>. Suddenly, services that talk to one another aren’t guaranteed to have versions or interfaces that match, so a old service can be receiving requests from a very old service that hasn’t been updated.</p>
<ul>
<li><em>How will they cope with communicating with any number of historical deployments?</em></li>
</ul>
<h3 id="a-concrete-example">A concrete example</h3>
<p>Here’s a data type that we use in our business critical application. It is called <code>OldUser</code>, which we never really questioned at the time.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OldUser</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">OldUser</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> firstName ::</span> <span class="dt">String</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> surname   ::</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> pet       ::</span> <span class="dt">String</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> age       ::</span> <span class="dt">Int</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Business is going pretty well, I can’t imagine my meeting this afternoon will go badly…</p>
<h3 id="oh-no">Oh no!</h3>
<figure>
<img src="../images/migrate-2.png" title="A change in business requirements has been spotted." alt="A change in business requirements has been spotted." />
<figcaption aria-hidden="true">A change in business requirements has been spotted.</figcaption>
</figure>
<h3 id="pivot-immediately">Pivot immediately</h3>
<p>Apparently we can increase profitability by <em>30%</em> by using newtypes properly.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Name</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Name</span> {<span class="ot"> getName ::</span> <span class="dt">Text.Text</span> }</span></code></pre></div>
<p>And replacing <code>String</code> selections of <code>pet</code> types with a more restrictive sum type.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OldPet</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">OldDog</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OldCat</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NoPet</span></span></code></pre></div>
<p>These changes took all night, but you really pulled through there.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NewUser</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">NewUser</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> newFirstName ::</span> <span class="dt">Name</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> newSurname   ::</span> <span class="dt">Name</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> newPet       ::</span> <span class="dt">OldPet</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> newAge       ::</span> <span class="dt">Int</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Great job.</p>
<h3 id="hold-on-though">Hold On Though</h3>
<p>Business is obviously booming now, but what are we going to do about:</p>
<ul>
<li><p>Third parties that will insist on using <code>OldUser</code> in their API calls for the
next 18 months</p></li>
<li><p>Stored JSON data with the old data shape</p></li>
</ul>
<h3 id="what-options-do-we-have">What options do we have?</h3>
<ol type="1">
<li>As well as developing new code, we keep <strong>old code</strong> for dealing with the <strong>old data</strong></li>
</ol>
<ul>
<li>This seems fine…</li>
<li>…till you’re fixing bugs in the old system too</li>
<li>Shit! More fixes! Now you’re got an new-old system as well as the new-new one.</li>
<li>More fixes again! Now we have a new-old-new-old system to maintain as well as your main one, which is a new-new-new system by now? It may have been superceded too. Oh dear.</li>
</ul>
<ol start="2" type="1">
<li>Or migrate the <strong>old datatypes</strong> to the <strong>new datatypes</strong> and keep one set of logic.</li>
</ol>
<ul>
<li>Logic stays in new code</li>
<li>Bug fixes in business logic happen once</li>
<li>Logic of migration separated from business logic</li>
</ul>
<h3 id="decision-time">Decision time</h3>
<p>If you choose Option <code>1</code>, you are on your own. However, if you have chosen Option <code>2</code>, read on…</p>
<figure>
<img src="../images/migrate-3.png" title="Another picture of an angry business person." alt="Another picture of an angry business person." />
<figcaption aria-hidden="true">Another picture of an angry business person.</figcaption>
</figure>
<h3 id="functions-we-will-need-migrate">Functions we will need: migrate</h3>
<p>The first thing we’ll need is a function to convert our <em>old terrible datatype</em> into our <em>new incredible exciting datatype</em>, in this case <code>OldUser</code> to <code>NewUser</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">migrate ::</span> <span class="dt">OldUser</span> <span class="ot">-&gt;</span> <span class="dt">NewUser</span></span></code></pre></div>
<p>Actually. Let’s be realistic about this, and account for the idea that this operation could fail, as life is a bin.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">migrate ::</span> <span class="dt">OldUser</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">NewUser</span></span></code></pre></div>
<h3 id="functions-we-will-need-parse">Functions we will need: parse</h3>
<p>We’ll also need some functions for decoding JSON, as I have made the somewhat brazen assumption this is a REST API that only receives JSON payloads. We’ll use functions from the <code>Aeson</code> library because it is reasonably ubiquitous.</p>
<p>This function will attempt converting some <code>JSON</code> into an <code>OldUser</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseOldUser ::</span> <span class="dt">JSON</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OldUser</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>parseOldUser json</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> parseMaybe (parseJSON json)</span></code></pre></div>
<p>And this very similar function will try and convert from <code>JSON</code> into a <code>NewUser</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseNewUser ::</span> <span class="dt">JSON</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">NewUser</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>parseNewUser</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> parseMaybe <span class="op">.</span> parseJSON</span></code></pre></div>
<h3 id="putting-it-together">Putting it together</h3>
<p>We can then make a function that takes some <code>JSON</code>, and then tries to decode it into a <code>NewUser</code>. If it can’t decode it into a <code>NewUser</code>, it tries to parse it into an <code>OldUser</code>, and if that succeeds, it uses some sort of <code>migrate</code> function to turn <code>OldUser</code> into a <code>NewUser</code>.</p>
<p>Said function looks something like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseSomeKindOfUser ::</span> <span class="dt">JSON</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">NewUser</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>parseSomeKindOfUser json</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">=</span>   parseNewUser json</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> (parseOldUser json <span class="op">&gt;&gt;=</span> migrate)</span></code></pre></div>
<p>(The <code>&lt;|&gt;</code> operator comes from the <code>Alternative</code> typeclass, and works sort of like the <code>||</code> function. The intuition is <code>try this OR try this</code>)</p>
<h3 id="does-it-scale-though">Does it scale though?</h3>
<p>It seems to do the job, with a couple of datatypes, however it’s easy to see how it could get out of hand…</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>thing <span class="ot">=</span> parse a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse b <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse c <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse d <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse e <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse f <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse g <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse h <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse i <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse j <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse k <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse l <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse m <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate <span class="op">&gt;&gt;=</span> migrate</span></code></pre></div>
<h3 id="so-this-method-is-a-no">So this method is a no?</h3>
<p>I don’t think so. But writing all of that is a bit much. Hopefully right now you are asking “Why can’t I get the compiler to do this for me?”.</p>
<figure>
<img src="../images/migrate-4.png" title="The compiler is your friend." alt="The compiler is your friend." />
<figcaption aria-hidden="true">The compiler is your friend.</figcaption>
</figure>
<h3 id="good-point.">Good Point.</h3>
<p>OK! Let’s give it a smash. We start by making a typeclass and using it to version tag our datatype.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Versioned</span> (<span class="ot">label ::</span> <span class="dt">Symbol</span>) (<span class="ot">num ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> num <span class="ot">`VersionOf` label ::</span> <span class="dt">Type</span></span></code></pre></div>
<p>(This <code>VersionOf</code> type here is an <code>associated type family</code> - a type level function that is scoped to only work inside the typeclass it is defined in.)</p>
<p>The typeclass defines a function we can use to find a datatype from the <code>label</code> and the <code>num</code>. For example, we can make a label called <code>"User"</code>, and make <code>OldUser</code> version <code>1</code> of it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;User&quot;</span> <span class="dv">1</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">1</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;User&quot;</span> <span class="ot">=</span> <span class="dt">OldUser</span></span></code></pre></div>
<p>We’ll also define an instance for <code>NewUser</code>, and make that version <code>2</code> of it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;User&quot;</span> <span class="dv">2</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">2</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;User&quot;</span> <span class="ot">=</span> <span class="dt">NewUser</span></span></code></pre></div>
<h3 id="linking-versions-together">Linking versions together</h3>
<p>Next we make a typeclass for migrations that uses our <code>VersionOf</code> type function:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Migratable</span> (<span class="ot">label ::</span> <span class="dt">Symbol</span>) (<span class="ot">num ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  fromPrevious</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> (num <span class="op">-</span> <span class="dv">1</span>) <span class="ot">`VersionOf`</span> label</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (num <span class="ot">`VersionOf`</span> label)</span></code></pre></div>
<p>It lets us define a function from the previous version of a datatype to the current one, so let’s use it to migrate <code>OldUser</code> to <code>NewUser</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Migratable</span> <span class="st">&quot;User&quot;</span> <span class="dv">2</span> <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fromPrevious ::</span> <span class="dt">OldUser</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">NewUser</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  fromPrevious older</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">NewUser</span> </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>              { newFirstName <span class="ot">=</span> <span class="dt">Name</span> (Text.pack (firstName older))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>              , newSurname   <span class="ot">=</span> <span class="dt">Name</span> (Text.pack (surname older))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>              , newPet       <span class="ot">=</span> readPet (pet older)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>              , newAge       <span class="ot">=</span> age older</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>              }</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      readPet s</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> s <span class="op">==</span> <span class="st">&quot;dog&quot;</span> <span class="ot">=</span> <span class="dt">OldDog</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> s <span class="op">==</span> <span class="st">&quot;cat&quot;</span> <span class="ot">=</span> <span class="dt">OldCat</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dt">NoPet</span></span></code></pre></div>
<h3 id="problem-migrating-from-old-json-versions">Problem: Migrating from old JSON versions</h3>
<p>Once we’ve defined instances of the <code>Versioned</code> and <code>Migratable</code> typeclasses for our data, the <code>Data.Migratable</code> library functions start doing helpful things. It provides a version of <code>migrate</code> function we defined concretely earlier, but with a much more exciting (confusing) type signature.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>migrate </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> earliest <span class="ot">`VersionOf`</span> label </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (target <span class="ot">`VersionOf`</span> label)</span></code></pre></div>
<p>It means “I can take the <code>earliest</code> version of <code>label</code> and <code>Maybe</code> return you the <code>target</code> version of <code>label</code>”. We use <em>type applications</em> to pass <code>versions</code> and a <code>label</code> to convert an old datatype to a new one.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">oldToNew ::</span> <span class="dt">OldUser</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">NewUser</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>oldToNew <span class="ot">=</span> migrate <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">2</span> <span class="op">@</span><span class="st">&quot;User&quot;</span></span></code></pre></div>
<p>Going from version <code>1</code> to <code>2</code> means we’ve just done a shitload of work for a single conversion, but the same function will recursively convert through as many versions of the datatype as you like:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">veryOldToVeryNew ::</span> <span class="dt">OldUser</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">VeryNewUser</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>veryOldToVeryNew <span class="ot">=</span> migrate <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">100</span> <span class="op">@</span><span class="st">&quot;User&quot;</span></span></code></pre></div>
<h3 id="solution-parsejsonvia">Solution: parseJSONVia</h3>
<p>The <code>Data.Migratable</code> library also provides us <code>parseJSONVia</code>, with the following exciting type signature:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>parseJSONVia</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">JSON</span> </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (target <span class="ot">`VersionOf`</span> label)</span></code></pre></div>
<p>We could use to try converting from both <code>OldUser</code> and <code>NewUser</code> like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>parseSomeKindOfUser </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">JSON</span> </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">NewUser</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>parseSomeKindOfUser </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> parseJSONVia <span class="op">@</span><span class="st">&quot;User&quot;</span> <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">2</span></span></code></pre></div>
<p>Underneath, this is doing our <code>parse</code> and <code>migrate</code> pattern under thge good</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>thing <span class="ot">=</span> parse <span class="op">@</span><span class="dt">NewUser</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> parse <span class="op">@</span><span class="dt">OldUser</span> <span class="op">&gt;&gt;=</span> migrate</span></code></pre></div>
<h3 id="a-note-on-type-applications">A note on Type Applications</h3>
<p>To understand how to pass the types to the <code>parseJSONVia</code> function, we need to look at the <code>Schema</code> typeclass that provides this functionality:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Schema</span> (<span class="ot">label ::</span> <span class="dt">Symbol</span>) (<span class="ot">earliest ::</span> <span class="dt">Nat</span>) (<span class="ot">target ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseJSONVia ::</span> <span class="dt">JSON.Value</span> <span class="ot">-&gt;</span> <span class="dt">JSON.Parser</span> (target <span class="ot">`VersionOf`</span> label)</span></code></pre></div>
<p>When we use it, we are passing it types in the order they appear in the class declaration.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>parseJSONVia <span class="op">@</span><span class="st">&quot;User&quot;</span> <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">2</span></span></code></pre></div>
<p>Therefore, we are passing the type-level symbol <code>"User"</code> as the first argument <code>label</code>, then a type-level natural number <code>1</code> as the starting version <code>earliest</code>, and finally another type-level natural <code>2</code> as the target version <code>target</code>.</p>
<h3 id="problem-uniqueness-checking">Problem: Uniqueness checking</h3>
<p>Uniqueness checking is another feature of <code>Data.Migratable</code>. Let’s say that we have this data type <code>Info</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Info</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Info</span> </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>      { amount<span class="op">:</span> <span class="dt">Pounds</span> }</span></code></pre></div>
<p>Then, after another hard pivot, we change the units:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NewInfo</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">NewInfo</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> amount ::</span> <span class="dt">Pennies</span> }</span></code></pre></div>
<p>In our static typed ivory tower, we are fine, but our clients keep sending us
this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span> <span class="dt">&quot;amount&quot;</span><span class="fu">:</span> <span class="dv">100</span> <span class="fu">}</span></span></code></pre></div>
<p>What is it? 100 pennies? 100 pounds? How can we stop this confusion?</p>
<h3 id="solution-checking-for-duplicates-with-quickcheck">Solution: Checking for duplicates with QuickCheck</h3>
<p><code>Data.Migratable</code> provides us with the <code>matchAll</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">matchAll ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> [<span class="dt">MatchError</span>] [<span class="dt">Integer</span>])</span></code></pre></div>
<ul>
<li><p>It uses <code>QuickCheck</code> and it’s <code>Arbitrary</code> instances to generate random <code>JSON</code>
values for each datatype</p></li>
<li><p>Then tries to load each generated value as each version of the datatype</p></li>
<li><p>And tells us how many version of a datatype each generated instance is able
to decode</p></li>
<li><p>If it’s one each - we’re going to have a good time:</p></li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>describe <span class="st">&quot;Uses Arbitrary to generate said tests&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  it <span class="st">&quot;Checks if our datatypes will get confused&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    found <span class="ot">&lt;-</span> matchAll <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">4</span> <span class="op">@</span><span class="st">&quot;User&quot;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    found <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span></code></pre></div>
<ul>
<li>But if our <code>JSON</code> representations are non-unique, we’ll know:</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>describe <span class="st">&quot;Our Pennies and Pounds schema&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  it <span class="st">&quot;Spots our problematic matching schema&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    found <span class="ot">&lt;-</span> matchAll <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">2</span> <span class="op">@</span><span class="st">&quot;Same&quot;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    found <span class="ot">`shouldBe`</span> <span class="dt">Left</span> [<span class="dt">Duplicates</span> <span class="dv">1</span> [<span class="dv">2</span>,<span class="dv">1</span>], <span class="dt">Duplicates</span> <span class="dv">2</span> [<span class="dv">2</span>,<span class="dv">1</span>]]</span></code></pre></div>
<ul>
<li>And we can fix our data types to ensure uniqueness.</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Info</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Info</span> </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> amountPounds ::</span> <span class="dt">Pounds</span> }</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NewInfo</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">NewInfo</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> amountPennies ::</span> <span class="dt">Pennies</span> }</span></code></pre></div>
<ul>
<li>Good job.</li>
</ul>
<h3 id="problem-getting-a-fromjson-instance">Problem: getting a FromJSON instance</h3>
<p>The <code>Aeson</code> library works by making datatypes define instances of the <code>FromJSON</code> typeclass, and packages like <code>Servant</code> allow us to automagically create web servers that use these types. Can we still use all this good stuff?</p>
<h3 id="solution-fromjson-instance-around-a-newtype-wrapper">Solution: FromJSON instance around a newtype wrapper</h3>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">APIUser</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">APIUser</span> {<span class="ot"> getAPIUser ::</span> <span class="dt">WhateverTheNewestUserTypeIsTheseDays</span> }</span></code></pre></div>
<p>…and using <code>parseJSONVia</code> to create a <code>FromJSON</code> instance for that datatype…</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">JSON.FromJSON</span> <span class="dt">APIUser</span> <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  parseJSON a</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">APIUser</span> <span class="op">&lt;$&gt;</span> parseJSONVia <span class="op">@</span><span class="st">&quot;User&quot;</span> <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">4</span> a</span></code></pre></div>
<p>…we can make a <code>Servant</code> server that can read any of our historical datatypes.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ExcellentApi</span> <span class="ot">=</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;user&quot;</span> <span class="op">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">APIUser</span>] </span></code></pre></div>
<p>Great job!</p>
<h3 id="problem-mistakes-in-our-datatypes">Problem: Mistakes in our datatypes</h3>
<p>What if we make “mistakes” in our types - like removing a piece of data we later decide we need? Here is a first version of some data.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dog</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Dog</span> {<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>        ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;Dog&quot;</span> <span class="dv">1</span> <span class="kw">where</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">1</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;Dog&quot;</span> <span class="ot">=</span> <span class="dt">Dog</span></span></code></pre></div>
<p>This is the second version of the datatype, where we remove <code>age</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AgelessDog</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">AgelessDog</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> name ::</span> <span class="dt">String</span> }</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;Dog&quot;</span> <span class="dv">2</span> <span class="kw">where</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">2</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;Dog&quot;</span> <span class="ot">=</span> <span class="dt">AgelessDog</span></span></code></pre></div>
<p>Oops. We needed that. It’s back in version <code>3</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">WithAgeDog</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">WithAgeDog</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>      ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>      ,<span class="ot"> tail ::</span> <span class="dt">Bool</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;Dog&quot;</span> <span class="dv">3</span> <span class="kw">where</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">3</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;Dog&quot;</span> <span class="ot">=</span> <span class="dt">WithAgeDog</span></span></code></pre></div>
<p>However, this means any version <code>1</code> piece of data will convert through version <code>2</code> and lose everything on the way.</p>
<h3 id="solution-multiple-import-paths">Solution: multiple import paths</h3>
<p>Let’s change our declarations…</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dog</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Dog</span> {<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;Dog&quot;</span> <span class="dv">1</span> <span class="kw">where</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">1</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;Dog&quot;</span> <span class="ot">=</span> <span class="dt">Dog</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;AgeDog&quot;</span> <span class="dv">1</span> <span class="kw">where</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">1</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;AgeDog&quot;</span> <span class="ot">=</span> <span class="dt">Dog</span></span></code></pre></div>
<p>(We’ve ignored the middle one for now - it is the same)</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">WithAgeDog</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">WithAgeDog</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>      ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>      ,<span class="ot"> tail ::</span> <span class="dt">Bool</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;Dog&quot;</span> <span class="dv">3</span> <span class="kw">where</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">3</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;Dog&quot;</span> <span class="ot">=</span> <span class="dt">WithAgeDog</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Versioned</span> <span class="st">&quot;AgeDog&quot;</span> <span class="dv">2</span> <span class="kw">where</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dv">2</span> <span class="ot">`VersionOf`</span> <span class="st">&quot;AgeDog&quot;</span> <span class="ot">=</span> <span class="dt">WithAgeDog</span></span></code></pre></div>
<p>Then our parsing function becomes (something like)</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseSomeKindOfDog ::</span> <span class="dt">JSON</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">WithAgeDog</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>parseSomeKindOfDog json</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span>  parseJSONVia <span class="op">@</span><span class="st">&quot;AgeDog&quot;</span> <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">2</span> json</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a> <span class="op">&lt;|&gt;</span> parseJSONVia <span class="op">@</span><span class="st">&quot;Dog&quot;</span> <span class="op">@</span><span class="dv">1</span> <span class="op">@</span><span class="dv">3</span> json</span></code></pre></div>
<p>How does it work?</p>
<ul>
<li><p>First, we try the lossless path</p></li>
<li><p>Failing that, we try the lossy path to pick up any <code>AgeLessDog</code> values.</p></li>
</ul>
<h3 id="ok.-sum-up-what-youve-said-and-stop-selling-me-your-crappy-non-existent-library">OK. Sum up what you’ve said and stop selling me your crappy non-existent library</h3>
<p>So hopefully, this technique should let you:</p>
<ul>
<li><p>Define migrations outside the main logic code, throw those into a file and forget about them forever until the next migration.</p></li>
<li><p>Use simple ADTs for my types if one feels like it.</p></li>
<li><p>Avoid historical code making new code more complicated.</p></li>
</ul>
<h3 id="but-does-it-work">But does it work?</h3>
<p>Who knows? See the code at
<a href="https://github.com/danieljharvey/migratable">https://github.com/danieljharvey/migratable</a> and decide for yourself. I mean, the tests pass, but what does that really tell us.</p>
<h3 id="addendum">Addendum</h3>
<p>After the talk, somebody suggested that it’s all very well accepting old JSON data version in an API, but really you’d need to provide the response in the old format too. This was a really annoyingly good point, so this is the next feature I am working on for the library - the plan so far is to create a kind of opposite of the <code>Migratable</code> typeclass for responses, that goes from newer to older versions instead.</p>
    </section>
</article>

    </main>

    <footer>
      <p>Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
      <p>Links for nerds:
        <a href="../atom.xml">atom</a>
        <a href="../rss.xml">rss</a></p>

    </footer>
</body>

</html>
