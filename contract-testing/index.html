<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Contract testing with Quickcheck</title>
    <link rel="stylesheet" href="https://danieljharvey.github.io/main.css">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="/">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="/">Posts</a>
        </nav>
    </header>

    <main role="main">
        
<h1 class="title">
  Contract testing with Quickcheck
</h1>
<p class="subtitle"><strong>2020-02-22</strong></p>
<p>
 <p class="blog-meta">
        
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/purescript/"
          >#purescript</a
        > 
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/haskell/"
          >#haskell</a
        > 
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/testing/"
          >#testing</a
        >
         
      </p>

<p>Hello. I hope you are well. Over the last few months I have been trying out a
method for generating <code>Contract Tests</code> between services using <code>Arbitrary</code>
instances from <a href="https://hackage.haskell.org/package/QuickCheck">Quickcheck</a> which I thought it might be good to share. It's not particularly clever, which is
partially what I like about it, and as a result I may not have been the first
to come up with it. If I have therefore somewhat stolen your thunder please
accept my apologies in advance and then maybe do some reading around SEO.</p>
<h3 id="what-is-contract-testing-anyway">What is Contract Testing anyway?</h3>
<p>Contract Testing is a way of checking that two services that are going to
communicate agree on what is going to be sent and received between the two.
There is a good intro to the concept on the <a href="https://docs.pact.io/">Pact
website</a> - which is itself a contract testing tool. It
is a good tool - HOWEVER it takes a lot of work and I am lazy so there what I
am going to describe is hopefully less work.</p>
<p>For example, a frontend says "I am going to call <code>/users/horse/1000</code> - is that cool?"
and the contract test confirms that the backend is indeed "cool" with that,
shows what kind of thing it would return from that call, to which the frontend
confirms it is also "cool" with that.</p>
<p><img src="/images/contract-handshake.png" alt="This is the agreement between the services probably looked like." title="This is what the agreement between the services
probably looked like." /></p>
<h3 id="what-is-quickcheck">What is Quickcheck?</h3>
<p>Quickcheck is a Haskell library that does a thing called Property Testing. It has since been ported to many other languages. A nice intro lives here
at <a href="https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing">School of
Haskell</a> - the tldr is that it lets us test properties about our programs by randomly generating examples and seeing if they fit rules that we define.</p>
<h3 id="so-what-is-your-so-called-idea-then">So, what is your so-called idea then?</h3>
<p>OK. So one of the main concepts behind QuickCheck is the <code>Arbitrary</code> typeclass.
Any datatype with an instance of this typeclass is able to generate random
example values that can be used for testing.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">module </span><span>ContractTests </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#b48ead;">import </span><span>Data.Aeson
</span><span style="color:#b48ead;">import </span><span>GHC.Generics
</span><span style="color:#b48ead;">import </span><span>Test.QuickCheck.Arbitrary
</span><span>
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Horse
</span><span>  = </span><span style="color:#d08770;">BigHorse
</span><span>  | </span><span style="color:#d08770;">SmallHorse
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Generic</span><span>, </span><span style="color:#a3be8c;">FromJSON</span><span>)
</span><span>
</span><span style="color:#b48ead;">instance Arbitrary Horse where
</span><span>  arbitrary =
</span><span>    oneof
</span><span>      [ pure </span><span style="color:#d08770;">BigHorse</span><span>,
</span><span>        pure </span><span style="color:#d08770;">SmallHorse
</span><span>      ]
</span></code></pre>
<p>This datatype <code>Horse</code> describes the two kinds of horse, <code>BigHorse</code> and <code>SmallHorse</code>. As is hopefully hand-wavingly evident, when the <code>arbitrary</code> function is run it returns one of <code>BigHorse</code> or <code>SmallHorse</code>.</p>
<p><img src="/images/contract-horse.png" alt="This is a horse." title="This is a horse." /></p>
<p>If we can make one <code>Horse</code>, then surely we can make a load of them? Indeed!
This is what the instance for <code>List</code> look like - the <code>Arbitrary a =&gt;</code>
constraint means that if we can make any <code>Arbitrary</code> value, we can make a list
of them.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">instance Arbitrary </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">=&gt; Arbitrary</span><span> [</span><span style="color:#bf616a;">a</span><span>] </span><span style="color:#b48ead;">where
</span><span>  ...
</span></code></pre>
<p>The Quickcheck library defines instances for most basic types, as well as most
collections, therefore it is quite simple to build <code>Arbitrary</code> instances for
our request and response datatypes - and that is exactly what we're going to
do.</p>
<h3 id="an-example">An example</h3>
<p>Let's think about a nice simple API. It receives <code>POST</code> requests in <code>JSON</code> format that translate into a datatype that looks like this:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">APIRequest
</span><span>  = </span><span style="color:#d08770;">APIRequest
</span><span>      { name      :: </span><span style="color:#d08770;">String
</span><span>      , age       :: </span><span style="color:#d08770;">Int
</span><span>      , horseSize :: </span><span style="color:#d08770;">Horse
</span><span>      }
</span></code></pre>
<p>Assuming that the requests are OK, it returns a response shaped like this
(again, sent over the wire in <code>JSON</code> format).</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">APIResponse
</span><span>  = </span><span style="color:#d08770;">APIResponse
</span><span>      { weight :: </span><span style="color:#d08770;">Int
</span><span>      , goodHorse :: </span><span style="color:#d08770;">Bool
</span><span>      }
</span></code></pre>
<p>These types are shown in <code>Haskell</code>, but the equivalent pair will also exist in
the frontend, and it's the compatibility between the two pairs that we will be checking.</p>
<p>Our testing is going to work like this:</p>
<ol>
<li>Our frontend will generate 100 example <code>APIRequest</code> values</li>
<li>Each one will be turned into JSON</li>
<li>Each piece of JSON is saved into a file</li>
<li>Our backend will decode each piece of JSON and see if it makes sense</li>
<li>If it does - great!</li>
</ol>
<p>Then, for responses, we do the same thing in reverse:</p>
<ol>
<li>Our backend will generate 100 example <code>APIResponse</code> values</li>
<li>Each one will be turned into JSON</li>
<li>Each piece of JSON is saved into a file</li>
<li>Our frontend will decode each piece of JSON and see if it makes sense</li>
<li>If it does - great!</li>
</ol>
<p>Essentially, a contract between two services is a complete set of these for each endpoint. In this article I will explain the <code>Haskell</code> part of this, and will follow with the front end portion in the next one.</p>
<p><img src="/images/contract-horses.png" alt="These are all horses." title="These are all horses." /></p>
<h3 id="creating-the-sample-responses">Creating the sample responses</h3>
<p>We're going to need to add some typeclass instances for our <code>APIResponse</code> type first, so let's change it to the following:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">import </span><span>Test.QuickCheck.Arbitrary.Generic
</span><span>
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">APIResponse
</span><span>  = </span><span style="color:#d08770;">APIResponse
</span><span>      { weight :: </span><span style="color:#d08770;">Int</span><span>,
</span><span>        </span><span style="color:#8fa1b3;">goodHorse </span><span style="color:#b48ead;">:: Bool
</span><span>      }
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Generic</span><span>, </span><span style="color:#a3be8c;">ToJSON</span><span>)
</span><span>
</span><span style="color:#b48ead;">instance Arbitrary APIResponse where
</span><span>  arbitrary = genericArbitrary
</span></code></pre>
<p><code>genericArbitrary</code> is provided by the <code>generic-arbitrary</code> package which allows <code>Arbitrary</code> instances to be created for any datatype with a <code>Generic</code> instance. (For more intro on the idea of generics, the <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html">Hackage</a> page is a good start.)</p>
<p><code>ToJSON</code> is provided by <code>Aeson</code>, the excellent package for all dealings with JSON, and deserves a whole post of it's own. For our purposes, all we need to know is that for any datatype with a <code>Generic</code> instance, we can derive a free typeclass for turning it to and from JSON.</p>
<p>The special sauce for all of this action is the <code>generate</code> function from
<code>Test.QuickCheck.Gen</code>, which generates any number of values for a given
<code>Arbitrary</code> instance. We use this with a bunch of other housekeeping functions to take these 100
items and turn them into 100 files. I have broken this down into a bunch of
functions so that it's hopefully easier to follow.</p>
<p>Firstly, a couple of helpers for adding index numbers to lists...</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">indexList </span><span style="color:#b48ead;">::</span><span> [</span><span style="color:#bf616a;">a</span><span>] </span><span style="color:#b48ead;">-&gt;</span><span> [(</span><span style="color:#b48ead;">Int</span><span>, </span><span style="color:#bf616a;">a</span><span>)]
</span><span>indexList as =
</span><span>  </span><span style="color:#d08770;">List</span><span>.zip [</span><span style="color:#d08770;">1 </span><span>..] as
</span><span>
</span><span style="color:#65737e;">-- indexList [&#39;A&#39;, &#39;B&#39;] == [(1, &#39;A&#39;), (2, &#39;B&#39;)]
</span></code></pre>
<p>...and creating a file path using said index...</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">createPath </span><span style="color:#b48ead;">:: String -&gt; Int -&gt; String
</span><span>createPath path index =
</span><span>  &quot;</span><span style="color:#a3be8c;">./</span><span>&quot; &lt;&gt; path &lt;&gt; &quot;</span><span style="color:#a3be8c;">/</span><span>&quot; &lt;&gt; (show index) &lt;&gt; &quot;</span><span style="color:#a3be8c;">.json</span><span>&quot;
</span><span>
</span><span style="color:#65737e;">-- createPath &quot;output&quot; 1 == &quot;./output/1.json&quot;
</span></code></pre>
<p>Next, we will make our functions for generating instances and saving them to
files. This first function uses a <code>Proxy</code> (from
<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Proxy.html">Data.Proxy</a>)
to pass the type we would like to generate (as such). We have chosen <code>100</code> as
it is as good a number as any.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">getResponses </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#b48ead;">Arbitrary </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">=&gt; Proxy </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; IO</span><span> [</span><span style="color:#bf616a;">a</span><span>]
</span><span>getResponses _ = generate $ vector </span><span style="color:#d08770;">100
</span></code></pre>
<p>This next function takes our list of randomised values, turns them to JSON, and pops them in a <code>Tuple</code> along with an index.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">listToJSON </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#b48ead;">ToJSON </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">=&gt;</span><span> [</span><span style="color:#bf616a;">a</span><span>] </span><span style="color:#b48ead;">-&gt;</span><span> [(</span><span style="color:#b48ead;">Int</span><span>, </span><span style="color:#b48ead;">BS</span><span>.</span><span style="color:#b48ead;">ByteString</span><span>)]
</span><span>listToJSON = (indexList . jsonifyList)
</span><span>  </span><span style="color:#b48ead;">where
</span><span>    jsonifyList = fmap encode
</span></code></pre>
<p>Finally, we put them together along with some glue code (using <code>writeFile</code> from
<code>Data.ByteString.Lazy</code>) to save the generated <code>JSON</code> files.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">contractWrite </span><span style="color:#b48ead;">::
</span><span>  (</span><span style="color:#b48ead;">ToJSON </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#b48ead;">Arbitrary </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">=&gt;
</span><span>  </span><span style="color:#b48ead;">Proxy </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt;
</span><span>  </span><span style="color:#b48ead;">String -&gt;
</span><span>  </span><span style="color:#b48ead;">IO </span><span>()
</span><span>contractWrite arbType srcPath = </span><span style="color:#b48ead;">do
</span><span>  </span><span style="color:#b48ead;">let</span><span> saveFile = \path (index, json) -&gt;
</span><span>        </span><span style="color:#d08770;">BS</span><span>.writeFile (createPath path index) json
</span><span>  responses &lt;- listToJSON &lt;$&gt; (getResponses arbType)
</span><span>  mapM_ (saveFile srcPath) responses
</span></code></pre>
<p>To use it with our datatype, we use a <code>Proxy</code> as such to pass it the type we
want (in our case, <code>APIResponse</code>, but the same code will work for any type with
<code>Arbitrary</code> and <code>ToJSON</code> instances)</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">contractWriteAPIResponses </span><span style="color:#b48ead;">:: String -&gt; IO </span><span>()
</span><span>contractWriteAPIResponses srcPath =
</span><span>  contractWrite (</span><span style="color:#d08770;">Proxy </span><span>:: </span><span style="color:#d08770;">Proxy APIResponse</span><span>) srcPath
</span></code></pre>
<p>If we crack this open in <code>ghci</code> we can run <code>contractWriteAPIResponses "sample"</code>, and it will create files called <code>1.json</code>, <code>2.json</code> (up to <code>100.json</code>) in the <code>sample</code> folder in the current working directory.</p>
<p>Our frontend tests can now read these and make sure that they understand them.
But how do we make sure our backend understands the front end requests?</p>
<p><img src="/images/contract-business-man.png" alt="I am feeling bad about how many words there are." title="I am feeling bad about how many words
there are." /></p>
<h3 id="reading-the-sample-requests">Reading the sample requests</h3>
<p>Assuming that our front end has also created some sample requests in a similar fashion, reading them and checking they are decodable is a simpler affair.</p>
<p>Given a path that points to a folder full of 100 json files, we can write code to attempt to read them. We are reusing the <code>createPath</code> function from above, but other than, this should do it.</p>
<p>This function takes a <code>Proxy</code> for our decoding type, a path and an index, and
tries to decode the file it finds.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">testFile </span><span style="color:#b48ead;">:: FromJSON </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">=&gt; Proxy </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; String -&gt; Int -&gt; IO</span><span> (</span><span style="color:#b48ead;">Maybe </span><span style="color:#bf616a;">a</span><span>)
</span><span>testFile _ path i = </span><span style="color:#b48ead;">do
</span><span>  str &lt;- </span><span style="color:#d08770;">BS</span><span>.readFile (createPath path i)
</span><span>  </span><span style="color:#b48ead;">case</span><span> eitherDecode str </span><span style="color:#b48ead;">of
</span><span>    </span><span style="color:#d08770;">Left</span><span> e -&gt; putStrLn (show e) &gt;&gt;= \_ -&gt; pure </span><span style="color:#d08770;">Nothing
</span><span>    </span><span style="color:#d08770;">Right</span><span> b -&gt; pure (</span><span style="color:#d08770;">Just</span><span> b)
</span></code></pre>
<p>Here we take a path to the folder full of files and attempt to read <code>100</code>
numbered <code>.json</code> files in it.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">contractRead </span><span style="color:#b48ead;">:: FromJSON </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">=&gt; Proxy </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; String -&gt; IO Int
</span><span>contractRead arbType srcPath = </span><span style="color:#b48ead;">do
</span><span>  maybeFound &lt;- mapM (testFile arbType srcPath) [</span><span style="color:#d08770;">1 </span><span>.. </span><span style="color:#d08770;">100</span><span>]
</span><span>  pure $ length $ catMaybes maybeFound
</span></code></pre>
<p>And here we put it all together using our <code>APIRequest</code> type.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">contractReadAPIRequest </span><span style="color:#b48ead;">:: String -&gt; IO Int
</span><span>contractReadAPIRequest srcPath =
</span><span>  contractRead (</span><span style="color:#d08770;">Proxy </span><span>:: </span><span style="color:#d08770;">Proxy APIRequest</span><span>) srcPath
</span></code></pre>
<p>Cracking open <code>ghci</code> and running <code>contractRead "sample"</code> will attempt to read 100 numbered <code>.json</code> files in the <code>sample</code> folder.</p>
<h3 id="digression-1">Digression 1.</h3>
<p>Note we have used a <code>Proxy</code> type here to pass the type around. An alternative way to do this could be a mixture of <code>TypeApplications</code> and <code>ScopedTypeVariables</code> but in the spirit of <code>#simplehaskell</code> we'll avoid them.</p>
<h3 id="digression-2">Digression 2.</h3>
<p>Whilst preaching simplicity, it seems enjoyably hypocritical to point out in
the same breath that we needn't have made a standalone instance of <code>arbitrary</code>
each time, and it's actually a great opportunity to crack open <code>DerivingVia</code>.</p>
<p>An alternative method could looks something like this, and save up to 15
characters per datatype.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#65737e;">-- this newtype can derive Arbitrary via Generic, so we use Deriving Via to
</span><span style="color:#65737e;">-- steal it&#39;s powers!
</span><span style="color:#b48ead;">newtype </span><span style="color:#d08770;">GenericArb</span><span> a
</span><span>  = </span><span style="color:#d08770;">GenericArb</span><span> {getGenericArb :: a}
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Generic</span><span>)
</span><span>
</span><span style="color:#b48ead;">instance</span><span> (</span><span style="color:#b48ead;">Generic </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#b48ead;">Arbitrary </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">=&gt; Arbitrary</span><span> (</span><span style="color:#b48ead;">GenericArb </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">where
</span><span>  arbitrary = genericArbitrary
</span><span>
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">APIRequest2
</span><span>  = </span><span style="color:#d08770;">APIRequest2
</span><span>      { name2 :: </span><span style="color:#d08770;">String</span><span>,
</span><span>        </span><span style="color:#8fa1b3;">age2 </span><span style="color:#b48ead;">:: Int</span><span>,
</span><span>        </span><span style="color:#8fa1b3;">horseSize2 </span><span style="color:#b48ead;">:: Horse
</span><span>      }
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Generic</span><span>, </span><span style="color:#a3be8c;">FromJSON</span><span>)
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Arbitrary</span><span>) via (</span><span style="color:#d08770;">GenericArb APIRequest2</span><span>)
</span><span>
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">APIResponse2
</span><span>  = </span><span style="color:#d08770;">APIResponse2
</span><span>      { weight2 :: </span><span style="color:#d08770;">Int</span><span>,
</span><span>        </span><span style="color:#8fa1b3;">goodHorse2 </span><span style="color:#b48ead;">:: Bool
</span><span>      }
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Generic</span><span>, </span><span style="color:#a3be8c;">ToJSON</span><span>)
</span><span>  </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Arbitrary</span><span>) via (</span><span style="color:#d08770;">GenericArb APIResponse2</span><span>)
</span></code></pre>
<h3 id="make-sense">Make sense?</h3>
<p>No. Thought not. Regardless, I'll follow up with how to great the front end
part. I'll be using <code>Typescript</code> because quite frankly if you understand this
then doing it in <code>Purescript</code> isn't wildly different.</p>


    </main>

    <footer>
      <p><a href="mailto:danieljamesharvey@gmail.com">Contact</a> |
      <a href="https://github.com/danieljharvey">Github</a></p>
      <p>Links for nerds:
        <a href="/atom.xml">atom</a>
        <a href="/rss.xml">rss</a></p>

    </footer>
</body>

</html>
