window.searchIndex = {"fields":["title","body"],"pipeline":["trimmer","stopWordFilter","stemmer"],"ref":"id","version":"0.9.5","index":{"body":{"root":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951}},"df":7},"1":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":4.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":4.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":17,"+":{"docs":{},"df":0,"1":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},",":{"docs":{},"df":0,"2":{"docs":{},"df":0,",":{"docs":{},"df":0,"3":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":2,",":{"docs":{},"df":0,"4":{"docs":{},"df":0,",":{"docs":{},"df":0,"5":{"docs":{},"df":0,",":{"docs":{},"df":0,"6":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":1}}}}}}}}}},".":{"docs":{},"df":0,"1":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1},"3":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1},"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}},"0":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3,"0":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.23606797749979}},"df":5,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}},"0":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}},"x":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951}},"df":2}},"2":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":3},"4":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1},"5":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":2},"8":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}},"2":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.449489742783178},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":11,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}},"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2,"2":{"docs":{},"df":0,"4":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}},"2":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1},"7":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"3":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":7,"0":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2,"0":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"4":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951}},"df":4,",":{"docs":{},"df":0,"5":{"docs":{},"df":0,",":{"docs":{},"df":0,"6":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1}}}},"2":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2},"8":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"5":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":4},"6":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":3,"5":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"7":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1},"8":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1},"9":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1,"0":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"_":{"docs":{"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772}},"df":2},"a":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}},"_":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":10}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":7}}}}}},"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}}},"c":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":3}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":5}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":2}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":4,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":7}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.449489742783178},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":29}}}}},"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":17,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}},"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":4.58257569495584},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":24,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,",":{"docs":{},"df":0,"2":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}},"3":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.449489742783178}},"df":1},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.449489742783178},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":3,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2}}}}}}}},"o":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":3}}},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}}}},"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772}},"df":1}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3}}}},"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":3.3166247903554}},"df":1,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}}}}}}}},"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.449489742783178},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772}},"df":23,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":2}},"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}},"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":3}},"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":3.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":3,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"x":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":1,"s":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":2}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2,"a":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":1}},"w":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":20}}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":3,"g":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":9}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":6,"t":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":12}}}}},"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":3}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":9}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}}},"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951}},"df":1}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":2}},"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}}},"d":{"docs":{},"df":0,"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}}},"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.449489742783178}},"df":1}},"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":3,"o":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772}},"df":2},"y":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":26}}},"s":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":7}}}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}},"y":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":19}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":13}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":4}}}}}},"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":3}}},"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"(":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}}},"p":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":4,"'":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951}},"df":1},"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":6}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":2}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2},"s":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":2}}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":12,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.3166247903554},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":14,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":1}}},"v":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1},"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":3.3166247903554},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":5}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":3}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":12}}}},"g":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.3166247903554},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772}},"df":10}}}}}},"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":22}}}},"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":1,"a":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.449489742783178}},"df":8,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}},"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}},"s":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":2},"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":5}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.8284271247461903}},"df":1,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.0}},"df":2}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}},"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":8},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":3}}},"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":5,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":3}}},"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":5},"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":4}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":7,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951}},"df":1}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951}},"df":6}}}},"w":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1},"y":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":8}},"k":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}},"y":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"b":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":3.3166247903554},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":3.3166247903554},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17,"_":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":20,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.0}},"df":3}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}}}}}},"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":8,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":6},"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":19}}}},"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":13,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}},"l":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13}}},"d":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":19,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":3,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":7}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":3},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}},"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.8284271247461903}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":5,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951}},"df":1}}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0}},"df":8}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":2}}}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.6457513110645907}},"df":2}}}}}}},"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":14,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951}},"df":1}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.449489742783178}},"df":2}}},"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":4,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.449489742783178},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":11},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":25,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}},"g":{"docs":{"https://danieljharvey.github.io/":{"tf":1.0},"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":6},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":9}}},"w":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.449489742783178}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}},"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979}},"df":2}},"g":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}},"u":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":3}},"o":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":1,"k":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3},"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":7,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":6}}}},"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":3,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":5}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":4}}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}}}}}},"x":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0}},"df":2}},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":4}}},"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":12},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":3}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":7}}},"w":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}},"e":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}},"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":9},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":4}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":10}}},"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.8284271247461903}},"df":11}},"y":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951}},"df":1}}},"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":7,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772}},"df":1}}},"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":4,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":6}}},"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":28,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":3.1622776601683795}},"df":1}}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":4}},"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":10}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772}},"df":1}}},"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}}}}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":3.3166247903554}},"df":1}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":5}}}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":4}}},"s":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":22},"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":1}},"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}},"c":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":1}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}},"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}},"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":3.605551275463989},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":29},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3}}}},"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}},"r":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":3}},"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.449489742783178},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":26,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":1}}}},"w":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772}},"df":2,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":8}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":5}}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":1}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"g":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0}},"df":1}},"p":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2},"y":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":4,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":8}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}},"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":7,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":3}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":7}}}},"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1},"k":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":6,"r":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3}},"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1}},"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":3.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":4.58257569495584},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":24,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}}},"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":6}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772}},"df":2}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.23606797749979},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":21,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}}}}}}},"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":30},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":5}},"u":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0}},"df":1}},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":4.358898943540674},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951}},"df":8}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":10},"x":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}}},"o":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":4}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":13,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}}}}}}}},"n":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13,"u":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5}}},"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":6}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1},"g":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772}},"df":2,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772}},"df":2}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}},"f":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":9}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":5,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":7}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":20}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":6}},"x":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":9,"u":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":2,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":2}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951}},"df":4}}}}},"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5}},"o":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":6,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951}},"df":1}}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":3},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":5}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}},"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.3166247903554}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":2},"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":5},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.0}},"df":1}}}},"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":4,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}}}}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":6}},"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":3}},"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}}}}}},"p":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":4,"p":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"z":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.0}},"df":24,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}}},"i":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1,"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":1}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":8}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":2}}}},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":2,"0":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"1":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1},"n":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}}}},"r":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":3.872983346207417},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.23606797749979},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772}},"df":18,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}}}}},"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"z":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951}},"df":1}}},"q":{"docs":{"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0}},"df":1}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}}},"x":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1}}}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":8}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/data-migrations/":{"tf":4.242640687119285},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":22}}}},"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}},"y":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":4}},"b":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0}},"df":2,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.23606797749979}},"df":1,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}}}}}}}}}},"c":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.8284271247461903}},"df":1},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1},"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":10,"t":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}},"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":11},"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":4},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"4":{"docs":{},"df":0,"5":{"docs":{},"df":0,"6":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":9}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":23,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":14}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":2,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}},"v":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":10}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772}},"df":7,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":12},"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":3}},"r":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":2}},"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":5}}}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}},"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":4}}}},"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":16}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":11}}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951}},"df":1}}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.1622776601683795}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2}}}}}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}},"d":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":4}}}},"o":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2}}}}}},"v":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"s":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}},"o":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":23,"b":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3}}}}}},"d":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":1}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":21}}}}},"g":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":5,"'":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772}},"df":1},"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":3}}}},"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":27}},"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13,"_":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772}},"df":1}}},"g":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}}},"w":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":9,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951}},"df":1}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1,"t":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}},"w":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":4}}},"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}},"s":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.8284271247461903}},"df":1},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}},"e":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":2}},"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}},"p":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":22}},"g":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979}},"df":1}}}},"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":16},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}}}}},"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":15,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":8}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}}},"t":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"d":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}},"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":4.123105625617661},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":7,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":2}}}}},"g":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.605551275463989},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.6457513110645907}},"df":4}},"i":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1},"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.605551275463989}},"df":3}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.23606797749979}},"df":4}}}}},"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1},"_":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":1}},"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":3.1622776601683795}},"df":9}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":18,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951}},"df":4}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":14}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":5}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":8}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":5}}},"v":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.6457513110645907}},"df":3}}}}}},"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772}},"df":1}}}},"q":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":5}},"i":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":8}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":13}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":4}}}}}},"t":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":9}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772}},"df":3}},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979}},"df":1}},"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":17,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":2,"u":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":16},"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":2},"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}}},"x":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":12}}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":27}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":11},"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":6}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":11}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":1}},"m":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":2}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":5}},"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":3}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":3}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":10}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":4}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":5}},"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":6},"s":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":3}}},"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772}},"df":4,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":3.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0}},"df":13}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":5},"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2},"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":2,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":5}}}}}},"y":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}}}},"f":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":9,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":10,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"(":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":10,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":4}}},"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":5}}}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":4,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":5}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}}}}}},"n":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":3,"c":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":9},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}}}},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.0}},"df":3}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":2},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":7}}}},"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":14},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":3}}},"w":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":14}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951}},"df":2}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":3}}},"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":10},"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772}},"df":2}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":10}},"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":20},"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":17},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}},"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":3},"m":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":2.449489742783178},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":3.3166247903554},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":30,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":11}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":5},"x":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979}},"df":1}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772}},"df":1}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.0}},"df":1}},"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"p":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1},"w":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":3.605551275463989},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":8}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0}},"df":7}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951}},"df":1}},"k":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":2},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":17}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"v":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":2}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772}},"df":1}},"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}},"k":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1},"m":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":11}},"r":{"docs":{"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":3}},"x":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"p":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":2}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}},"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":3.605551275463989},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":12},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.6457513110645907}},"df":1}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772}},"df":6,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}}}}},"w":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":12,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":4,"c":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0}},"df":1}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/contract-testing/":{"tf":3.0},"https://danieljharvey.github.io/data-migrations/":{"tf":4.69041575982343},"https://danieljharvey.github.io/datatypes-either/":{"tf":3.605551275463989},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":3.0},"https://danieljharvey.github.io/do-notation/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.3166247903554},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":4.358898943540674},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":7.416198487095663},"https://danieljharvey.github.io/new-types/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":3.605551275463989},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":5.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/refined-types/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":4.47213595499958},"https://danieljharvey.github.io/total-functions/":{"tf":4.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":4.358898943540674},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":3.605551275463989},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":4.69041575982343},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.449489742783178}},"df":44}}},"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":3.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":4.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.1622776601683795}},"df":15}}}},"n":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":34}}}}},"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":8}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":4.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.6457513110645907}},"df":4}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.449489742783178},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":3.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":21,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":4}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"i":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"r":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951}},"df":17,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":2}}}}},"h":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":4,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":11}},"i":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"9":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2}}},"m":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":22,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":12}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2}}},"o":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/data-migrations/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.449489742783178},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":37,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":5},"n":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":4},"n":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":27,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}}},"f":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":3}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":4},"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}}}}}},"s":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":34}},"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1},"p":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"w":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":3.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":3.3166247903554},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":20,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":4}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":5}}}},"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":7}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":6}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":3}},"i":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":3}},"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":16,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3},"l":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}},"g":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":2}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":22}},"i":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.23606797749979}},"df":1}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":30,"l":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2}}}},"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":10,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":3}}}}}},"e":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3},"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":4},"r":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":2,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1,"'":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1},"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":2}}}}}}},"v":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13,"o":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7}},"p":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":23,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":9}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":4}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.605551275463989},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.0},"https://danieljharvey.github.io/new-types/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":42,"'":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":14}},"o":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979}},"df":1}}}}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0}},"df":1,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":3}}}}},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":10},"e":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":4}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":4,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951}},"df":2},"g":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":4}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":21}}}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.23606797749979}},"df":2}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":2}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":1}}},"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979}},"df":2},"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":3,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":1}}}}}},"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"j":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":4}},"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":3,"&":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"4":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2}}},"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"'":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951}},"df":3}},"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":16},"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":9}},"1":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772}},"df":1},"3":{"docs":{},"df":0,"2":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772}},"df":3}},"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":14,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":4}},"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178}},"df":5,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":12},"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":7}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.8284271247461903}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":5}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":6}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":3}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":17}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":12,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":3}}},"o":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2}}}}},"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":6}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}},"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":12,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"x":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":3}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":3}}}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":4,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":3}}},"x":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":4}},"o":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":5,"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}}}},"g":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":5,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,",":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772}},"df":1}},"o":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":12}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":26},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3},"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":3.605551275463989},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-either/":{"tf":3.605551275463989},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":3.3166247903554},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.605551275463989}},"df":32}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":29}}}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":13,"3":{"docs":{},"df":0,"2":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.605551275463989},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":6},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3},"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":8}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":24}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":2}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":4}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":6,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":8}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":7}}}}},"o":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":2.23606797749979},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":4.358898943540674},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.449489742783178},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":4.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772}},"df":10},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979}},"df":3,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.23606797749979},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17}}},"o":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":3.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.23606797749979},"https://danieljharvey.github.io/total-functions/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.8284271247461903}},"df":40,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":3},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":3}}},"e":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.449489742783178},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":18},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":10}}}}},"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":12}}}}}}}},"z":{"docs":{},"df":0,"z":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772}},"df":1,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":15},"h":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979}},"df":2,"n":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":4.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":4}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1}}},"q":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":3,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":3.872983346207417},"https://danieljharvey.github.io/data-migrations/":{"tf":3.3166247903554},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.0}},"df":6}}},"u":{"docs":{},"df":0,"d":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":4}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}},"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.0}},"df":1}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1},"p":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":9}},"r":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"y":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":7}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":15,"a":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":2}},"g":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"w":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":23,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":3}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":5}}}},"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}},"d":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.449489742783178}},"df":2}}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":3},"g":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":4.123105625617661},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0}},"df":12}}}}},"r":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":3}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":12,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":3}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}}},"w":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.8284271247461903}},"df":2,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"y":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951}},"df":3}}},"z":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":5}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":1},"k":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":11}},"v":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":7}},"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":2},"f":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":3.872983346207417},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.8284271247461903}},"df":11,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}}}}}}}}}},"n":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":3.3166247903554},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":5,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":3}}},"s":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951}},"df":2}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":10,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":14,"'":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.605551275463989},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":43},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":11}}},"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}},"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":14}}}}},"f":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":5},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1,"f":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772}},"df":1}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0}},"df":1,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}}}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":3}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":5}}},"n":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":7},"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":7}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":3.3166247903554},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/total-functions/":{"tf":3.3166247903554},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.449489742783178}},"df":25,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0}},"df":3}},"t":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17}}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}},"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":6.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.1622776601683795}},"df":4,"'":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1},".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}}}},"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":15,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":4}}},"g":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":7}}},"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}},"e":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":3},"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":40,"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979}},"df":1}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1}}}}}},"p":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":4}},"s":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":3},"s":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":26},"u":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":8}},"w":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.449489742783178}},"df":2,";":{"docs":{},"df":0,"$":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":2}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}}},"*":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0}},"df":5}}}},"|":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772}},"df":3}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":2}}}}},"m":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951}},"df":3,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":6.48074069840786}},"df":2}}},"o":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951}},"df":1}},"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":15}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":7}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":15,".":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.449489742783178},"https://danieljharvey.github.io/contract-testing/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/data-migrations/":{"tf":3.605551275463989},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":4.47213595499958},"https://danieljharvey.github.io/total-functions/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.3166247903554}},"df":44,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":3.0}},"df":1}}},"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3}},"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":14},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":5}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951}},"df":4}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}}}},"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":14,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0}},"df":1}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951}},"df":1}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":1}}},"k":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":2,"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":16,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"z":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}}}}},"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}}},"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":2}}}}},"y":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":3.605551275463989},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.449489742783178},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.449489742783178},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":23,"e":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.7320508075688772}},"df":1}}}}}},"d":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":34,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":2,"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0}},"df":1}}}}}}}},"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3}}},"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.6457513110645907}},"df":5}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":9}}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":6,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":3}},"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1,"l":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}}},"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":1,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}}}}},"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":3.872983346207417}},"df":1}}}},"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.449489742783178}},"df":1}}}},"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":4}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":9,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":5,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"u":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}},"x":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772}},"df":2,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":1}},"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0}},"df":1},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":11,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951}},"df":2}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":3}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772}},"df":1}}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951}},"df":1}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":11}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":5}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":41,"s":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.0}},"df":1}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3}}}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":4.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":9,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0}},"df":1}}}}}},"w":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"y":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0}},"df":1}}}},"z":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":28}},"d":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3,"d":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951}},"df":1}}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":10,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":6}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}},"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951}},"df":1}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951}},"df":1}}}},"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951}},"df":2}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.6457513110645907}},"df":1}}}},"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178}},"df":1},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2},"v":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":17,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951}},"df":6,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}}}}},"e":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.605551275463989},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":34,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}}},"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772}},"df":1}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951}},"df":3}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":4}}},"w":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/data-migrations/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.449489742783178},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.449489742783178},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":27,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":11}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903}},"df":1}}},"x":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":18}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":30,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":6}},"k":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.605551275463989}},"df":1,"\"":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.0}},"df":1}},"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"l":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}},"d":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":2,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":6,"e":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}}}}},"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0}},"df":1}},"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":4}},"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":20},"h":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.23606797749979},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":27,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1}}}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":13}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}},"w":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.449489742783178},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.23606797749979},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":39}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}},"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":3,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":3.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":20}}}}}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"y":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":2}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":3}}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}},"d":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.3166247903554}},"df":1}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1,"i":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979}},"df":1},"x":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979}},"df":1}}}}}},"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":11},"k":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":29},"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":3.872983346207417},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":10,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":3.0}},"df":1}}},"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":3.3166247903554},"https://danieljharvey.github.io/datatypes-either/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.449489742783178},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.449489742783178},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.23606797749979},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.6457513110645907}},"df":42,"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":16},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951}},"df":1}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":7}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":4}}}}},"o":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":3},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":10,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":4}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951}},"df":2},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3}}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}}}}},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":3.0}},"df":7,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.23606797749979}},"df":9}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":12}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":3}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":8}}}}},"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":38,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951}},"df":1}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":9}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":4}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":23,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":1}}}}}}}}}},"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":3},"k":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.23606797749979},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":8,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}},"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0}},"df":1}}}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"d":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":5}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1},"n":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3},"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":3}},"l":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772}},"df":1}}}},"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772}},"df":5,"e":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0}},"df":1}}}}}}},"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772}},"df":3}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":20,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":5,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":26},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1,"a":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0}},"df":3},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951}},"df":13}}}}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951}},"df":2}},"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}},"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":14}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":4}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":3}}}},"e":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1,"c":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":8}},"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1},"k":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":1,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"q":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}},"z":{"docs":{},"df":0,"z":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":12,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}},"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":3},"t":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":4}}}}},"y":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.0}},"df":1,"'":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":10}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":5},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}},"u":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":5,"m":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":19,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":3.4641016151377544}},"df":1}},"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":3}}}}}}},"o":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}},"r":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":3}},"p":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":5,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":5,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":3.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":13}}}},"t":{"docs":{"https://danieljharvey.github.io/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":11,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":10}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":4}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":3.1622776601683795}},"df":1}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/refined-types/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772}},"df":4,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}},"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":5}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":2}}},"s":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2},"u":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":24},"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":1}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":5,"s":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":2},"k":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":6,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":3.4641016151377544}},"df":2}}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":14}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":16}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":4,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}},"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":8}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772}},"df":3}}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":14,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":5}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}}}}}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}},"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7}}}}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":14}}},"x":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0}},"df":1}}}},"s":{"docs":{},"df":0,"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1}}}}}}}}}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":5},"p":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772}},"df":9,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7,"'":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":3}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":22,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}}}}}}},"y":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":1}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.4142135623730951}},"df":3},"y":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951}},"df":1}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":7}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":3,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":4}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":4}}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":22}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}},"d":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}},"n":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":3,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}},"w":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}},"e":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":4}},"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":40,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.0}},"df":6,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}},"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":6},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772}},"df":1}}}},"l":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":7,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":3,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.449489742783178}},"df":29}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":6}},"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":7}}},"k":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":6,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}}}}},"d":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3},"x":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":6,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":4.898979485566356}},"df":1,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":8}}}}},"l":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":3,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}},"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"k":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}},"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":9}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":2}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.449489742783178}},"df":3,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}},"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":5,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":6}},"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":8,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":4}}},"i":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":6}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":8}}}},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":8,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":20}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.0},"https://danieljharvey.github.io/do-notation/":{"tf":2.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.872983346207417},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/total-functions/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":35}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2}}}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":3.872983346207417},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":23,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}},"k":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":3}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0}},"df":1}},"w":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.449489742783178},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":3.3166247903554},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":3.1622776601683795}},"df":3,"'":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":6}},"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":29,"_":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":3}}}}}},"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":5,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":3},"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}}},"f":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":4,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}}},"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.23606797749979}},"df":31},"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772}},"df":3}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}}}}},"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":8}},"w":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1},"x":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}}},"y":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":1}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}},"n":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.449489742783178}},"df":2}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":3,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":2,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}}},"w":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":3}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772}},"df":8,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":7}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2}}}}},"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":38,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0}},"df":28},"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":4}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.23606797749979},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":4,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}}},"f":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}},"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":2.449489742783178},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":3.4641016151377544}},"df":5,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}}}}}}}}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":4},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":33,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":5}}}},"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":3}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1},"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979}},"df":3,"e":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":8,"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"v":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}}}},"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":19,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}},"l":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":3}},"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":4}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":5}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}},"p":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":13,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":6,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}}}},"t":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":4}},"w":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":18,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":4},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951}},"df":1}}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":11,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2}},"n":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":13}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":20}}}},"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":18,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":3},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":5}}},"i":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4,"c":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1},"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":9,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":3},"z":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"e":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2},"p":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1}},"t":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":7}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":2},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1},"w":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":8,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":3}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951}},"df":1}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":11}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"z":{"docs":{},"df":0,"z":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":3}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":10}},"v":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":6}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178}},"df":1}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":3}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.449489742783178},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":34},"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":4}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":20}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4}}}}}},"n":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":10}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951}},"df":7}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":20,"a":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":8}},"p":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1,"i":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":6}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":6,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"f":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951}},"df":5,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":4}}}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3},"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}},"n":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":3},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1,"n":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}}}}}}}}},"q":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":2,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0}},"df":1}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}},"g":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":7}}}}},"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":28,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.3166247903554},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":4,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":4}}}},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":5},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":1}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}},"y":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}},"p":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":3},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":16}},"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951}},"df":2}}},"p":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":8},"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":6}}}}}}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.605551275463989},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.449489742783178},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/refined-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-show/":{"tf":3.0}},"df":24}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1,"u":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}}}},"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":29}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":2}}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":7}}}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":3}}}},"u":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772}},"df":3,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.3166247903554}},"df":2}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"l":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}},"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":22},"k":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":1}},"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}}}}},"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":4,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"'":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":9},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951}},"df":3,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}},"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":6}}}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":21},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":5,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}},"x":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":5}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":8,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":5}},"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1,"l":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772}},"df":3},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"k":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.449489742783178},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":33,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":5}}},"l":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":17}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1},"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}}},"b":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}},"m":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":15}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}}}},"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":4,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951}},"df":1,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":11}},"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":4},"y":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/contract-testing/":{"tf":3.3166247903554},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":6.557438524302},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/testing-io/":{"tf":3.3166247903554},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.449489742783178}},"df":14,".":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772}},"df":1}}}}},"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772}},"df":1}}}}}},"x":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}}}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":5,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}}}}}},"t":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1,"'":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":31,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951}},"df":1}},"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.23606797749979}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":13,"l":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":25}}}}},"y":{"docs":{},"df":0,"'":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3}},"r":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":10},"v":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"g":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1,"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.23606797749979},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/new-types/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.449489742783178},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-show/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.449489742783178}},"df":40},"k":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":28}},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":13}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":22,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":9}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":7,"p":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":11,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}}}},"w":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":11,"n":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"u":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":8,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":4}},"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1},"l":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":36,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"i":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,";":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951}},"df":2}}},"d":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0}},"df":2}}},"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":10,"'":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"o":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":2}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":24}}}},"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":5},"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3},"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":7}},"p":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":7,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":30}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}}}},"r":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}},"y":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}}}}}}}},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.872983346207417},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":6}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}},"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.3166247903554},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":3.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0}},"df":24,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":5,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951}},"df":2}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":4}}}},"u":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951}},"df":8},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2}}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"s":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772}},"df":2},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.23606797749979}},"df":3}},"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":23}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":7}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.449489742783178},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":33}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.449489742783178},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/data-migrations/":{"tf":4.69041575982343},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.449489742783178},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":6.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":4.69041575982343},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.449489742783178},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.449489742783178},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":3.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":4.358898943540674},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.23606797749979},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":6.082762530298219},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":3.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":40,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.7416573867739413}},"df":8,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}},"m":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":3.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":4.898979485566356}},"df":25,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.6457513110645907}},"df":5}}}}}}},"o":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}}}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"k":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.449489742783178}},"df":1}}}},"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":3}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":16}}}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.6457513110645907}},"df":1,"i":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0}},"df":1}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}}},"q":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":3}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772}},"df":1}}},"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":7}},"k":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":4.123105625617661}},"df":2}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}}}}}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":6}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951}},"df":1}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":2}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1,"u":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":8}}}}},"p":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":2.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.449489742783178},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":30,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":7}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":2.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}},"l":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772}},"df":1}},"s":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":3.0},"https://danieljharvey.github.io/contract-testing/":{"tf":3.3166247903554},"https://danieljharvey.github.io/data-migrations/":{"tf":4.358898943540674},"https://danieljharvey.github.io/datatypes-either/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":3.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":4.47213595499958},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.3166247903554},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":2.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":3.3166247903554},"https://danieljharvey.github.io/refined-types/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/testing-io/":{"tf":3.3166247903554},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":4.242640687119285},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.23606797749979},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.449489742783178}},"df":43,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.4142135623730951}},"df":14,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":9}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":3}}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772}},"df":3}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/total-functions/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.6457513110645907}},"df":11,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"u":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":2.449489742783178},"https://danieljharvey.github.io/data-migrations/":{"tf":2.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":4.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":4.358898943540674},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.3166247903554},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":3.0},"https://danieljharvey.github.io/polymorphism/":{"tf":2.23606797749979},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":3.7416573867739413},"https://danieljharvey.github.io/tags-and-shit/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/testing-io/":{"tf":2.23606797749979},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":3.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":3.605551275463989},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":3.872983346207417},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":2.23606797749979},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":38,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":3.4641016151377544},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":8}},"t":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951}},"df":3}},"o":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2}}}}},"e":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}}},"i":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.449489742783178},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":32},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":5.0990195135927845},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":14,"o":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":3},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":3}}},"e":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":3}},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":5}},"l":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":1},"l":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":2}},"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.23606797749979},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.23606797749979},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":32}},"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":4.898979485566356}},"df":1},"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":2.449489742783178}},"df":1},"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":4}}},"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":5}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":3}},"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1,"y":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}},"i":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}},"y":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.449489742783178},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":35}},"e":{"docs":{},"df":0,"'":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":11},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":2.23606797749979},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":3.605551275463989},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.872983346207417},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":2.23606797749979},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":29}},"r":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.23606797749979},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.449489742783178},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":28},"v":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":25}},"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}},"b":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.4142135623730951}},"df":3}}}},"e":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1,"k":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":12,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}},"o":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":4}}},"l":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/data-migrations/":{"tf":2.449489742783178},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":2.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/new-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.7320508075688772}},"df":34}},"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951}},"df":5}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.7320508075688772}},"df":25},"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":15,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":3}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":10}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":4}}}},"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":6}}},"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":14}},"o":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951}},"df":5,"l":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":2}}}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":2}}}},"p":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772}},"df":2}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":21}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":9}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":3}}},"k":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0}},"df":1}}}},"k":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/contract-testing/":{"tf":2.23606797749979},"https://danieljharvey.github.io/data-migrations/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":2.8284271247461903},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":3.1622776601683795},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/polymorphism/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":2.23606797749979},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":2.449489742783178},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":2.0}},"df":38},"l":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":6}},"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":4}},"s":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":4,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":4}},"t":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951}},"df":6,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":3}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/do-notation/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/new-types/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":21,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"f":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":5}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772}},"df":1}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":2.23606797749979},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":2.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":29,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}},"r":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.4142135623730951}},"df":3}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.4142135623730951}},"df":9}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":12}},"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":3}}}}},"x":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.449489742783178}},"df":1},"y":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":2.0}},"df":1,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.7320508075688772},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":11,"a":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":2.6457513110645907},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":2.449489742783178},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":5},"r":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":6}},"p":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951}},"df":2}},"u":{"docs":{},"df":0,"'":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":4},"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.0},"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":12}},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":11},"v":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":5}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/data-migrations/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":5}}}}}}}},"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.4142135623730951}},"df":8}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}},"title":{"root":{"docs":{},"df":0,"1":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":5},"2":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":4},"3":{"docs":{"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":2},"4":{"docs":{"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":1},"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}}}}}},"f":{"docs":{},"df":0,"f":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0}},"df":1}}}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":7}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":3}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":2}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0}},"df":1}}}}}}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":4}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/datatypes-either/":{"tf":1.0},"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":2}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0}},"df":1}}}}},"q":{"docs":{"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0}},"df":1},"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0}},"df":1}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{"https://danieljharvey.github.io/the-genius-of-concrete/":{"tf":1.0}},"df":1}}}},"o":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/do-notation/":{"tf":1.0},"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/polymorphism/":{"tf":1.0},"https://danieljharvey.github.io/total-functions/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":8}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"o":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.4142135623730951}},"df":1},"t":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/testing-io/":{"tf":1.0}},"df":1}}},"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"z":{"docs":{},"df":0,"z":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/content-addressed-languages/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":5}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0}},"df":2},"t":{"docs":{},"df":0,"'":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":4}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{"https://danieljharvey.github.io/datatypes-maybe/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"https://danieljharvey.github.io/data-migrations/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/new-types/":{"tf":1.0},"https://danieljharvey.github.io/tags-and-shit/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/do-notation/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"tf":1.0},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-1-lens/":{"tf":1.0},"https://danieljharvey.github.io/optics-pt-2-prism/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0},"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":12}}},"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"z":{"docs":{},"df":0,"a":{"docs":{"https://danieljharvey.github.io/free-like-pizza/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"https://danieljharvey.github.io/polymorphism/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0}},"df":1}}}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/getting-started-pt-1/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/purescript-aff/":{"tf":1.0},"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0}},"df":2}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0}},"df":1}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://danieljharvey.github.io/refined-types/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://danieljharvey.github.io/purescript-semigroups/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0}},"df":2}}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/contract-testing/":{"tf":1.0},"https://danieljharvey.github.io/property-testing-mimsa/":{"tf":1.0},"https://danieljharvey.github.io/testing-io/":{"tf":1.0},"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://danieljharvey.github.io/total-functions/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0}},"df":1}}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://danieljharvey.github.io/typechecking-pt1/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://danieljharvey.github.io/typeclasses-alternative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-applicative/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-contravariant/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-eq/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-foldable/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-functor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monad/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-monoid/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-ord/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-profunctor/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-semigroup/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-show/":{"tf":1.0},"https://danieljharvey.github.io/typeclasses-traversable/":{"tf":1.0},"https://danieljharvey.github.io/what-is-a-typeclass/":{"tf":1.0}},"df":15}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://danieljharvey.github.io/typescript-contract-tests/":{"tf":1.0}},"df":1}}}}}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{"https://danieljharvey.github.io/announcing-wasm-calc/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"tf":1.0},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"tf":1.0},"https://danieljharvey.github.io/ordering-and-limits/":{"tf":1.0}},"df":4}}}}}}}},"documentStore":{"save":true,"docs":{"https://danieljharvey.github.io/":{"body":"","id":"https://danieljharvey.github.io/","title":"List of blog posts"},"https://danieljharvey.github.io/announcing-wasm-calc/":{"body":"So last year I started writing a\nseries on compiling a functional language to\nLLVM, and I have to confess, I came utterly unstuck.\n\nUntil recent versions, LLVM tried to be helpful by making you specify types\nfor all pointers you pass around. This is really helpful in simple cases as you\nget basic typechecking at compile time. However, once you start implementing things like sum types (ie, reserve a slab of memory, and stuff it with one of several sets of data), it becomes super annoying.\nFor example, compiling an Either&lt;Int, Bool&gt; type requires you to constantly cast between \"arbitrary array type we've chosen\nthat takes up the right amount of memory\", \"this thing if it turns out\nto be Left&lt;Int&gt;\" and \"this thing if it turns out to be Right&lt;Bool&gt;.\nThis has been solved though! More recent versions of LLVM have the concept of an Opaque\npointer, which allows us to pass\npointers around without caring what type they are, and then think about the\ntypes when it comes to actually interacting with the underlying data. This is\nideal!\nHowever, it's only available in LLVM 14 onwards, and getting a working\nversion-matched set\nof LLVM Haskell libraries turns out to be precarious at best. I got reasonably\nclose using\nthe LLVM-15 branch of llvm-hs-pure, but could not find an equivalent for llvm-hs-pretty.\nBasically, it was all getting a bit fiddly and stupid, and writing a tutorial that is either a) already out of date or b) relies on a set of arbitrary commits from a\nbunch of forks doesn't feel like it will be particularly useful, so I have decided to change tack.\nThe good news?\nI decided to port the project to compile to WebAssembly instead! Development of\nthe thing itself has been going really well, see for yourself here: wasm-calc\nThe language is fully featured enough that we can create a very simple\nwasm-4\ngame with it.\n\nSome thoughts so far:\n\n\nThe wasm package for Haskell is lovely!\n\n\nNot being able to cheat by including a bunch of C in a runtime has forced me to learn how allocators work\n\n\nThere's a bunch of useful resources, like\nwatlings and Mozilla's\ndocs.\n\n\nWhat's next?\nAs well as serving as a big excuse, this blog is supposed to be a forcing\nfunction to write the tutorials to go with all the wasm-calc versions. I'll\nstart by porting the llvm-calc blogs, and then move onto the new features\nwe've got.\nMake sense? If not, get in touch!\nFurther reading:\nwasm-calc\n","id":"https://danieljharvey.github.io/announcing-wasm-calc/","title":"llvm-calc is dead, long live wasm-calc"},"https://danieljharvey.github.io/content-addressed-languages/":{"body":"Over the last year and a half I haven't really written much stuff, because I\nhave been working on a small content-addressed programming language called\nmimsa. I'm not really sure why I am doing this, other than that I watched a\nneat tutorial about how typecheckers worked, and then got somewhat carried away.\nI has sat down to write about my recent implementation of property testing in said\nlang, then realised that before I can do that I should probably provide some\ncontext.\nSo, what IS a content-addressed language?\nAccording to Unison, the language that pioneered\nthis concept, this means \"code is immutable and identified by its content\".\nLet's take that apart a bit:\nSay I have a function for adding two numbers:\n\nInstead of just dumping this in a text file, I would \"save\" this function. In\nthe mimsa repl, I would do this:\n\nThis has saved the expression \\a -&gt; \\b -&gt; a + b in the project, and pointed add\nto refer to said expression.\nLet's use our new function:\n\nHopefully, no surprises there.\nLet's make a new function that uses add:\n\nThis has saved the expression add 3 in the DB, and pointed add3 at it. More\nimportantly, it has also remembered exactly which add function it used (more\non this shortly).\n\nLike haskell or elm, mimsa functions only take one argument, so\napplying 3 to add (which has type Int -&gt; Int -&gt; Int) returns a new\nfunction with type Int -&gt; Int.\n\nAgain, let's test it and check for surprises:\n\nAll seems well.\nNow what if we decide to make add evil? We are allowed to rebind it, so let's\ndo that:\n\nNow when we use add we'll get wonky answers as expected.\n\nHowever, look what happens when we use add3:\n\nWe still get the original correct result.\nSo, what has happened here?\nThe answer is in how mimsa expressions are stored. When we stored add, we\nstored not only the expression \\a -&gt; \\b -&gt; a + b , but the fact that\nadd has no dependencies. Internally, it would look a bit like this:\n\nOnce we've made the addExpression, we can create a hash of it, which\nwe'll pretend looks like \"abc123\" in hexadecimal. Then when we bind the\nname add to it, we can store it in the project:\n\nNow when we create add3, the following happens:\n\nWhen evaluating add 3, mimsa has looked in the project for something called\nadd, found it, and then saved that it is needed in this expression. Because\nwe refer to add by a hash of it's content, this is what makes it \"content\naddressed\".\nAssuming add3 has a hash of \"def456\", our project would look like this now:\n\nNow, when we come to update add and make it evil, we create the following:\n\nAssuming it has a hash of \"ghi789\", then the project looks like this:\n\nThe project has been updated, but note we haven't deleted any items from the\nstore. All that has been updated in the project is the binding for add.\nThis means any new uses of add will use the new broken\nfunction, but add3 is completely unaffected. If you did want add3 to adopt\nthe new terrible behaviour, it would be a case of binding it again, where it\nwould use the broken add function from the project.\nWhy would you do this?\nMaximum cachability\nBecause any of the expressions we can created don't change once created, they\ndon't need reparsing or typechecking (or transpiling to JS, etc) over and over. add will have the type\nInt -&gt; Int -&gt; Int forever, meaning that the idea of a slow build is kinda\nremoved.\nNo namespacing issues\nIn many languages conflicting names of packages or imports can cause issues. We\nmight want to use function A from package version 1.1 but function B from\npackage version 1.3. Most package managers won't let you do this (or they let\nit sort of happens sometimes, but weird stuff happens with globals interacting, I'm looking at you React). Expressions\nin a content-addressed language refer to each other by hashes rather than names,\nso function A and function B will have no idea about one another unless they\ndepend on one another somehow, and everything works great.\nGranular code sharing\nBecause of the above, the idea of the package as the unit of shared\nfunctionality is somewhat obselete. Unison Share\ndemonstrates what it could be like if we shared smaller units instead.\nTests don't need running over and over\nIf we test that add 1 3 == 4, and I know that add is not going to change,\nthen I can keep this test result around and don't need to run it again. When\nadd is rebound, we can make a copy of the test and run it on the new\nimplementation to see if the same test still passes. Property tests, it turns\nout, aren't quite so simple, but I'll come to that in a later post.\nDoesn't this mean that most developer tools that are built assuming programming means text files and diffs to said files are all unusable here?\nAhem.\nThat's all the words\nThat's some context of what content-addressed languages are, at least, my weird\nunderstanding of them anyway. The actual implementation in mimsa is more\ncomplicated than above (for instance, we store the raw AST rather than the\ntext syntax so we can change the syntax without breaking the expressions, and\nstore the history of name bindings rather than just the newest one) but\nhopefully it gives you a clue about what is going on under the hood.\nMake sense? If not, get in touch!\nFurther reading:\nUnison - the big idea\nmimsa\n","id":"https://danieljharvey.github.io/content-addressed-languages/","title":"What the hell is a content addressed language"},"https://danieljharvey.github.io/contract-testing/":{"body":"Hello. I hope you are well. Over the last few months I have been trying out a\nmethod for generating Contract Tests between services using Arbitrary\ninstances from Quickcheck which I thought it might be good to share. It's not particularly clever, which is\npartially what I like about it, and as a result I may not have been the first\nto come up with it. If I have therefore somewhat stolen your thunder please\naccept my apologies in advance and then maybe do some reading around SEO.\nWhat is Contract Testing anyway?\nContract Testing is a way of checking that two services that are going to\ncommunicate agree on what is going to be sent and received between the two.\nThere is a good intro to the concept on the Pact\nwebsite - which is itself a contract testing tool. It\nis a good tool - HOWEVER it takes a lot of work and I am lazy so there what I\nam going to describe is hopefully less work.\nFor example, a frontend says \"I am going to call /users/horse/1000 - is that cool?\"\nand the contract test confirms that the backend is indeed \"cool\" with that,\nshows what kind of thing it would return from that call, to which the frontend\nconfirms it is also \"cool\" with that.\n\nWhat is Quickcheck?\nQuickcheck is a Haskell library that does a thing called Property Testing. It has since been ported to many other languages. A nice intro lives here\nat School of\nHaskell - the tldr is that it lets us test properties about our programs by randomly generating examples and seeing if they fit rules that we define.\nSo, what is your so-called idea then?\nOK. So one of the main concepts behind QuickCheck is the Arbitrary typeclass.\nAny datatype with an instance of this typeclass is able to generate random\nexample values that can be used for testing.\n\nThis datatype Horse describes the two kinds of horse, BigHorse and SmallHorse. As is hopefully hand-wavingly evident, when the arbitrary function is run it returns one of BigHorse or SmallHorse.\n\nIf we can make one Horse, then surely we can make a load of them? Indeed!\nThis is what the instance for List look like - the Arbitrary a =&gt;\nconstraint means that if we can make any Arbitrary value, we can make a list\nof them.\n\nThe Quickcheck library defines instances for most basic types, as well as most\ncollections, therefore it is quite simple to build Arbitrary instances for\nour request and response datatypes - and that is exactly what we're going to\ndo.\nAn example\nLet's think about a nice simple API. It receives POST requests in JSON format that translate into a datatype that looks like this:\n\nAssuming that the requests are OK, it returns a response shaped like this\n(again, sent over the wire in JSON format).\n\nThese types are shown in Haskell, but the equivalent pair will also exist in\nthe frontend, and it's the compatibility between the two pairs that we will be checking.\nOur testing is going to work like this:\n\nOur frontend will generate 100 example APIRequest values\nEach one will be turned into JSON\nEach piece of JSON is saved into a file\nOur backend will decode each piece of JSON and see if it makes sense\nIf it does - great!\n\nThen, for responses, we do the same thing in reverse:\n\nOur backend will generate 100 example APIResponse values\nEach one will be turned into JSON\nEach piece of JSON is saved into a file\nOur frontend will decode each piece of JSON and see if it makes sense\nIf it does - great!\n\nEssentially, a contract between two services is a complete set of these for each endpoint. In this article I will explain the Haskell part of this, and will follow with the front end portion in the next one.\n\nCreating the sample responses\nWe're going to need to add some typeclass instances for our APIResponse type first, so let's change it to the following:\n\ngenericArbitrary is provided by the generic-arbitrary package which allows Arbitrary instances to be created for any datatype with a Generic instance. (For more intro on the idea of generics, the Hackage page is a good start.)\nToJSON is provided by Aeson, the excellent package for all dealings with JSON, and deserves a whole post of it's own. For our purposes, all we need to know is that for any datatype with a Generic instance, we can derive a free typeclass for turning it to and from JSON.\nThe special sauce for all of this action is the generate function from\nTest.QuickCheck.Gen, which generates any number of values for a given\nArbitrary instance. We use this with a bunch of other housekeeping functions to take these 100\nitems and turn them into 100 files. I have broken this down into a bunch of\nfunctions so that it's hopefully easier to follow.\nFirstly, a couple of helpers for adding index numbers to lists...\n\n...and creating a file path using said index...\n\nNext, we will make our functions for generating instances and saving them to\nfiles. This first function uses a Proxy (from\nData.Proxy)\nto pass the type we would like to generate (as such). We have chosen 100 as\nit is as good a number as any.\n\nThis next function takes our list of randomised values, turns them to JSON, and pops them in a Tuple along with an index.\n\nFinally, we put them together along with some glue code (using writeFile from\nData.ByteString.Lazy) to save the generated JSON files.\n\nTo use it with our datatype, we use a Proxy as such to pass it the type we\nwant (in our case, APIResponse, but the same code will work for any type with\nArbitrary and ToJSON instances)\n\nIf we crack this open in ghci we can run contractWriteAPIResponses \"sample\", and it will create files called 1.json, 2.json (up to 100.json) in the sample folder in the current working directory.\nOur frontend tests can now read these and make sure that they understand them.\nBut how do we make sure our backend understands the front end requests?\n\nReading the sample requests\nAssuming that our front end has also created some sample requests in a similar fashion, reading them and checking they are decodable is a simpler affair.\nGiven a path that points to a folder full of 100 json files, we can write code to attempt to read them. We are reusing the createPath function from above, but other than, this should do it.\nThis function takes a Proxy for our decoding type, a path and an index, and\ntries to decode the file it finds.\n\nHere we take a path to the folder full of files and attempt to read 100\nnumbered .json files in it.\n\nAnd here we put it all together using our APIRequest type.\n\nCracking open ghci and running contractRead \"sample\" will attempt to read 100 numbered .json files in the sample folder.\nDigression 1.\nNote we have used a Proxy type here to pass the type around. An alternative way to do this could be a mixture of TypeApplications and ScopedTypeVariables but in the spirit of #simplehaskell we'll avoid them.\nDigression 2.\nWhilst preaching simplicity, it seems enjoyably hypocritical to point out in\nthe same breath that we needn't have made a standalone instance of arbitrary\neach time, and it's actually a great opportunity to crack open DerivingVia.\nAn alternative method could looks something like this, and save up to 15\ncharacters per datatype.\n\nMake sense?\nNo. Thought not. Regardless, I'll follow up with how to great the front end\npart. I'll be using Typescript because quite frankly if you understand this\nthen doing it in Purescript isn't wildly different.\n","id":"https://danieljharvey.github.io/contract-testing/","title":"Contract testing with Quickcheck"},"https://danieljharvey.github.io/data-migrations/":{"body":"A few weeks ago I gave a talk at London Haskell that was basically an advert for a data migrating library I haven't even finished yet. However, I managed on the whole to hide this fact and some people even came up afterwards and asked me how the library was performing in production to which of course I said \"very well indeed, because of course i am very good at computers\" and quickly changed the subject.\nWhat follows is basically the crap from my slides, occasionally turned from bullet lists into sentences where I realised I had overused that particular presentation device a little much.\nSitting comfortable? Then we shall begin...\nIn The Beginning...\n...we had server side applications.\n\n\nIf the code agrees with the DB schema...\n\n\nDeploy!\n\n\nGreat!\n\n\nThen Came Javascript...\n\n\nSuddenly all our data was spread around the place\n\n\nThings didn't necessarily agree with one another\n\n\nThere was sometimes JQuery.\n\n\nAnd at some point we land at\nThe Traditional Backend / Frontend Monolith\n\n\nWhen the back end changes...\n\n\nChange the front end too.\n\n\nDeploy everything together\n\n\n(did you forget to update the DB schema?)\n\n\nDO THAT QUICKLY\n\n\nForget about the past\n\n\nYOLO\n\n\nSo...\nWhat could possibly go wrong with this?\n\nProblem One\nCompany A have found that DB schema changes make changing the application more difficult than they would like. Therefore they choose to use event sourcing. As the application changes, the DB schemas keep up, but they are soon left with an event table full of various historical versions of JSON data.\n\nWhat is this data? Do they still understand it?\n\nProblem Two\nCompany B decide their code is so good that they are going to create a public API. Other companies decide to use this API, and annoyingly want it not to change at random. Therefore the API owners make promises not to change their API (even though they bloody love changing their API because they are 10x hackers who just can't stop delivering business value).\n\nHow can they make changes to this without breaking everything?\n\nProblem Three\nCompany C have noticed that large monoliths take ages to deploy. They would also like to decouple teams to maximise parallelisation of work. They adopt a microservice architecture. Suddenly, services that talk to one another aren't guaranteed to have versions or interfaces that match, so a old service can be receiving requests from a very old service that hasn't been updated.\n\nHow will they cope with communicating with any number of historical deployments?\n\nA concrete example\nHere's a data type that we use in our business critical application. It is called OldUser, which we never really questioned at the time.\n\nBusiness is going pretty well, I can't imagine my meeting this afternoon will go badly...\nOh no!\n\nPivot immediately\nApparently we can increase profitability by 30% by using newtypes properly.\n\nAnd replacing String selections of pet types with a more restrictive sum type.\n\nThese changes took all night, but you really pulled through there.\n\nGreat job.\nHold On Though\nBusiness is obviously booming now, but what are we going to do about:\n\n\nThird parties that will insist on using OldUser in their API calls for the\nnext 18 months\n\n\nStored JSON data with the old data shape\n\n\nWhat options do we have?\n\nAs well as developing new code, we keep old code for dealing with the old data\n\n\nThis seems fine...\n...till you're fixing bugs in the old system too\nShit! More fixes! Now you're got an new-old system as well as the new-new one.\nMore fixes again! Now we have a new-old-new-old system to maintain as well as your main one, which is a new-new-new system by now? It may have been superceded too. Oh dear.\n\n\nOr migrate the old datatypes to the new datatypes and keep one set of logic.\n\n\nLogic stays in new code\nBug fixes in business logic happen once\nLogic of migration separated from business logic\n\nDecision time\nIf you choose Option 1, you are on your own. However, if you have chosen Option 2, read on...\n\nFunctions we will need: migrate\nThe first thing we'll need is a function to convert our old terrible datatype into our new incredible exciting datatype, in this case OldUser to NewUser.\n\nActually. Let's be realistic about this, and account for the idea that this operation could fail, as life is a bin.\n\nFunctions we will need: parse\nWe'll also need some functions for decoding JSON, as I have made the somewhat brazen assumption this is a REST API that only receives JSON payloads. We'll use functions from the Aeson library because it is reasonably ubiquitous.\nThis function will attempt converting some JSON into an OldUser\n\nAnd this very similar function will try and convert from JSON into a NewUser.\n\nPutting it together\nWe can then make a function that takes some JSON, and then tries to decode it into a NewUser. If it can't decode it into a NewUser, it tries to parse it into an OldUser, and if that succeeds, it uses some sort of migrate function to turn OldUser into a NewUser.\nSaid function looks something like this:\n\n(The &lt;|&gt; operator comes from the Alternative typeclass, and works sort of like the || function. The intuition is try this OR try this)\nDoes it scale though?\nIt seems to do the job, with a couple of datatypes, however it's easy to see how it could get out of hand...\n\nSo this method is a no?\nI don't think so. But writing all of that is a bit much. Hopefully right now you are asking \"Why can't I get the compiler to do this for me?\".\n\nGood Point.\nOK! Let's give it a smash. We start by making a typeclass and using it to version tag our datatype.\n\n(This VersionOf type here is an associated type family - a type level function that is scoped to only work inside the typeclass it is defined in.)\nThe typeclass defines a function we can use to find a datatype from the label and the num. For example, we can make a label called \"User\", and make OldUser version 1 of it:\n\nWe'll also define an instance for NewUser, and make that version 2 of it.\n\nLinking versions together\nNext we make a typeclass for migrations that uses our VersionOf type function:\n\nIt lets us define a function from the previous version of a datatype to the current one, so let's use it to migrate OldUser to NewUser.\n\nProblem: Migrating from old JSON versions\nOnce we've defined instances of the Versioned and Migratable typeclasses for our data, the Data.Migratable library functions start doing helpful things. It provides a version of migrate function we defined concretely earlier, but with a much more exciting (confusing) type signature.\n\nIt means \"I can take the earliest version of label and Maybe return you the target version of label\". We use type applications to pass versions and a label to convert an old datatype to a new one.\n\nGoing from version 1 to 2 means we've just done a shitload of work for a single conversion, but the same function will recursively convert through as many versions of the datatype as you like:\n\nSolution: parseJSONVia\nThe Data.Migratable library also provides us parseJSONVia, with the following exciting type signature:\n\nWe could use to try converting from both OldUser and NewUser like this:\n\nUnderneath, this is doing our parse and migrate pattern under thge good\n\nA note on Type Applications\nTo understand how to pass the types to the parseJSONVia function, we need to look at the Schema typeclass that provides this functionality:\n\nWhen we use it, we are passing it types in the order they appear in the class declaration.\n\nTherefore, we are passing the type-level symbol \"User\" as the first argument label, then a type-level natural number 1 as the starting version earliest, and finally another type-level natural 2 as the target version target.\nProblem: Uniqueness checking\nUniqueness checking is another feature of Data.Migratable. Let's say that we have this data type Info:\n\nThen, after another hard pivot, we change the units:\n\nIn our static typed ivory tower, we are fine, but our clients keep sending us\nthis:\n\nWhat is it? 100 pennies? 100 pounds? How can we stop this confusion?\nSolution: Checking for duplicates with QuickCheck\nData.Migratable provides us with the matchAll function:\n\n\n\nIt uses QuickCheck and it's Arbitrary instances to generate random JSON\nvalues for each datatype\n\n\nThen tries to load each generated value as each version of the datatype\n\n\nAnd tells us how many version of a datatype each generated instance is able\nto decode\n\n\nIf it's one each - we're going to have a good time:\n\n\n\n\nBut if our JSON representations are non-unique, we'll know:\n\n\n\nAnd we can fix our data types to ensure uniqueness.\n\n\n\nGood job.\n\nProblem: getting a FromJSON instance\nThe Aeson library works by making datatypes define instances of the FromJSON typeclass, and packages like Servant allow us to automagically create web servers that use these types. Can we still use all this good stuff?\nSolution: FromJSON instance around a newtype wrapper\n\n...and using parseJSONVia to create a FromJSON instance for that datatype...\n\n...we can make a Servant server that can read any of our historical datatypes.\n\nGreat job!\nProblem: Mistakes in our datatypes\nWhat if we make \"mistakes\" in our types - like removing a piece of data we later decide we need? Here is a first version of some data.\n\nThis is the second version of the datatype, where we remove age.\n\nOops. We needed that. It's back in version 3.\n\nHowever, this means any version 1 piece of data will convert through version 2 and lose everything on the way.\nSolution: multiple import paths\nLet's change our declarations...\n\n(We've ignored the middle one for now - it is the same)\n\nThen our parsing function becomes (something like)\n\nHow does it work?\n\n\nFirst, we try the lossless path\n\n\nFailing that, we try the lossy path to pick up any AgeLessDog values.\n\n\nOK. Sum up what you've said and stop selling me your crappy non-existent library\nSo hopefully, this technique should let you:\n\n\nDefine migrations outside the main logic code, throw those into a file and forget about them forever until the next migration.\n\n\nUse simple ADTs for my types if one feels like it.\n\n\nAvoid historical code making new code more complicated.\n\n\nBut does it work?\nWho knows? See the code at\nhttps://github.com/danieljharvey/migratable and decide for yourself. I mean, the tests pass, but what does that really tell us.\nAddendum\nAfter the talk, somebody suggested that it's all very well accepting old JSON data version in an API, but really you'd need to provide the response in the old format too. This was a really annoyingly good point, so this is the next feature I am working on for the library - the plan so far is to create a kind of opposite of the Migratable typeclass for responses, that goes from newer to older versions instead.\n","id":"https://danieljharvey.github.io/data-migrations/","title":"Mr Migration"},"https://danieljharvey.github.io/datatypes-either/":{"body":"It's one thing to understand typeclasses individually, but another to see them in context. This is the second in a series looking at some common datatypes and see how their instances of the main typeclasses act. We started with one of the simplest, Maybe, and now we move onto it's slightly more powerful cousin Either.\nOne thing or the other thing\nHere is the data definition for Either. We have used deriving to auto-generate instances of the Eq, Ord and Show typeclasses as we don't need anything special going on with them.\n\nWhilst Maybe only had one type parameter, a, Either has both a and b. If we use the Left constructor, it holds an a, or the Right constructor holds a b.\nHere, we are returning either a Left String with some harsh words, or a Right Int with a nice answer to an easy sum.\n\nFunctor\nNext we'll define a functor instance for Either. The important intuition here is that the function f that is provided will only be run on a value inside Right. Anything held in a Left will be returned untouched.\n\nThe Functor typeclass is only allowed to affect one type parameter, so anything held in a Left will be returned untouched, so if we want to run functions over that, we'll need...\nBifunctor\nThis instance allows us to map over the left, right or indeed both sides of a datatype. We define it with the bimap function which takes a function for each side.\n\nJust defining bimap also means we get the first function which just maps over the Left side, and the second function which just maps over the Right (so it's basically fmap with another name).\nApplicative\nThe applicative instance for Either has two functions, pure and &lt;*&gt; (also called ap). We use pure to define a default instance of the datatype, so we just take the value and wrap it in Right. The &lt;*&gt; function is used to apply a function inside a Right to a value wrapped in another Right. However, if we hit a Left we return the first one immediately and stop computing.\n\nSometimes, this behaviour is not what we want as we might want to collect together all of the Left values rather than just the first one found. For this there is a variation on Either called Validation, which we'll look at in future.\nMonad\nThe monad instance for Either provides us with &gt;&gt;= (or bind). The behaviour is much like the Applicative above or indeed the Monad instance for Maybe - as soon as an error is found (ie, a Left) we return that error value and shortcircuit the computation, as such.\n\nSemigroup\nThis semigroup instance for Either differs from the standard one in Data.Either as, like our Semigroup instance for Maybe it has a constraint allowing us to combine Semigroup values inside. I like this better, having nested Semigroup values all magically combining is very enjoyable to my mind.\n\nMonoid\nSadly, because Either has two type parameters rather than Maybe's one, we can't have a Monoid instance as we won't know which value to put in Left to represent nothingness. Oh well.\nFoldable\nIf we'd like to extract our value out of this Either context at some point we can use foldable. Note that we still provide a default a in the Left version of the function - the Left values might be a different type to the Right ones so there's no guarantee they'll be helpful in our fold, hence we still provide a default value.\n\nAlternative\nFor the same reasons that defining mempty is impossible for Monoid, we can't define Alternative for Either because it's just too messy. I'm sorry.\nMonadPlus\nAs I'm sure we all remember, MonadPlus is just Alternative with a more dynamic sounding name, so we don't get this one either.\nTraversable\nThe traversable instance for Either is very similar to Maybe. If traverse is run on a Left it wraps said Left and it's value inside whichever Applicative it is used with (the pure function coming from the other type rather than from Either). If we traverse a Right value then the provided function f is run on the Right values the same way in which they worked on Just. Note if we have several Left values, the shortcircuiting behaviour means we only get the first one back, shown here by using the sequence function (which is just traverse id, fact fans).\n\nIf you are ever trying to turn a List of Maybe values into a Maybe List, or indeed turn any pair of Applicatives inside out, then sequence is probably what you are looking for. It's magic, honestly.\nMonadFail\nIt turns out MonadFail is quite fussy about things, and so because the e in Either e a can be a String, but might not be, we can't define it. What a pain in the arse, all told.\nRight, right, right, right.\nAnyway, that's some things. Tldr; Either isn't too dissimilar to Maybe when everything is going well, and a bit different when errors start happening. Also, Either has way less instances than I thought, which was somewhat a relief I have to admit. I can't decide whether to do List or something jazzier like Reader next, but it'll be something like that. Please note these aren't the same definitions as you'll find in the Haskell Prelude, as I have tried to write them with an emphasis on clarity/simplicity (or indeed go completely off-piste with Semigroup.) By all means check out the originals on Hackage.\nIf having skim-read this post you find yourself with strong feelings about it (positive or otherwise) I'd appreciate you shouting them at my face via the usual channels. It's lonely down here in the soupy bottom of this old council bin.\nThat's all.\nFurther reading:\nData.Either\n","id":"https://danieljharvey.github.io/datatypes-either/","title":"Datatypes - Either"},"https://danieljharvey.github.io/datatypes-maybe/":{"body":"It's one thing to understand typeclasses individually, but another to see them in context. This is the first in a series where we'll look at some common datatypes and see how their instances of the main typeclasses act. We're starting with one of the simplest, Maybe, and I hope this will help you get a feel for the way it acts. The plan is to move onto Either, List and then Reader, Writer and State.\nIt Really Meant Nothing, Frank\nLet's start with a definition. We have used deriving to auto-generate instances of the Eq, Ord and Show typeclasses as we don't need anything special going on with them.\n\nAs is hopefully apparently, Maybe can either be a Just with an a wrapped inside, or Nothing which holds no value.\n\nFunctor\nNext we'll define a functor instance for Maybe. Essentially, if there is a value inside, let's run the provided function over it, and if not, return the same Nothing.\n\nApplicative\nThe applicative instance for Maybe has two functions, pure and &lt;*&gt; (also called ap). We use pure to define a default instance of the datatype, so we just take the value and wrap it in Just. The &lt;*&gt; function is used to apply a function inside a Just to a value wrapped in another Just. Therefore, if either of those are a Nothing, that's not going to work, so we return Nothing.\n\nMonad\nThe monad instance for Maybe has only one additional function, &gt;&gt;= (or bind). The most important thing in the Maybe case is that if we start with a Nothing, then we don't bother doing anything, allowing the computation to be shortcircuited, as such.\n\nSemigroup\nThe semigroup instance for Maybe is used to combine multiple Maybe values together. An important thing to note is the constraint Semigroup a - this means that for two Maybe values to be combined, the values inside must also have a semigroup instance, allowing them to be combined as well.\n\nMonoid\nNotice that when a Just is combined with a Nothing, we still get a Just value. This is because Nothing is our empty element, meaning that when it is combined to any value it does not change it. Defining this upgrades our semigroup instance into an exciting Monoid.\n\nFoldable\nNow carrying all these wrapped values around is great, but at some point we may want to extract values from these Maybe values, so we use foldable. Note the a in the Nothing version of the function - this makes the user of the typeclass provide a default value so that we don't end up without a value for Nothing.\n\nAlternative\nA good intuition for the Alternative typeclass is that it's a like the or operator ||. Therefore it can be used to return the first out of a list of values that is wrapped in Just.\n\nMonadPlus\nSince we're on a roll with defining typeclasses, let's plop in a quick instance of MonadPlus, which is basically Alternative with a different name, with mzero replacing empty and mplus replacing &lt;|&gt;.\n\nTraversable\nThe traversable instance for Maybe isn't too unusual, if traverse is run on a Nothing it wraps a Nothing inside whichever Applicative it is used with (the pure function coming from the other type rather than from Maybe). If we traverse a Just value then the provided function f is run on the value inside Just which wraps the a in an applicative functor, and we then use fmap to make the value inside a Just.\n\nMonadFail\nThe MonadFail typeclass hasn't come up before, but it's a very generic way of allowing all computations to fail in a similar way. The fail function has the type signature String -&gt; m a. However because we cannot carry around any values inside Nothing we simply discard the String and return Nothing. The usefulness of this typeclass will become much more apparent with Either and monad transformer stacks. (what? - we'll come to it...)\n\nJust \"a great job\"\nAnyway. This is quite a laborious post but I hope it is somewhat helpful. I intend to do similar ones for Either and List next. Please note these aren't the same definitions as you'll find in the Haskell Prelude, as I have tried to write them with an emphasis on clarity/simplicity. If you are a purist, or just bloody hate clarity, by all means check out the originals on Hackage.\nIf having skim-read this post you find yourself with strong feelings about it (positive or otherwise) I'd appreciate you shouting them at my face via the usual channels. It's lonely out here in the bleak abyss of South East London.\nThat's all.\nFurther reading:\nData.Maybe\n","id":"https://danieljharvey.github.io/datatypes-maybe/","title":"Datatypes - Maybe"},"https://danieljharvey.github.io/do-notation/":{"body":"Do notation is a strange thing. You first see it in examples of IO () with something like:\n\nAnd all seems well! This functional programming seems fine! But what's going on here?\nActually what's really going on here is\n\nOK. That's a little scarier. Quite a lot of weird arrows and stuff. What's this mean then?\nSo getStrLn is a function that returns an IO String, which means a string wrapped in the IO monad. With a bit of hand-waving, the &gt;&gt;= (bind) function runs it, unwraps the String inside and passes it into the anonymous function (the one starting with (\\firstName -&gt; ...)). This function runs it AGAIN and passes the unwrapped result into the next function. As you can see, the layers could get quite deep, hence the do notation which aims to make everything clearer.\nSo is do notation it just an IO thing?\nNo!\nHere's an example with Maybe. safeHead is a function that returns the first item of a list wrapped in a Just, which means that if there isn't a first item, instead of crapping out and ruining everything we return a Nothing which is easier to cope with.\n\nAnd here is a function that does it twice with do notation. Note not an IO () in sight!\n\nWhat does this do? Well it takes a list of lists, and returns the first value of the first list inside. Therefore there are two potential points of failure, that being, the entire input being an empty list, or the first list inside the main input being an empty list. Let's desugar it!\n\nThere is probably a shorter way to write this one to be fair.\n\nOK, so in this case, do notation doesn't look so great. Oh well. Remember: clever things are interesting but they're not always good.\nMake sense? If not, why not get in touch?\nFurther reading:\nDo Notation in Wikibooks\nA Fistful of Monads\n","id":"https://danieljharvey.github.io/do-notation/","title":"Why The Hell Should I Care About Do Notation?"},"https://danieljharvey.github.io/free-like-pizza/":{"body":"When I first started working at a Serious Software Place, I remember being very excited about the idea of testing things and dependency injection and purity and all such things. One day, I was spouting about this (presuming, I suppose, that everybody else was also so new to and thus enamoured with the topic), as well as these Functors I had been reading about, and one of the more senior engineers said, \"Well (raises eyebrows suggestively)...you're going to LOVE Free Monads!\".\nNow, many people that know me would agree I am a fairly jaded man, but I have to admit that even my interest was piqued. However, it's taken me absolutely fucking ages to work out what they are and how they relate to this original promise, and I think they do, just not how I thought.\nThe Intuition For Free Monads\nSo, the thing that took me the longest time to lose was this assumption I had made that a Free Monad was a wild monad, from the edges of abstract math. It's Ornette Coleman! It's John Zorn! It's a saxophone played with a hoover! It can do anything, at any time! Needless to say, this was a very exciting idea, so I set out to read about, framing everything I read with this wild (but admittedly very attractive) mis-assumption. Needless to say, I was very confused and wasted a lot of time that I could have spent doing fun things instead.\nThe reality is that the Free in Free Monad is not free like \"jazz\" or \"thinking\", but free as in \"pizza, at a tech meetup, knowing that of course the real price is listening through the following recruitment messages\". They are still very good, but (in my humble opinion, etc), not half as fun as I had originally promised myself they would be.\nWith this crushing piece of disappointment aside, let's look at what they actually are.\nDogs Disguised As People By Way Of Wearing A Coat And Hat\n\nLet's start with the idea of a Functor. If this is confusing to you I have written a vague explanation and so have much more competent people which are probably worth digesting before we go on.\nA functor is a data structure which contains some other data, and we can \"map over\" the data inside it to change that without fucking up the functor itself. For example, we can use the map function on a Maybe value, and it will change the a on a Just, and do nothing on Nothing.\n\nNow, there is already a Monad instance for Maybe, and this means we can use do notation and all sorts of great stuff with it, like this:\n\nLet's try them with the Product monoid (which multiplies its contents together when combined), to satisfy ourselves that this function does a thing that we vaguely like and approve of.\nThis fails as it should....\n\n...and this gives us an answer.\n\n(Isn't Monoid such a nice thing?)\nThat Didn't Mention Dogs Or Hats, What Gives?\nAhh shit, yes.\nSo.\nWhat if there isn't a Monad instance? Or we want to write programs like this, but don't want to commit to using Maybe? (or perhaps Maybe is TOO safe, and we want the option of throwing loads of exceptions instead). Could this be a job for...a Free Monad?\n(note for readers with subtext disabled in their browser: yes)\nOK. Let's make a datatype that's like Maybe, but isn't.\n\nLet's make an instance of Functor for it to prove there is no funny business at hand.\n\nMap the f function over an a if there is one, if not, do nothing. Good?\nStill No Dogs, What Gives?\nRight. In this example, MoybeF is our dog. It's a plain old functor that doesn't really do anything except contain an a inside Jost, or contain nothing at all inside Nothong. What Free does for us (and by that, I mean Free from Control.Monad.Free) is gives us a coat to wrap about this Functor to let us use it like a Monad.\n(In this tenuous analogy, the Monad represents a human adult, or at least some impression of one)\n\n(An aside: this metaphor felt a lot more powerful in my mind, but a cursory image search came up with a lot less than I had expected, and quite frankly this picture creeps me the fuck out).\n\nOK. So now, by use of the liftF functor from Control.Monad.Free, we can change any MoybeF value into a Moybe monad value instead. Let's define some helper functions that do this:\n\nNow, we can redefine our function from above to our our new exciting Moybe type too!\n\n(We could just have used liftF directly, and avoided the helpers, but this way hopefully we can see better how equivalent the two first' functions are)\nNow, let's remake our list smashing function from earlier using Moybe....\n\nHopefully, you can see it's pretty much the same. But how do we use it? If we run fFirstAndSecondCombine [] [], for instance, what we get back is a MoybeF again. So what the hell use is that? I went to all of this trouble to create a Monad (admittedly as cheaply as possible) - but it doesn't do anything!\nInterpreting The Computation\nSo what is MoybeF? Essentially, it's a data structure describing a monadic computation. Therefore, if we want to turn into something that does things, we need to interpret it.\nLet's turn it back into our original Maybe computation:\n\nAs you can see, we're just substituting Jost for Just and Nothong for the inferior Nothing.\nNow we can use our function to actually do things like before:\n\nI See That Once Again We're Doing Something Easy The Difficult Way\nOK, fair point. Where is the value in all this indirection?\nHow about if we want to interpret this computation differently? Perhaps we need to return an Either instead? Changing the interpreter is pretty straightforward:\n\nIs This...A Domain Specific Language?\nThat's right. One of the main strengths of Free is in creating small little sub-languages for writing logic, that can be interpreted in a number of different ways (such as \"what even is this doing?\" and \"i don't understand this code\")\nHow Does This Relate To Testing?\nSo, this example is pointedly very simple indeed, and involve swapping one pure thing for another, but a much more common use of this pattern is to take some code that does effectful things (like save files, write to a database, etc) and write them in a way where they can be run in the program using IO, but then testing by turning them into something pure like Writer, and looking at the output.\nDo You Have An Example Of Exactly That, Preferably Centered About Reading And Writing To A Terminal Window, Perchance?\nWhy yes, I do.\nSo ConsoleF is a Functor with two commands for input and output from a terminal.\n\nWe power it up into a Free Monad...\n\n...and then we write our helpers with liftF...\n\n...then we write our program with it...\n\n...then we interpret in IO to make a working program...\n\n...then we interpret it in Writer for testing...\n\n...run it...\n\n...and we go home for a nice sit down.\nIsn't This The Point Of Typeclasses?\nAye, some would say so. But what's the point of Haskell if there isn't 10 ways of doing the same thing, and endless bloody fights to the death about the minor differences between them?\nThat Is True, You Are So Right. Any Other Helpful Links?\nThe thing that finally made all this click for me was this video by Nate Faubion. Once I did understand it wasn't about jazz, this by Matt Parsons was really great too.\n","id":"https://danieljharvey.github.io/free-like-pizza/","title":"Free like pizza, not like jazz"},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"body":"So, confession, I love playing on the computer, but I'm terrible at SQL. I know that it's Good or whatever and there's this whole very sensible looking Relational Algebra behind it all, but like when I have to interact with it, I get the job done and then immediately wipe whatever I learned from my brain.\nEnough is enough. It's time to learn it properly. And what better way than to write an ANSI SQL database from scratch!\nDisclaimers etc\nSetting some expectations, this is very much a \"fun\" learning project, and we're gonna get a lot of things wrong. We'll be using Rust, because I write that a lot atm and so it's what my brain thinks in, but I would definitely not read this hoping for a Rust tutorial because I am almost as bad at Rust as SQL. I am going to describe things in a very hand-wavy way that will probably annoy people that know what they're talking about, but it's my blog and I can do what I want.\nSo, let's do it?\nOK. So what we're going to do in part 1 is:\n\nMake (steal) a SQL parser\nDo a table scan (From)\nFilter results from that table (Filter)\nChoose the fields we want to look at (Project)\n\nWe're going to be concentrating on the Query Engine part of the database initially,mostly because I'm more interested in it, so our tables are going to be static JSON files taken from the chinook dataset. We are using this because it's full of rock albums and it's nice to be reminder that Led Zeppelin are a totally sick band from time to time.\nOur types\nWe might not be implementing in Haskell but it's spirit lives on - let's start by defining the types of our query.\n\nA parser\nThis could quickly become a parsing tutorial and we don't want that, so we're going to use the sqlparser crate. It takes a string input and returns either it's own AST or an error. We'll pattern match on this and extract only the things we support into a Query type we defined above.\nNothing about this is very interesting, so I will just link to it. Know that we parse some SQL and make the types above.\nOur run_query function\nNow we've worked out what the user wants, we need to run the query. Initially we'll do this by matching on the Query type.\n\nWe'll fill these todo! out one by one now.\nQuery::From\nThe first thing we'll implement is a simple table scan. A table scan is \"get all of the rows in the table\". If you're thinking \"that doesn't sound wildly performant\", rest assured your Software Craftsperson spidey-sense is still working correctly. However, our tables only have ~300 items in them, so for now we'll live with it until we start thinking about indexes.\nHere is some code. Forgive me, Padre.\n\nLet's smash that into our run_query function:\n\nIt is not good code, but it is code. We'd test it, but it would still fail because of the other todo!. Oh well. Onwards.\nQuery::Filter\nCall me a staunch traditionalist, but often when I am accessing a database I do not wish to download all of it's data at once. We're going to allow users to filter data using a where clause, which lets us define properties about rows we are interested in.\nLet's recap on our Expr type:\n\nThis is pretty limited, but it does let us express select * from Album where album_id = 1.\nWe start by defining a function for deciding whether we care about a row. It takes a row (which we store as a serde_json::Value) and an Expr, returning a bool telling us to keep the row or throw it in the bin.\n\nLet's use it in our run_query function:\n\nWe'd test a query, but it'd still fail. But nearly!\nQuery::Project\nSo far we return every single field from our table scan, so every select is a select * from .... We can do better than that, let's implement Project, which is how we extract fields from rows. Eventually, we'll allowing renaming things with aliases, but that's quite boring and fiddly, so for now we're just supporting stuff like select Title, ArtistId from Album.\n\nThen we add it to run_query, completing it for now.\n\nBringing it together\nWe then add a basic CLI using clap, that takes a single argument --sql. Nothing surprising or interesting here, sorry.\n\nThis means we can run a query with cargo run --bin cli -- --sql 'select Title from Album where AlbumId = 48' | jq  and look what we get:\n\nNot bad, not bad at all.\nWhat's next?\nIf you've made it this far without being furious about my use of unwrap(), then in part two we're going to add some JOINS.\nMake sense? If not, get in touch!\n","id":"https://danieljharvey.github.io/fuck-it-lets-write-a-database/","title":"Let's write a database (part 1)"},"https://danieljharvey.github.io/getting-started-pt-1/":{"body":"I have not always found it clear how to get started with Haskell, and I have a small library I want to make as an experiment so I figured I'd document the process as a sort of Getting Started. The tiny library I wish to make is for reading environment variables, which can be used for database connections or similar. I use MacOS but will try not to make anything too platform specific, and link to docs where info for other systems can be found where possible.\nFirst, let's assume we have nothing Haskell-based on the system whatsoever, and start by installing Stack.\nOn MacOS this is as easy as running\n\nbut for other systems you will need to look at the Stack docs.\nAssuming that's all gone swimmingly, let's start a new project, which we will call simple-env.\n\nThis will create a new folder called simple-env containing the following:\n\nLooks great. There are two files here that describe our project... simple-env.cabal generated by Cabal, and package.yaml generated by Stack. Don't make the mistake I made and change the Cabal one directly - instead use package.yaml as the source of truth and allow Stack to auto-generate sensible .cabal files.\nHere is our default package.yaml file:\n\nIf you're familar with the Javascript world, this isn't a million miles away from a package.json file.\nWe aren't going to need any new libraries for our project, but it seems sensible to explain how that's done. Let's install contravariant package, because why not.\nLet's add it to here:\n\nso we have\n\nWe don't mind what version in this case - Stack will choose us a sensible one that fits with our other dependencies, that's what it's for.\nLet's run\n\nand watch the action.\nThe first time you run this on any given project, Stack will download the GHC compiler and all the libraries so you may wish to take a break and go and read War and Peace or something. After the initial wait subsequent builds will be very quick, but this one is a bit of a stinker.\nOk. Great, we have filled our hard drive with nonsense and we are ready to Haskell.\nWhat else have we got in this folder?\nFirstly, we have the app folder which contains one file, Main.hs. This is the entry-point to our application, and looks like this:\n\nWhen a Haskell program is run the main function in a module called Main is run, and then it is responsible for everything else that happens. Therefore we can deduce that this program is importing someFunc from somewhere and running that. Seems plausible. Let's run it and see what happens.\nIf we look back in package.yaml we have a section that looks like this:\n\nWhat it telling us? Well, a bunch of things, but two that stick out.\n\nFirstly, yes, our assumptions were correct - our main source directory is app and the main file is Main.hs.\nSecondly, that our executable file is called simple-env-exe\n\nLet's run it then!\n\nIt should just print \"someFunc\" to the screen and exit, which is admittedly quite underwhelming.\nWe can do better than this.\nSo it looks like someFunc is a function in src/Lib.hs. The whole file looks like this. Let's start work in here.\n\nOur library is going to extract environment variables so they can be used in programs. This is helpful for stuff like database credentials that we don't want to save in version control.\nHere is the MVP version:\n\nLet's take this apart a bit.\n\nFirstly, we have an import. We are using the lookupEnv function from System.Environment. If we look in the docs for it in Hackage we can see it has the following type signature:\n\nThis means we need to give it a String (the name of the environment variable we wish to check for) and it will return a Maybe String. This means if it CAN find a String it will return it, if not, it won't explode or anything, which is handy. However, that Maybe String is wrapped in an IO. What does this mean?\nIt means that this function needs to do interaction with the outside world, therefore it must also be run from another IO function using bind. Think of IO like the electricity that allows access to side-effects and the outside world. It's where the problems are most likely to come from, so Haskell forces us to be very explicit about where it is and more importantly, where it isn't. Our main functions have access to IO, and they must pass the IO-ness to wherever else needs it.\nOpinionated note: IO is one of the more complicated parts of Haskell, and it's somewhat unfortunate for adoption of the language that we have to deal with it in the first lines of any program. I would wager that this is why so many tutorials and books start with hacking in the ghci repl instead, as it saves having to have The IO Chat. I am a firm believer in uncomfortable truths, moreso if they are explained terribly like this, but if you are starting out, feel utterly free just to accept this part is a bit weird, learn to live with it, and come back to in depth later. The IO concept really is quite a good thing, it just presents something of a Learning Kerb.\nWe also have a helper function called showResult.\n\nThis function just takes our Maybe String and turns it into a String ready for us to print to the console. It uses pattern matching of the maybeValue to display either the result (value) that the environment variable was set to, or a fallback message. Therefore we should get:\n\nPretty OK, huh?\nOK, lastly the glue function, someFunc.\n\nWhat's the deal here? Ok. So firstly, the Do - it says that we're starting some Do notation which allows us to write in a slightly more imperative style. Like the IO concept in general it's a bit of a heavy concept to throw at beginners in the first few lines so let's also make a mental note to just nod and come back to the concept later. Again, it is a pretty neat thing, but confusing to start with.\nMoving on, this line is more interesting:\n\nSo as discussed earlier, our lookupEnv takes a String (in this case \"TEST_VALUE\") and returns Maybe String wrapped in IO. This &lt;- pulls it out of the IO so that in effect, this line is setting testValue to Maybe String. If lookupEnv finds an environment variable called \"TEST_VALUE\" then testValue will be Just \"whatever_the_value_was\", but if it fails, it'll be Nothing. Note that we were only able to even use the lookupEnv function because someFunc is also an IO function, so in effect we have passed the IO power along to lookupEnv to let it do it's magic.\nGreat stuff. We have done a thing. Now let's tell our wonderful user all about it.\n\nOK. So this line just takes testValue (a Maybe String), uses showResult to turn it into a nice String that tells us what happened, and then uses putStrLn (put string line) to show it on the screen. putStrLn is another IO action, with this type signature:\n\nThis means it takes a String, and then returns () (unit, the nothing value) inside an IO. Again, it must be run inside another IO context to get it's \"power\", as such. Also, the fact it returns () is helpful - our someFunc is of type IO () meaning it should also return nothing, so putStrLn is also doing that for us. Tidy.\nGreat stuff.\nLet's try our program.\n\nAssuming you've not got an environment variable called \"TEST_VALUE\" set you should see:\n\nLet's set one (assuming you're in Bash or Zsh):\n\n...and run the program again.\n\nGreat stuff. It's not much of a library, but it's a start. Next time we'll make a nicer API for fetching multiple variables at once so it's actually a bit more helpful for our users.\nMake sense? If not, why not get in touch?\nFurther reading:\nThe Haskell Stack Tool\nSystem.Environment\nIntro to IO\nSystem.IO\nLearn You A Haskell: IO\n","id":"https://danieljharvey.github.io/getting-started-pt-1/","title":"My First Haskell Project - Part 1"},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"body":"Hello, hello, hello. Welcome to part two of this adventure where we're making a database by hand. In part one we stole a SQL parser, did some table scans, filtered some results, and projected the ones we're interested in. I promised we'd look at joins today, but first we need to do a bit of housekeeping.\nIf you'd like to look at the code, it's right here.\nStoring our rows better\nPreviously we passed our rows around as Vec&lt;serde_json::Value&gt; so each row was a JSON value that looked like this:\n\nThis is poor for two reasons:\n\n\nHaving the column names in every row is wasteful\n\n\nIf we want to rename columns (or disambiguate the \"name\" column from two tables that have been joined), we have to change every row\n\n\nInstead we have a Row type that contains a Vec full of individual serde_json::Value types for each column entry:\n\nAnd we pass around a single Schema type that holds all the column names:\n\nChanges to our query functions\nPreviously we just returned a big pile of rows from each query function, but now each one returns a QueryStep type:\n\nNow we have a bunch of rows, and a Schema so we know what's in them.\nFrom\nWhen selecting fields, we grab all the rows, and then return a schema too. These are hardcoded for now:\n\nFiltering\nFor instance, this means our filtering now looks like this, passing the schema through unchanged from whatever Query it wraps:\n\nProjections\nOur projections let us drop and reorder fields, so they'll change the schemas as well as the rows:\n\nAs well as a project_fields function we have a matching project_schema function that creates a new schema.\n\nOutputting everything\nWe still want to output everything in JSON as before, so our QueryStep has a to_json function that puts everything back as it was before.\n\nAfter this, all the outputs look the same as before and our tests all pass again. Nice!\nWhat's next?\nOK, we've got all our ducks in a row, next time we'll do the joins, I promise.\nMake sense? If not, get in touch!\n","id":"https://danieljharvey.github.io/lets-write-a-database-part-2/","title":"Let's write a database (part 2)"},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"body":"Well, well, well, if it isn't part 3. Last time we tidied up a bit so that we're ready to tackle joins. As ever, all the code lives right here.\nWhat is a join then?\nSay we have a table of Albums that looks something like:\n\n...and another table full of Artists like:\n\nA join is what lets us look up the artist name for a given album.\n\nWill return something like:\n\nWhat makes it a 'join' is that for each row on the left hand side we attach the rows from the right hand table where the join condition (here, Albums.artistId = Artists.artistId). Where one row matches from each side like this, it's all very neat.\n\nNow, each artist may have zero or more albums, so our result will look like\n\nBecause The Beatles have multiple albums, we make a copy of each left hand side for each right hand side. What about our old friend Johnny Noalbums though? He has no matching albums, but we still include the left hand side. If we didn't want to include him though, we could use an inner join instead:\n\nHere we'd only include items where there is a match on both sides, so our result would look like:\n\nThere are a bunch of other kinds of joins too, but we'll stick with these two for now.\nImplementing the joins\nWe'll be using the classic hash join to join our tables.\nSo in our Artists -&gt; Albums join, we start by creating a HashMap and adding an empty array for each artistId found in the Artists table (as artistId is the column we are joining on). It should look like:\n\nThen we go through the Albums table, and for every row with an artistId, add the entire row's values under the key in the HashMap. Our HashMap should now look like:\n\nThe final step is to put everything together. For each row in the Artist table, we:\n\n\nLook up the artistId in the HashMap.\n\n\nFor each entry we find, output a new row combining the Artist row with the Album entry from the HashMap.\n\n\nif we don't find any entries, then\n\n\n\n\nfor left outer join, emit a new row containing the Artist row columns only, with null for any other columns in Album.\n\n\nfor inner join, don't emit a row.\n\n\nIn code\nWe have a new Query::Join item.\n\nWe deal with these in run_query as follows:\n\nHere is the hash_join function:\n\nIs that it?\nWell yeah, sorta. We only handle two kinds of joins here, left outer and inner, and so there's a bunch more we can do here. Really with joins the trick is optimising them right - ideally we want the smaller table on the left hand side, for instance. We'll get to that once we start implementing some optimisations.\nWhat's next?\nHaven't really decided yet actually. Perhaps some nice optimisations? Let's see what takes our fancy.\nMake sense? If not, get in touch!\n","id":"https://danieljharvey.github.io/lets-write-a-database-part-3/","title":"Let's write a database (part 3)"},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"body":"Recently I thought it would be good to start compiling the small functional\nlanguage mimsa I've been messing\naround with for the last few years to LLVM. There's a few really helpful\nresources - Joseph Morag's Micro-C\nseries, and Mapping High Level Concepts to LLVM\nIR in\nparticular, but neither go into converting functional programming paradigms\nsuch as pattern matching, lambdas and ADTs in much depth.\nSo, here we're going to give it a go. The plan is that we start with an\nentirely working but tiny language, get it all working, and then as we add\nfeatures to the language, we'll also add a typechecker and introduce more LLVM\nconcepts. The source code for the whole working calculator, along with a basic repl, can be found\nat llvm-calc.\nOur language\nThe first iteration of our language is going to be the most basic of\ncalculators. Here is a valid program in our language:\n\nHere are the datatypes for our language. We will use this to represent our\nprograms internally.\n\nHere's some example values:\n\nWe call datatypes like Expr Abstract Syntax Trees (or ASTs).\nYou may notice the ann type variable. We'll use this to \"decorate\" items in\nour AST. For now, we'll just use ().\nParsing text into AST terms\nAlthough we could provide our compiler as a Haskell library and ask our users\nto manually create Expr values for us, it'd be much nicer to be able to read\ninput from a user.\nThis process is called parsing, and looks something like this:\n\nGiven some user input, parsing returns either a valid Expr or a (hopefully)\nhelpful error.\nThe whole parser can be seen\nhere. We'll not go into too much depth as there are already lots of great references\non parsing, but a few details are worth noting:\nWhich library?\nWe'll be using a library called\nmegaparsec. It's fast, it's got a great\ntutorial, and it generates errors that we can render nicely with the diagnose library.\n\nDealing with whitespace\nAlthough some languages make whitespace meaningful, we won't be bothering with\nany of that for now. However we would like to allow our users some flexibility\nwith how they lay out their code. 1+1 and   1    + 1 should mean the same thing. That means we either need a lot of code like this:\n\n...or we need a neat way of automating this. megaparsec has a handy thing\ncalled a lexeme. This is a sort of rule that says\n\"when eating this value, also eat all the whitespace before it\". When you see\nmyLexeme in the code, this means we're wrapping a parser with\nwhitespace-eating powers. This is\ncovered in much better detail in the\nmegaparsec tutorial.\nParsing infixes\nOne problem with parser combinator libraries is that it's easy to get into an\ninfinite loop. megaparsec has a bunch of useful helpers for this, in\nparticular, support for Operator.\n\nA nice part of the the above code is that by putting * in a group before +\nand -, we have defined operator precidence and so 6 * 1 + 1 equals 7 rather\nthan 12 (which we'd get from 6 * (1 + 1)).\nSource code location\nYou may have noticed the ann type variable in our Expr type. This allows us\nto \"decorate\" our AST nodes. In parsing, it's useful to decorate each node with\nit's location in the code.\nWe use the following datatype for this:\n\nThe two Int values are \"character number we start at\" and \"length of the\nstring\". Therefore parsing \" 100\" should return:\n\nWe won't be using these values today as our language is so limited that it's\npretty difficult to break, but as we add multiple types (and thus, the\npossibility of type errors) we'll use them to show the user where they did a\nboo boo.\nA simple interpreter\nBefore we get stuck into LLVM, it's good to be able to evaluate our language\ninternally. Although it's pretty clear how this calculator should work, it\nwill be useful to compare our own simple interpreter with the LLVM output as\nthings get more complicated.\nYou can view the full code\nhere.\nAs you can see, there isn't very much of it:\n\nWhen we see an EInfix value, we look for EPrim values inside and add / subtract / multiply them. If they're\nnot EPrim values yet, then they must be nested expressions, so we interpret them\nand try again.\n\nEnough nonsense, let's do some compiling\nHopefully we understand what our small language is now, so let's get down to\nthe business of turning it into real life native code.\nWhat is LLVM\nLLVM stands for Low Level Virtual Machine. The idea is that higher level languages compile into LLVM, and then LLVM is turned into whatever local version of assembly is required. This means that by using LLVM, your programs will work on lots of architectures without you needing to understand a tremendous amount about them. As somebody who understands pretty much nothing about any processor architecture, this is very appealing indeed. If you need further persuading, Rust, Swift and GHC can all compile to\nLLVM.\nLLVM is part of the clang C compiler, and as a result, it's very C shaped.\nIt's got a bunch of number types, structs, and arrays, functions, and enough pointers to have a\nvery bad time.\nOur \"runtime\"\nIn order to do things our language will need a runtime, This is a bunch of helper code written in something that be compiled to the target\nlanguage. Because we'll be compiling using clang, we'll use C. I don't know much about C, but what I can tell you is that this file contains a single function called printint, that takes an int and prints\nit to stdout.\n\nThis is the only C you'll need to see today. I'm sorry about that. Onwards!\nOur first LLVM module\nLLVM is organised in modules.\nTo start us off, here is the IR (Intermediate Representation) for printing the number 42 to stdout.\n\nLet's take this apart line by line:\n\n\nThis is a comment. See, LLVM is easy.\n\n\nThis declares an external function we'd like to use. In this case it's the\nprintint function from our standard library defined above. It\ntakes a single argument, an i32, and returns an i32.\n\n\nThis defines a function called main that takes no arguments and returns a\nsingle i32.\nThe ccc part is the \"calling convention\". This defines the manner in which\nLLVM will generate the function code. There are absolutely loads of these, many\ndesigns to optimise specific languages. We'll keep to ccc for now, but may\nwant to change our minds when we start doing tail calls.\n\n\nThis line of defines a variable %1, and sets it the result of calling the\nprintint function we imported above. We pass the printint function a single\nargument, an i32 value of 42. This will print the number 42 to stdout.\n\n\nFunctions in LLVM must return something (although that thing can be null).\nThis line returns an i32 value of 0. Because this is the main function of\nour program, this is what will be returned to the operating system as our exit\ncode. 0 means \"great job, everything went fine\".\n\n\nThis is a closing curly brace. LLVM is like C, we have to specifically\nend our functions. No great hardship though.\n\nCompiling and running our hand-baked module\nTo check that the code above does what we say it does, and to check we've got\neverything installed that we need, let's write the LLVM to a file called\nmodule.ll, the C code to runtime.c, and then compile it using clang.\n\nThis should output an executable called a.out. If we run it, we should see\nthis:\n\nHooray!\nCompiling our programming language to LLVM\nOK. So now we've had a taste of the raw power available to us, let's get down\nto business. Although we could just create raw LLVM IR by hand, instead we will use the following\nlibraries:\nllvm-hs-pure - a set of\ntypes for LLVM IR, along with some helpful building functions.\nllvm-hs-pretty - a\nprettyprinter for llvm-hs-pure.\nWe'll use the datatypes in llvm-hs-pure to create modules, then use llvm-hs-pretty to render these to files and then compile by hand. This means that when we\ninvariably generate LLVM errors, we'll at least we able to look at the error\nand reference the code we've given it to try and work out what went wrong.\nShut up and show me some Haskell code\nThe whole module can be seen\nhere, but let's look at the highlights:\n\n\nThis function creates integer literals from our EPrim constructors, using\nthe int32 function.\nThis returns an Operand (an LLVM value, broadly) that we can pass to other LLVM functions. We'll\nexpand this function to include more types as we need them.\n\n\nHere we compile our Expr into and take care of adding /\nsubtracting / multiplying integers.\nBecause we're using the MonadIRBuilder\nand MonadModuleBuilder, it's almost as if we're writing code to do the\ninterpreting by hand, as all the actual code output is plumbed away in the\nmonad. If you squint, it looks very similar to the interpreter we wrote earlier, so if you\nunderstand that, you pretty much understand this.\n\n\nFinally, we wrap up our compiled Expr and turn it into a\nmodule. We are going to import printint from our standard library, output the\nresponse of our computation to stdout, and then return exit code 0.\nLet's look at the generated LLVM for 6 * 8 - 3:\n\nHopefully, nothing too surprising.\nRunning our code\nAs with earlier, our little compiler works by pretty printing the LLVM module\nwe created, then running clang to compile it into an executable. I pretty\nmuch stole the compiling code from\nMicro-C (thanks/sorry, Joseph!).\nYou can see our slightly tattered version\nhere if for some reason you don't believe any of this actually works.\nWell that's that\nCongratulations, you are all low-level compiler experts now. Hopefully that was\nsomewhat helpful. Next time we'll be adding the equality operator and some basic control flow.\nExciting!\nMake sense? If not, get in touch!\nFurther reading:\nllvm reference\nllvm-calc\n","id":"https://danieljharvey.github.io/llvm-compiler-part-1/","title":"Compiling a functional language to LLVM, part 1"},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"body":"Welcome to part 2 of this series in compiling functional languages to LLVM. In\npart 1 we created a very simple\ncalculator that let us add, subtract and multiply integers like 1 + 1 or 6 * (5 - 2).\nToday we're going to spice things up a touch by adding some basic control flow.\nBy the end of today we're going to be writing sweet syntax such as:\n\nWhat's new then?\nTo make our dreams come true, we're going to two new\nsyntactic features:\n\n\nif expressions\n\n\nan == infix operator\n\n\nLet's do that now!\n\nOur EIf constructor takes three Expr ann as arguments. The first is the\npredicate, ie, the thing that must evaluate to True or False, and the\nother two are expressions to be evaluated on the then and else branches.\nFor all of this to make any sense, these will need to be the same type.\nTypes?\nPreviously we sort of glossed over the idea of types, because every value in\nour calculator was either an Integer (ie, 1, 42) or an expression that would eventually\nevaluate into an Integer (like 1 + 1, 6 * 12).\nHowever, the expression 1 == 1 doesn't resolve to an Integer, it can only\nbe True or False, ie a Boolean type. (it is true that we could express\nthis with an Integer but if we start cutting corners this early in the game\nwe'll never get anywhere). This means we'll need to extend our Prim type to also describe Boolean values as\nwell as Integers.\n\nHowever this means we are in danger of our users being able to make silly mistakes like if 27 then False else 6? How can we stop this? This can only mean one thing: we are going to need\nto write a bidirectional type checker.\nBidirect what?\nA bidirectional type checker is a way of working which types parts of an\nexpression has, and identifying parts that don't make sense. What makes it\n\"bidirectional\" is that it works in two \"modes\":\n\ninfer mode: given an expression, give me the type\ncheck mode: given an expression and the type we think it has, give me the\ntype\n\nThe broad idea is when we don't know anything about an expression, we infer\nwhat types it has, but as we learn more, we use that information to help us\nwork the rest out. Although we could arguably get away with just an infer mode for a language\nthis simple, we will need this special two-way magic in future.\nEnough waffle, let's see some code, and then talk about it.\nCode\nFirstly, we need a type for types. We'll call it Type. We are adding an ann\ntype argument to it, so that we can attach source code locations etc. This will\nbe helpful for showing our user helpful errors, which we will be doing today:\n\nThings go wrong\nAny old typechecker can tell you when things are going well, but the ones that\nare really worth their salt are the ones that tell you helpfully what is going\nwrong. We will need these ones:\n\nThe meat of the thing\nTherefore, the point of the typechecker is to take Expr ann (ie, an Expr\ncarrying around some ann that does not concern us), and turn it into either\nTypeError ann or Expr (Type ann).\nExpr (Type ann) means that we'll have \"decorated\" each part of the Expr\nwith it's type. We'll take whatever ann was in there and put it in the Type\ninstead. For example:\n\nThe entire typechecker lives\nhere.\nLet's go through the key parts:\n\n\nelaborate is the function the typechecker exports. It takes an untypechecked\nExpr ann and returns either Expr (Type ann) or an excuse. It starts by\nrunning infer, which we'll see shortly.\n\n\nThe most basic type inference we can do is looking at a primitive value. As it\nstands in our language, there is one number type and one boolean type, so we\ncan unambiguously work out the type just by looking at the value.\n\n\nThis is how if works. We infer the type of the predicate, then use\ngetOuterAnnotation to get the Type ann out of it. We then case match on it\nto see if it's a Boolean or not, \"throwing\" an error if not.\n\n\nWhen typechecking ==, we want to make sure both sides have the same type,\n\"throwing\" an error if not.\n\n\nHere are the other operators. Both the arguments should be Integer and the\nreturn type is Integer, otherwise we construct and return an error type. It\nseems like a lot of work to be so specific, but look how helpful our errors\nare!\n\n\n\n\n\n\n\n\n\nYou can see all the error rendering code\nhere.\n\n\nThat's how we put infer together, easy!\n\n\nLastly, here's check. We only use it when comparing arms of if statements,\nbut soon this will become more interesting.\nYou can see all of the typechecker code\nhere.\n\nInterpreting our new friends\nBefore heading back into LLVM land, let's update our manual interpreter so we\ncan understand what's needed here.\nFirstly, it's now possible that our interpreter can fail. This will only happen\nif our typechecker is not working as expected, but we should make a proper\nerror type for it anyway because we are good programmers who care about our\nusers.\n\nInterpreting infix expressions is a little bit more complicated, as our pattern\nmatches have to make sure we're looking at the right Prim values. The\neagle-eyed may notice that a broken typechecker could send this into a loop.\nCan you see where?\n\nWe ended up with a MonadError constraint above - why's that? It's because the\nmain interpret function can now \"explode\" if we try and match a non-predicate\nin an if statement. Our typechecker should stop this happening of course.\n\nWe interpret if statements by reducing the predicate down to a boolean, then\ntaking a peek, and then interpreting the appropriate branch. If we don't need a\nbranch, there's no need to interpret it!\nYou can see all of the interpreter code\nhere.\nOK, LLVM time\nI feel like I'm rushing through all this, and maybe copy pasta-ing an entire\ntypechecker in the preamble was somewhat undisclined of me.\nBUT, here we go.\nDigression\nFirstly, we'll add a new function to our C \"standard library\":\n\nIt will take an LLVM boolean, and print either True or False depending on\nwhether it is 0 or not.\nTo the IR!\nWe're going to start by looking at the LLVM IR for the following arbitrary\nexpression:\n\n\nWhat a ride! Let's take it line by line.\n\n\nOnce again, let's ease ourselves in with a code comment.\n\n\nDeclaration for the new function in our standard library. It takes an i1 (a\nboolean, stored as 0 or 1) and returns void.\n\n\nWe define the main function, which is the entry point of our program. It\ntakes no arguments, and returns an i32 integer value (which becomes the exit\ncode).\n\n\nHere we are making a new variable, %1, by comparing two integers, 2 and\n1, using eq. This is our 2 == 1 expression, and maps across quite neatly.\n\n\nTo make control flow works, we are going to need to jump to different places.\nHowever, LLVM has no way of passing a value back between sections. Therefore,\nwe are going to create a mutable placeholder for the result, and each branch\nwill be responsible for storing the result here. alloca is broadly \"allocate\nmemory\" and i1 is the LLVM type for a Boolean.\n\n\nThis is where we do the branching. br takes an i1 value for the predicate,\nand then two labels for blocks that we'll jump to depending on the value of the predicate.\nTherefore if %1 is 1 we'll jump to then_0, otherwise we'll jump to\nelse_0. We'll define these shortly.\n\n\nThis defines a block labelled then_0. We will \"jump\" here in the \"then\" case\nof the if statement. We store 1 in the %2 variable, and then jump to the\ndone_0 block.\n\n\nThis defines a block labelled else_0. We will \"jump\" here in the \"else\" case.\nOnce again, we store 0 in the %2 variable, and then jump to done_0.\n\n\nThis introduces a new block called done_0. As our if construct is an\nexpression, we always need to return something, so ee jump here when the\nthen or expr branches are finishing doing their business, and load whatever\nthey stored in %2.\n\n\nCall the printbool function from our standard library with the loaded value.\n\n\nAs our program succeeded, we return a 0, this becomes our exit code.\n\n\nAs a little palette cleanser, a nice closing brace.\nGenerating it from Haskell\nNow we have Boolean as well as Integer values, we'll need to represent them\nin LLVM. We'll use a bit which is a 1-bit LLVM number to represent\nBooleans.\n\nNow we'll need to choose the right printing function:\n\nThe most interesting part is if expressions. We use the RecursiveDo\nextension, which gives us the mdo syntax. This lets us use bindings before\nthey are created. This will allow us to use thenBlock and elseBlock before\nthey're defined. We create IR for the predExpr, then pass it to\nLLVM.condBr, which will then jump to the appropriate block depending on the\nvalue.\n\nTo work out which kind of type to alloca, we take the return type and use it\nto work which LLVM type to use.\n\nYou can see all of the LLVM conversion code\nhere.\n\nWell that's that\nCongratulations, you are all bidirectional type checking experts now. Hopefully that was\nsomewhat helpful. Next time we'll be adding basic functions and variables.\nGreat!\nMake sense? If not, get in touch!\nFurther reading:\nllvm reference\nllvm-calc\n","id":"https://danieljharvey.github.io/llvm-compiler-part-2/","title":"Compiling a functional language to LLVM, part 2"},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"body":"Welcome to part 3 of this series in compiling functional languages to LLVM. In\npart 2 we added basic control\nflow to our langauge with an if / then / else construct.\nToday we're going to get one important step towards a functional programming\nlanguage by adding functions and variables.\nBy the end of today we'll be able to make small modules such as:\n\nHowever, there are quite a few things our functions won't do.\n\nThey can't call themselves recursively (ie, function factorial(a: Integer) { if a == 0 then 1 else a * factorial(a - 1) }. This is to simplify the typechecker\nimplementation for the time being rather than any limitation in LLVM - we'll come back round to making this\npossible.\nWe must define all function arguments up front (ie, a: Integer, b: Boolean). It is possible to infer these, but let's keep things simple for\nnow.\nFunctions can only call functions defined before them. This can be solved by\ndoing some dependency analysis before typechecking (ie, move things around to\ntypecheck them in a sensible order). We avoid this for now, but will come\nback to it.\nFunctions can't return other functions, they can only be defined at the top\nlevel. This is a limitation of LLVM, however in future chapters we'll work around this by\nimplementing closures.\n\nOK, lets get concrete\nWe're going to need some new datatypes to express all the new things we want to\ndo.\nFunction\nFirstly, we have a Function type.\n\nThis lets us describe something like:\n\nNote that the function body is a single Expr, and that it can use variables\na and b introduced as function arguments.\nThe ann type will contain file location information\nafter parsing, and then will contain the type of the function after\ntypechecking.\nOur function implementation is very limited - we can only\nuse variables passed into the function as arguments, and must explicitly\nannotate each function argument with it's type.\nModule\nA Module lets us combine multiple functions and a main expression.\n\nThis lets us write code like:\n\nAs mentioned earlier, functions can only be used in the order\nthey are defined. Therefore decrement could call increment, but not the\nother way round. We can improve this in future with some basic dependency\nanalysis.\nExpr\nOur Expr needs a couple of new constructors.\n\nEVar represents a variable such as a, and EApply represents function application (add(1,2)).\n\nTypechecker changes\nAfter a rather sizable swerve into bidirectional typechecking in the previous\npart, we are going to focus less on the changes here.\nAdding state\nThe most important part is that it's become stateful, as we will be learning\nabout both functions and variables as we typecheck. We have created a\nTypecheckM newtype that we use, that contains both a ReaderT and a\nStateT.\n\nThe reasons for separate Reader and State are the nature of the state in\nthem. Variables only live for the life of a function that are defined in, so\nthey live in the TypecheckEnv used by Reader, and disappear after the\nfunction definition is typechecked (more information on this technique\nhere).\nThe trick is using the local function from Control.Monad.Reader:\n\nWe pass in some args, which are the function arguments and their types, and\ncomputation, which is whatever typechecking we'd like do. Then throughout\nrunning computation, we'll have extra variables in scope, and then they'll\ndisappear again. This is helpful for typechecking functions, where the vars\nonly exist inside.\nInference changes\nWe have two new infer cases, EVar and EApply. EVar is pretty\nstraightforward:\n\nWe lookup the type for var, and decorate the type with it. If lookupVar\nfails, it \"throws\" a TypeError ann.\n\nThe other new infer case is EApply. This is used to get the type of an\napplied function.\n\nNote how we use check here to check each argument against the expected type in the\nfunction. This is where the bidirectional type checking approach really starts\nto shine, as any problems become immediately apparent.\nThe lookupFunction helper is very similar to lookupVar, except it looks in\nthe State instead of Reader:\n\nThese types, and the functions used to store / fetch variables and functions\nare defined\nhere.\nElaborating a function\nOur functions have types for the arguments, so we push them into the Reader\nenvironment, and then elaborate the expression inside.\n\nWe've extended the Type datatype to add a TFunction constructor, which\ncontains the types of all the arguments, and the return type. All functions\nwill have a TFunction type.\n\nElaborating a module\nElaborating a module involves:\n\nElaborate each function\nPush it's type into the State\nElaborate the main expression\n\n\n\nUpdating the interpreter\nWe won't go into the interpreter changes today, they work in the same way as\nthe typechecker,\nstoring variables in the Reader env and functions in the State. The code\nlives\nhere.\nTo the IR!\nHere is an expression:\n\nHere is the LLVN output for it. Hopefully it's not too brutal.\n\n\nA comment, lol.\n\n\nWe define our output function from our standard library.\n\n\nDefine the function. The first i32 is the return type. %a_0 is the first\nargument with type i32, and %b_0 is the second argument, with type i32.\n\n\nBody of the sum function, add %a_0 and %b_0 and assign the result to\n%1.\n\n\nReturn %1 from the function.\n\nEnd of sum function.\n\n\nThis defines the main function, the entry point to our application.\n\n\nBody of the main function - this calls the sum function, passing it 20\namd 22 as args. The result is stored in %1.\n\n\nPass the result (%1) to the printint function in our standard library.\n\n\nReturn the value 0 to show the program successfully completed.\n\n\nNice closing bracket. Time for a rest.\n\n\nGenerating IR from Haskell\nAdding functions and variables means that our IR generation also becomes\nstateful. We're going to define a couple more types:\n\nIt also means something can go wrong:\n\nBoth these errors shouldn't happen if the typechecking is working, however\nit's nice to capture them properly rather than just throwing with error.\nIt means we also need a similar set of functions for adding and looking up\nfunctions and variables, which can be found\nhere and are hopefully unsurprising.\nA lot of our implementation are various \"turn things into LLVM\" functions:\n\n\n\nNow we can create IR for each function in our module. We put each function\nvariable in State so that we can look them up when generating expressions:\n\nWe have two new cases in exprToLLVM, for EVar and EApply. These somewhat\necho the implementation in the typechecker above. For EVar, we lookup the\nLLVM IR in our State.\n\nAnd for EApply, we lookup the function in State, then use LLVM's call to\npass all the arguments to it.\n\nFinally, we bring it all together in the top level moduleToLLVM function,\nwhich takes our typechecked Module and creates an LLVM module.\n\nYou can see all of the LLVM generation code\nhere.\n\nWell, well, well, if it's not the end of the article\nCongratulations, you are all functional programming language implementation experts now. Hopefully you found that somewhat interesting and/or useful.\nNext time we'll be adding basic product types and pattern matching. Great!\nMake sense? If not, get in touch!\nFurther reading:\nllvm reference\nllvm-calc\n","id":"https://danieljharvey.github.io/llvm-compiler-part-3/","title":"Compiling a functional language to LLVM, part 3"},"https://danieljharvey.github.io/new-types/":{"body":"Good question. What are newtypes?\nYou see them in Haskell a lot. Here's one.\n\nWe can make a Dog as a container for a thing (in this case, a String)\n\nOr we can unwrap it again and lose nothing along the way (this means the types String and Dog String are isomorphic in maths terms)\n\nIn short, they are basically the same thing. Once compiled in fact, they're exactly the same, so there's no cost to all this, computationally.\n\nSo why do this?\nWell, the nice thing about a newtype is that we can use it to pass data around with a bit more contextual information about what it means.\nLet's calculate a salary. That seems like a plausible thing to do with a computer.\n\nThis function takes a number of months, and calculates how much this person should get paid, based on a salary of 1000 (of some unknown unit) a month.\nBut what happens if we give it an invalid number of months?\n\nThat's crazy talk! Surely this weird minus payment will send even the most well-meaning of accountants into a spin.\nLet's improve it a bit by checking if the number is negative.\n\nNote that we're introducing the Ord typeclass here, as we need to compare amounts. We don't mind what a is as long as it is both a valid number (ie, in the Num typeclass) and is orderable (ie, the Ord typeclass).\nSo now if we try this on a stupid amount, we get Nothing\n\nOK. Good stuff. That should stop the accounts department crying into their sensibly priced but ultimately unsatisfying packed lunches.\nThe thing is, when we run this, we get this Just wrapped around things.\n\nThis is fine in isolation, but if we wanted to do a lot of calculations here we don't want to be wrapping and unwrapping Maybe values all over the place. It means mixing up our validation logic with our actual business logic or whatever, and that's Bad.\nWhat about a nice newtype solution?\n\nNothing to write home about so far, but the trick here is that Haskell allows us to export the type PositiveNum but not the constructor PositiveNum. That means that instead we can provide a function for making a PositiveNum that does some validation. This means that, outside our module itself, there is no way to create a PositiveNum that doesn't make sense.\n\nIt comes wrapped in a Maybe, sure, but only one. It can be used over and over without needing validation, and once it is available it can be unwrapped with a quick getPositiveNum.\n\nGreat stuff.\nLet's make a nicer salary calculator.\n\nPretty OK. Let's bring it all together. First our library functions:\n\nWe've added zero that just makes a default PositiveNum with a value of 0 here, to use as a fallback if the value is ridiculous.\nNow we have a function for getting a PositiveNum for our number of months:\n\nWhich we can use as follows:\n\nNice. By pushing all of the validation concerns into the months function, our actual function is nice and simple and easy to understand. Also we have a nice re-usable tool, PositiveNum that can be used across our project everytime we need some guarantees about a value.\nBonus credit: Functor instance for a newtype.\nWe can treat newtypes like any other type, and create typeclass instances for them. For instance, we could create a functor instance for PositiveNum and do calculations inside it by mapping instead.\n\nThis lets us change the value inside PositiveNum with an fmap function.\n\nOr the same, but unwrap it afterwards:\n\nThat seems pretty OK to me. Anyway, that's enough things, time for bed.\nMake sense? If not, why not get in touch?\nFurther reading:\nNewtype in Haskell Wiki\nNewtypes aren't as cool as you think\n","id":"https://danieljharvey.github.io/new-types/","title":"Why The Hell Should I Care About Newtypes?"},"https://danieljharvey.github.io/optics-pt-1-lens/":{"body":"Lenses are a thing that Haskell people talk about a lot. They bloody love a lens. Everywhere you go, lens, lens, lens. What is lens? Should we, mere mortals, care?\nLet's try and find out what the big deal is.\nSo.\nImmutability is great, but it does mean that updating a value that lives deep within a big data structure can become an utter pain in the arse. Let's define a data structure:\n\nIt contains DbConfig which looks like this:\n\nAnd here is an example of the data:\n\nHow would we get data from this structure in something like javascript?\n\nIt's not too bad in Haskell either, as it auto creates selector functions for records like thus:\n\n(This could also be written as thePort $ dbConfig app but lets keep things simple.)\nThat all seems well and fine, but how would we change the port in this app config? In mutable JS-land, this would be easy, something like:\n\nIgnoring for a moment that we have ruined the original object and probably confused anything that depends on it, this is OK, and nicely concise. The immutable way is a bit wordier though...\n\nAnd this will only get worse as the levels get deeper. Haskell has a similar problem with deep updates in records, here's the equivalent code:\n\nThe worst thing about the code above is that the only really relevant part is thePort = oldPort + 1. Urgh. What's the solution then? Lens!\nA lens captures the idea of both a getter and a setter of a piece of data and a sub-part of it. Here is one for getting title from an AppConfig.\n\nWe can get the title of the app using view:\n\nWe can change the app's title using set:\n\nLastly, we can map over the app's title using over:\n\nOK. All so well and good, but this does not solve our deep structure update problem. How might we change thePort inside dbConfig in the same way?\nBy composing Lenses!\nThis lens gets us the DbConfig inside AppConfig:\n\nAnd this one gets us thePort inside DbConfig:\n\nBut by composing them together we get a lens that takes us from AppConfig all the way to thePort:\n\n(Function composition with the . operator usually means that the right-hand function is run first, and then the left. With lenses, it makes more sense if we read from left to right, so if you squint it looks a little like javascript: fullPort = dbConfig.port. Kind of. Just nod and let's not mention this again.)\nLet's use them to look at the port!\n\nTo choose a new port!\n\nOr to increment the port by 1, for some reason!\n\nLook at all the things we've done with not too much code. We are now surely mighty hackers. A small disclaimer, the family of things that Lens is a part of are called Optics, and Lens is only the beginning. Next time, we'll look at another variation on Lens called Prism, and see how it let's us interact with that Either type we've conveniently ignored in these examples.\nMake sense? If not, why not get in touch?\nFurther reading:\nThinking in Ramda: Lenses\nA Little Lens Starter Tutorial\n","id":"https://danieljharvey.github.io/optics-pt-1-lens/","title":"Why The Hell Should I Care About Lens? (Part 1)"},"https://danieljharvey.github.io/optics-pt-2-prism/":{"body":"So last time we looked at lens and saw had to jump into record-shaped structures and change things around like big hacker professionals. However we didn't try to change anything with a sum type in it, like Either or Maybe or something. What can we use for that? Only a bloody Prism, apparently.\nHere's an example sum type that can either contain a dog's name or it's age, and is in no way utterly contrived.\n\nHere are some examples of it is in use. Here it is valiantly holding a dog's name, a String, with the DogName constructor.\n\nGreat!\nAnd here, instead, is a dog's age, stored as an Int inside DogAge.\n\nExcellent stuff, I'm sure you'll agree.\nNow, we could start making all our getters and settings by hand again like this...\n\n...but I'm sure it's clear it's soon going to get quite verbose and we should probably use something more clever instead.\nEnter Prism! (the crowd goes wild, etc.)\nA Prism is like a Lens, except it let's you peek into a particular part of a sum type. Therefore we can make one Prism that is interested in the name of dogs...\n\n...and another which only cares about the age of dogs...\n\nOK. So how do we use them?\nIn lens, we had view for peeking inside, set for changing values, and over for mapping over the values inside. What has Prism got going on?\npreview\nUnlike lens which has set, prism has a good pal called preview that it uses for checking out values. It returns the result inside a Maybe as the value is not guaranteed to actually be there.\n\nThat seems reasonable.\nWhat about running that on spruceBruce (that is built from a DogName)?\n\nNo dice. Zero dice. A complete lack of dice. No age, no int, sorry.\nMaybe our dogNamePrism can help though...?\n\nYes! Good stuff. Does he work on ages though?\n\nNo. Damn.\nset\nIn lens we used set for changing the value of something nested. How does that work here?\n\nAll seems well here, pretty similar to a regular lens. How about we give our dog a name instead of an age?\n\nWhat's happened here? Where is the name? We've ended up with exactly what we started with! How the hell do we give the dog a name? I must admit this confused me for quite a while, until I realised that Prism is doing exactly as it should - letting us get at the values inside a sum type without changing it's structure.\nTherefore we can change one DogName for another...\n\n...but not change the name of DogAge.\n\nover\nAs well as inheriting set from lens the prism also has over, that lets us map a function over nested value.\n\nWhen you think about how mapping a function doesn't change the structure around the value (hello, functor) then the behaviour of set that initially confused me so much seems a lot more reasonable. The over function just lets us muddle around with whatever is inside our chosen sum type, should it be there to muddle around with. As such. Clear as mud, right?\nComposition\nOk. So like all these examples, the one above is quite simple so that you can see what's going on, but like all abstractions, it can leave us thinking \"thanks pal, but this all seems a little bit much like hard work, surely\". But what makes it all worthwhile is when we combine a Prism with other optics to make a giant super-optic. Remember our example from part one?\n\nWhat if we wanted to change what's inside count? That would be nice, wouldn't it.\nFirst, let's make a prism for count.\n\n...and a lens for getting a count out of the main appConfig...\n\n...and then we can compose them together to make a new thing.\n\nLet's use it to grab that count value...\n\nGreat job!\nAnd we can use it to change things too! With set!\n\nAnd over!\n\nAll our friends are here!\nYou might notice the new type Traversal that has been produced by combining a Lens and a Prism. That's an interesting thing in itself, but we'll come to that another time.\nThat's quite enough.\nMake sense? If not, why not get in touch?\nFurther reading:\nLens by example - Prisms\n","id":"https://danieljharvey.github.io/optics-pt-2-prism/","title":"Why The Hell Should I Care About Lens? (Part 2)"},"https://danieljharvey.github.io/ordering-and-limits/":{"body":"Hello, hello, hello. Welcome to part four of this adventure where we're making a database by hand. In part three we did some joins, and today we're doing to do some limiting.\nIf you'd like to look at the code, it's right here.\nNo no, no no no no, no no no no, no no, there's no limits\nLimit is very straightforward, it's used to control the amount of data we get back from a query.\n\n...will get 10 items from the albums table. To help decide how we choose which 10, we'll need ordering which will come next.\nWe add a new Limit to the Query type, containing the following:\n\nThen we add this to our run_query function:\n\nThat's the whole thing. What a disappointing blog post.\nWhat's next?\nNext time we're doing ordering, which is marginally more exciting, but not that exciting tbh.\nMake sense? If not, get in touch!\n","id":"https://danieljharvey.github.io/ordering-and-limits/","title":"Let's write a database (part 4)"},"https://danieljharvey.github.io/polymorphism/":{"body":"Let's talk about type signatures.\n\nPretty clear what is going on, right? Seems fine. What about this lad?\n\nThat's pretty unhelpful to be honest.\nWhat are these letters doing in our types when we wanted, well, types?\nLet's work up from a simple one to a stupid one and maybe learn something along the way. Good? Great.\nProbably the worst function ever\nHere is a type signature for a mysterious function:\n\nGiven any a, and knowing nothing about that a, what is the only thing that we can do with it?\nIf you guessed \"just return it\", then yes, you were right. It's the classic identity function.\n\nWhat do you think this function does?\n\nSince we don't know anything about b, and the function returns an a, then all we can do is ignore the b altogether. This is called the const function, and is used when we have to want to make a map function do not very much at all.\n\nHopefully the pattern you are seeing here is that if we know nothing about our variables, then there is actually very little we can do with them.\nLists of mysterious things\nA place most people come across polymorphism quite early on in their Haskell careers is in stuff like lists. Instead of one function that works on List String, and another one List Int, and another on List (Maybe Tuple (Int, String)) we can use polymorphism to act upon the structure of the list itself but not the items inside.\nWith this in mind, and given that [a] means a List that is full of zero or more a values, what possible things could this function do to our [a]?\n\nAccording to the function search engine Hoogle - not a huge amount. It lists four functions that match this signature - and two of them throw exceptions if passed an empty list so they're not the kind of functions that we like to spend our time with. This leaves:\n\n\ncycle - this repeats the list of values infinitely.\n\n\nreverse - reverses the order of the list.\n\n\nThe important thing is that since we don't know anything about what the hell a is, all the functions can do is mess around with the ordering a bit, as is their right, I suppose. How can we find out more about these a and b values without concretely specifying what they are?\nConstraints\nIf there's anything going on before the =&gt; in a type signature, there's a good chance it's a constraint. These are rules that apply to each type they refer to. Here, we are using a constraint on a, that says \"I don't care what a is, so long as it has a Show instance\".\n\nTherefore, the only thing we can really do to these a values is show them, as we don't know anything else about it.\nWe can do something similar with the Num typeclass (which is the typeclass of numbers).\n\nHere, the constraint means we don't mind which kind of number we are passed - since they all implement + so we can add them together.\nWe can have as many constraints as we like on our variables (often multiple ones on the same value, such as (Show a, Ord a) =&gt; for things that can be sorted and eventually turned into strings) - and can use any typeclass to do the restraining.\nI hope this makes sense. This started melting into something about IO testing, but I have decided to spin that into a separate post before this one spirals out of control, so let's stop for now. Thanks.\nMake sense? If not, why not get in touch?\nFurther reading:\nPolymorphism for Dummies\nPolymorphism in Haskell\n","id":"https://danieljharvey.github.io/polymorphism/","title":"Why The Hell Should I Care About Polymorphism?"},"https://danieljharvey.github.io/property-testing-mimsa/":{"body":"So in the last post I quickly introduced the project I've been working on for a\nwhile called mimsa. The reason I did this was so that I could write this post\nabout recently adding property tests to the language, and what was good/bad\nabout that, so without further ado here are many words:\nTests in mimsa\nSo, for context, unit tests work as follows in mimsa:\n\nWe create a (broken) add function:\n\n\n\nWe create a unit tests that confirms that add is indeed broken:\n\n\n\nWe update add to a working implementation, and now the test passes:\n\n\nWhat is really neat is that what looks like one test being run twice is\nactually two tests being run once each.\nWhy? The reason is immutability - once the first test is\ncreated it can't be changed. It also doesn't need re-running - it always has\nthe same arguments, and it's only dependency, the original add function,\nnever changes, so the test stands as a static assertion of the behaviour of\nsaid function.\nAnd where does the second test come from? When we bind a new version of add, it stands to reason we might\nwant to run the same tests on it, therefore a new copy of any test is created\nthat uses the new add function as it's dependency.\n\nA really nice property of testing in this way is that we could also make it\nrun in reverse. If I add another test to the new add function there is no\nreason not to auto-create versions of it for the old add bindings too. This\nis super helpful when finding a new regression, as we can write a new test for\nold code to find out when said regression occurred, a sort of super-powered\ngit bisect. I say could here because I have not done this yet because I am\nlazy.\n\nProperty testing, a recap\nProperty testing is a kind of testing where instead of confirming our code\nworks against known good values we confirms that it obeys certain rules.\nA non-property test could be add 2 2 == 4 - we know this should be the answer\nbecause we have checked on a calculator that 2 + 2 does indeed equal 4.\nA property test might be add 0 a == a, given any a. When this is run by\nquickcheck or\nfast-check the property testing\nframework will run the test with loads and loads of different values for a,\nand return all the ones that break it (in this case, none of them). If the\ntests all pass then we know the property adding zero to a number returns the same\nnumber holds.\nProperty testing is very useful for finding edge cases in functions, and used\nwell, can be a lot more thorough than unit tests, for not a lot more effort.\nThe current implementation\nFor a unit test to be valid in mimsa, it must have the type Boolean (There\nis a lot wrong with this, as it doesn't let you see what went wrong, but we\ncan't just go around making things \"good\" all the time).\nTherefore this are the simplest possible tests:\n\nTo make a property test, we provide an expression with the type something -&gt; Boolean, like:\n\nWhat's happened here?\nThe mimsa typechecker has inferred that bool must be a Boolean, generated\na big bucket of booleans, and then checked that each time or bool True == True. This returns True everytime so the test passes.\n\nThe or function has type Boolean -&gt; Boolean -&gt; Boolean and looks something like \\a -&gt; \\b -&gt; if a then True else b. It is\nsimilar to the || operator in most programming languages.\n\nLet's try another:\n\nThis property test has failed, and it's telling us that when you pass False\nto the test function, it does not return True. The and function here is\nequivalent to &amp;&amp;, so this makes sense, as False &amp;&amp; True equals False.\nAs the input is a Boolean there are only two inputs, and the mimsa property\ntest generates 1000 sample inputs, it's fairly likely we'll get both a False\nand a True input.\nBreaking it\nHowever, it's not too difficult to make a less definitive test:\n\nBecause the input type here would be Maybe (Maybe (Maybe (Maybe Boolean))) there are a lot of potential inputs,\nand it's quite possible that Just (Just (Just (Just True))) is not amongst\nthe generated values.\nAnother type of flaky test can be generated like this:\n\nIt passes every time I have tried it, although as a statement it makes no\nsense - there is no string that equals \"dog\". This kind of test is hard just\nbecause there are so many potential strings out there that a total search of\nthe space is close to impossible.\nThe problems / solutions\nSimple tests could be non-deterministic and aren't:\n\nThis could be two unit tests that are run once and never again, however as a\nproperty test it must be run over and over. This is the least of the problems\nbut worth mentioning.\nComplex finite tests become flaky\n\nGiven that a Maybe is either Nothing or the value inside, and Boolean can\nbe 1 of 2 values, there are 1 + 1 + 1 + 1 + 2 == 6 potential inputs here.\nIt doesn't seem out of the question to auto-generate all the possible values\nhere and run tests against them all. This would ensure a) the same results each\ntime and b) that we could cache the results once and never run them again.\nHowever, if the input type contains an Int, String, Array or any recursive\ntype then generating a complete set of inputs is no longer practical.\n\nA recursive type is one that contains itself. For instance, a linked list is\ndefined in mimsa as type List a = Nil | Cons a (List a). The second List a argument to Cons means \"and another list\" so this datatype can grow and\ngrow and grow.\n\nString and number spaces just too huge\n\nDue to the way the mimsa web client works, we can't really fall back to brute\nforcing an absolute shit ton of inputs for String and Int inputs. However,\nwe have access to the AST when running the test. Would it be so terrible to add all of the string and number literals found in the\nexpression into the test values? For instance, if we used the input \"dog\"\nabove we'd find the breaking case immediately.\nNo more words\nThat is the end of the words. It's a bit of a braindump, and pretty much only\nfor my own benefit, but I hope it is perhaps vaguely interesting. Who knows?\nMake sense? If not, get in touch!\nFurther reading:\nquickcheck\nfast-check\nmimsa\n","id":"https://danieljharvey.github.io/property-testing-mimsa/","title":"Property testing a content-addressed language"},"https://danieljharvey.github.io/purescript-aff/":{"body":"Good morning and/or evening. I found myself defaulting to starting with an apology for the amount of time since my last post, then I caught myself and reminded myself that It's My Blog And I Can Post Whenever I Feel Like It Actually. So with that in mind, let's continue to today's main course, at exactly the rambling pace\nof my choosing.\n\nAs I may have mentioned, my current timesink of choice is a Purescript re-write of a browser game I wrote a couple of years back called It Is The Egg. It is going pretty OK, all told, I've gotten all the awful fiddly stuff like rendering sorted so now I am free to remake the game logic in nice pure functions and generally have a good time. For those of that don't spend their free time ignoring their loved ones and instead writing terrible games in a functional programming style, a few notes on the vague architecture that I have settled on.\nIt falls into three parts:\n\nAdmin\nRendering\nLogic\n\nAdmin\nThe admin of the game is everything that needs setting up at the start. Images need loading, level files need loading, window events need setting, and we need to start a game loop that will run everything all the other parts. All of this stuff is very effectful as it involves interacting with the real actual world, the thing that functional programmers are rightly terrified of. This is mostly the layer that we will be discussing today. This layer is difficult to test, so don't.\nRendering\nMuch like in the React architecture, the Rendering layer is only concerned with receiving the current state of the game, and displaying it on the screen. We will come back to this later when we talk about working with the HTML Canvas in Purescript, and how we use buffering to keep things (vaguely) smooth. The Rendering layer only has access to a) the current game state and b) the previous game state, so that we can do a few optimisations to avoid unnecessary work. It has no way of changing the game state in any way. This layer, because of it's need to write to the canvas, is also effectful, and difficult to test so try and keep it as thin as possible.\nLogic\nThe Logic layer is run every \"turn\" of the game and is a function that takes the current game state, any input that has been received since the last turn, and uses this to compute the next game state to pass to Rendering layer. Everything in the Logic layer is pure functions, and is very easy to test, therefore this should have lots of tests because we all good programmers who appreciate software craftsmanship. Anybody that has written Redux reducers should find this very familiar.\n(Anybody vaguely familiar with design patterns in Haskell might be thinking \"shit, this sounds a lot like Matt Parsons' Three Layer Haskell Cake pattern, this could be pretty awkward\" - and yes - it is indeed pretty similar, and shamelessly so.)\n\nSo today we're going to talk about the game setup part, and on the way, discover, as I did, the actual difference between Purescript's Effect and Aff and how to operate the two of them.\nFirstly, some background\nWhilst any Haskell programming must start with a function such as this:\n\n(The type signature IO () means \"this returns a function that does some IO and returns nothing of interest\")\nThe Purescript equivalent is this, taken from the default program generated by Pulp.\n\nThis program uses console.log to write out a friendly message, and returns nothing of interest. The Effect type is like Haskell's IO, meaning \"this function does something effectful\" and Unit is the same as (), meaning \"nothing\", but Purescript prefers it written using words which is arguably easier to understand.\nThere is a more subtle difference though - Haskell's IO is blocking - meaning we can write code like this, no problem:\n\nWhen we run this program approximate this will happen:\n\nThe program greets the user, ask them their name, read the response, and use that name in the reply. The type signature for readLine is IO String, meaning a function that does some IO and returns a String. It does not specify when said string will arrive. If the user sits and waits for 100 years to type a response, the program will happily sit and do absolutely nothing else, obediently waiting for the user before continuing with the program.\n\nPurescript, however, is built on top of Javascript, and some of you may be lucky enough to remember first getting stung by the concepts of callbacks etc when first moving to writing front end code. It's equivalent function to readLine, looks something like this:\n\nHopefully what should be bothering you is that this function returns Effect Unit - ie, with no String to be seen. What's going on? Well - the actual return is happening in the the callback function, which is the first argument - (String -&gt; Effect Unit). This function will immediately return Effect Unit but then send the String to the callback whenever the user sees fit to provide on. Therefore we can write the original greeting function in this new style as thus:\n\nThis seems pretty OK, however if we end up asking a lot of questions, we're going to end in a classic Javascript anti-pattern, the Pyramid Of Death.\n\nNot ideal.\nWhat has this got to do with eggs?\nSure, sure. Coming back round to our game, we have a similar problem. The game is tile based and so before we can dream of drawing anything we're going to need to load a big pile of images.\n\nAs we can see in the Purescript Canvas Docs we are going to need a CanvasImageSource to draw a sprite onto the canvas:\n\nHow do we load one? With this tryLoadImage function.\n\nIt takes a String (the path to the image), a callback function (that will be passed Maybe CanvasImageSource), and then returns Effect Unit. This is very similar to readLine, so if we want to load lots of images we are going to end up with a weird pyramid of callbacks and generally a bad mess.\nEnter Aff\nAff is the asynchronous effect monad for Purescript. It allows to sequence async events without using callbacks, and we're going to use it to load loads of images. First we are going to need to wrap our Effect function to make an Aff function.\n\nHow does this work then?\nFirstly, it probably helps to look at the type signature for makeAff:\n\nOK. It's a bit weird. The a can be whatever item we're trying to move around, let's replace it with CanvasImageSource:\n\nThis function takes a function that returns an Effect Canceler, and returns an Aff function that returns a CanvasImageSource. The (Either Error CanvasImageSource -&gt; Effect Unit) function will actually be passed to you, to use as the callback for the Effect function you are wrapping.\nLet's look closer at wrappedFn, with a type signature added for clarity.\n\nIt is passed done - which takes an Either holding either an Error for failure, or a CanvasImageSource if all went well.\nThe callback in tryLoadImage gives us a Maybe so we pattern match on that, add a helpful Error if things go wrong, or return the CanvasImageSource if it all works.\nFinally, it creates an Effect Canceler with pure mempty - which just returns a Canceler that does nothing.\nUsing our exciting new function\n\nNow instead of using callbacks, we can use regular monad binds to get our images out.\n\nAnd even better than that, if we take an array of file paths...\n\n...we can use traverse to turn an array of paths into an array of CanvasImageSource.\n\nloadImages takes our list of file paths, and returns an Aff containing an Array of CanvasImageSource. traverse runs our function on each item in the array, then turns the types inside out so we can Aff (Array CanvasImageSource) instead of Array (Aff CanvasImageSource).\nConstructing this Aff doesn't do anything until we actually run it, which we can do with runAff.\n\nIt takes a callback, the Aff we have constructed, and then returns Effect Unit. Our whole image loading program would thus look like this:\n\nThis will attempt to load the files, and then either log out the error message or the number of files loaded! Magic! Next time, we'll grab these images and print them all over the screen in an exciting manner. For now though, this is quite enough.\nFurther reading:\nGraphics.Canvas\nEffect.Aff\n","id":"https://danieljharvey.github.io/purescript-aff/","title":"A game in Purescript (Part 2 - Effect and Aff)"},"https://danieljharvey.github.io/purescript-semigroups/":{"body":"Hello! I hope you are well. It has been a little while between posts as I keep starting things and then not finishing them.\nMy most recent distraction has been remaking a game that I wrote a year or two back called It Is The Egg, which is an HTML canvas game where eggs roll around and generally have a nice time. I wanted to add more levels and features but I have no strong desire to write Typescript in my free time, so I have made the somewhat foolish and time-sucking decision to port it over to Purescript.\n\nSo far I've learned a few things, listed thus:\n\nRewriting an entire game takes a while actually.\nUsing Purescript means about 30% of the LOC it took in Typescript\nA lot of the problems have already been solved by other people\nAbstractions are helpful\n\nAnyhow, I figured concrete useful examples are the most difficult thing to find when explaining functional programming, and since I stumbled across a few in this process I figured I'd share some. Today I'm going to example how to describe positions and movement using a semigroup.\nMeaningless? Possibly! Perhaps some examples...\nSo we have a Player type - it describes one of the eggs onscreen. The eggs have a position onscreen, and a direction that they are currently moving in.\n\nThis is the Coord type. The eagle-eyed might notice it's a newtype rather than a type - the reason for this will be explained shortly.\n\nThe game board is a grid, so position is a Coord where x and y describe the current square the Player is in, and any movement away from the center is described by offsetX and offsetY. Once a players position offset goes over a certain boundary, we increase or decrease x or y and set offsetX or offsetY back to zero.\nThe position for the pink egg in the above screenshot would look something like this:\n\nThe direction is also a Coord, where we use x and y to express which direction the player is headed. Our pink egg above is falling downwards, which would look like this:\n\nThe offsetX and offsetY don't really have much use in this context, but that's fine.\nSo what's the use in expressing two slightly different things in the same data type and also what about that newtype and why have we not mentioned semigroup yet?\nAn abridged version of each game turn goes as follows.\n\nLook around to see if we are still able to move in direction we want to\nIf not, change direction\nMove the player in whichever direction we're now decided on\n\nLooking around the board\nOK. So firstly we need to check around the board to see if we are allowed to carry on moving where we are moving. Without going into the whole mechanics of the game board, let's say we have a function that tells us whether a certain Coord on the board is a place we are allowed to go.\n\nWhat this function does is none of our business at this point - all we need to know is whether the square we intend to move into is happy with our decision to do so.\nMy first implementation followed the original logic and looked something like this:\n\n\"If we are moving left then look to the current square but with x reduced once but if we're looking right then look to the current square but with x increased but if we're looking up....\".\nQuite a laborious thing to read really, and it says nothing of it's intentions.\n(If you are not familiar with guard syntax, think of this as very similar to select case statement in Javascript.)\nStand back, I am going to use Maths.\nOK, so we made that Coord a newtype for a reason right? Let's add some typeclass instances to it and get it working for us for a change.\nFirst we must please the gods of boilerplate by deriving some standard instances of Eq, Ord and Show. Purescript needs this to be a little more explicit that Haskell does, sadly.\n\nderive newtype instance means \"You know how you're a newtype wrapped around something, can you just copy whatever the thing inside does? Ace, thanks.\"\nThis means we can now compare and order things, which is helpful although not the main point here.\nLet's define a semigroup!\n\n(Notice that unlike Haskell, Purescript likes us to give our instances names, hence we have chosen the olympically dull semigroupCoord. It could be pintsOfCream or indepedenceDayIsPrettyUnderatedAsFarAsBlockbustersGo, go absolutely wild if you like.)\nSo what does this append function we have defined do then?\nIt takes two Coord values (fst and snd in this case) - adds up x, y, offsetX and offsetY - then makes and returns a new Coord. Therefore we can do stuff like add a position and a direction together.\nIn the above example of our pink egg, and our position and falling values defined above, we can check whether we're OK to keep falling downwards as such.\n\n(Note we're using &lt;&gt; which is another name for the append function, we could just as easily have written canMove (append position falling) but I think the little &lt;&gt; looks nicer.)\nLooking around the board with Maths\nBack to our implementation of canIMoveNext, here is the new version that combines our player's direction and position in a nice tidy way.\n\nNice.\nChanging direction\nWhat if our egg hits a wall or something? What should we do then? It should be as easy as reversing the direction, right?\n\nTherefore we can use it on our player like thus:\n\nAnd wrap up the entire logic for the turn like this:\n\n(Readers with a keen eye will notice we did not use anything particularly clever or typeclass based here, I just included it for completeness.)\n\nActually moving that egg around\nLet's get back to moving the egg around. Once we've worked out that our egg is moving somewhere it is allowed to, we need to actually update the offsetX and offsetY in it's position so that's in the new location and ready to go through all this hell again. As web browsers are flaky at best, instead of moving by a set amount the actually amount to increment the change depends on how much time has passed since the last frame. Therefore we need a function that takes the amount to move and a Player, and returns a new Player that has moved in some way.\nHere, in a similar manner to our earlier function, is something like my original painful version.\n\nIt should work but it's a bit terrifying. Let's break it up and get some of that sweet semigroup magic working for us.\nFirstly, a helper function - this takes an Int and a Coord and creates a new Coord that describes the movement we want the egg to do.\n\nTherefore if we take the falling value from earlier, and a moving amount of 20, it would create something like this:\n\nWith our helpful helper function in hand, and a dash of &lt;&gt;, we can now rewrite our move function like thus:\n\nSo here we're creating a Coord for the movement (called moveCoord) - and then using the &lt;&gt; function to combine it with the current position to make a new Coord called newPosition, and then making a new Player with that position.\nPutting it all together\nNow we've created all our functions, we can plop them together like this to do the whole move:\n\nEasy as pie.\n\"But I thought we'd actually draw one of those attractive looking eggs and instead we've just done some shitty maths\", I hear you say. OK, OK, sure, I get it, you want adventure, you want action. We'll come to it soon, I promise.\n","id":"https://danieljharvey.github.io/purescript-semigroups/","title":"A game in Purescript (Part 1 - Semigroups)"},"https://danieljharvey.github.io/refined-types/":{"body":"About a month ago I gave a talk about Refined types at a React meetup.\nNeedless to say, it was a resounding success so I thought I would share an\nadapted version of the slides so that you can all learn to be as learned as me\nwhen it comes to such a topic.\nLet's start by listing some things that we as programmers generally agree we don't particularly like:\nRuntime errors caused by Javascript YOLO\nHere is some classic code written in the Javascript programming language:\n\nAt a casual glance, it would appear to be some rather convoluted code for\nmaking a string uppercase.\nTherefore, this seems fine:\n\nBut this isn't so great:\n\nWhat happened? Well it wasn't really a function for making strings uppercase,\nit was a function that takes any piece of data, then makes it uppercase if it's\na string, and just breaks weirdly with anything else.\nAnother thing we don't really like doing as programmers is...\nOverly defensive code around user input\nSo if your start in programming involved more than a sprinkling of PHP, then\nyou'll be used to starting all your functions with the manual typechecking dance.\n\nDefense against the dark arts\nAnother favourite is manually checking our values to check basic mathematical\noperators aren't going to explode the whole computer.\n\nHow far does something like Typescript get us?\nSo we can change our weird uppercasing function...\n\n...to only take a string like we intended.\n\nLet's give it a smash:\n\nExcellent stuff.\nAnd now, if we try and do some wild type stupidity, our code doesn't even compile:\n\n+1\nWhat about this potentially malformed user input?\nThis Wild West Cowboy Javascript...\n\n...gets a string type, which means we don't have to check that name exists...\n\n...but we still need to check whether name is long enough and return a default if not.\nWhat about that classic divide by zero problem?\nWhat can basic types give us here?\n\nWe can get rid of the number checks...\n\n...but we've still got to check for that zero value. Better, but not great. What if I told you we could do better than this?\nRefined\nEnter Refined types. A Refined type looks like this:\n\nAs it is a newtype it is a wrapper around a value that is used for type\npurposes at compile time but then erased at run time (so when the program runs,\nRefined 100 is just 100 as far as memory etc is concerned)\nvalue is the type of actual data we are refining, for example Int or Number.\npredicate is a type that lets us better describe the value.\nThe most interesting thing to note here is that predicate only exists on the type side (ie before the =) and not after - this makes it a phantom type which is only used to add contextual information. Let's see what that actually means...\nMaking Refined values\nThere are a few ways to make Refined values, especially in the Haskell\nlibrary - we'll concentrate on two. I'm going to use the types from the\nPurescript version because a) they're simpler and b) I made them and am thus\nless likely to get it wrong.\n\nThis is the regular way to make Refined value - you pass it a plain value and\nit returns either Left with a RefinedError describing the problem, or Right with\nthe Refined value inside.\n\nThis ignores the predicate and leaves it to the programmer to go full YOLO\nand decide whether the predicate will be fine. I have used this to make\nMonoid classes where I want to add two positive numbers without checking\nthat the outcome will still be positive.\nId\nThe most basic predicate is id, which doesn't really do anything.\n\nIt's named after the id (or identity) function - the function that returns whatever it\nreceives, basically doing nothing.\n\nFor example, any value that is a value Int can be made into a valid Refined Id Int.\n\n\nPositive\nThe Positive predicate, which only allows numbers over 0.\n\nThis refinement would pass the predicate:\n\nThis clearly very negative number clearly won't fly. Nice try, ding dongs!\n\nFrom\nWe can be even more specific with these types too. The From predicate takes an integer and only allows values equal to or above\nit.\n\n(A note here - that D10 is a type-level 10. It is provided by the purescript-typelevel package.)\nTherefore this 9 is clearly taking the piss and totally won't refine.\n\nHowever this 100 is cool with me, and will happily refine.\n\nTo\nHopefully it should be fairly intuitive how the To predicate works...\n\n\nSizeEqualTo, SizeGreaterThan, SizeLessThan\nRefinements don't have to just be about numbers - we can use them on foldable\nstructures too, such as Lists. The refinements let us be specific about sizes\nof said structure. Therefore we could make a non-empty List of Boolean\nvalues with Refined (SizeGreaterThan D0) (List Boolean).\n\nTherefore this list does not refine...\n\n...but this one is fine.\n\nAnd, Or\nThese type signatures are starting to get pretty hefty, but we can do better\nthan that - we've also got And and Or for combining them.\nLet's only allow whole numbers from 1 to 100...\n\nOr indeed, allow all whole numbers EXCEPT 1 to 100.\n\nThis type describes the roll of a dice.\n\nOr this one, which describes the first bunch of prime numbers, and is all a bit silly\nto be honest.\n\nBack to our stupid contrived problems...\nNow with the power of Refined types, our defensive printName function is pretty much unnecessary...\n\nPlus we can make a type to make division safe from fear, at last..\n\nAutomatic JSON validation\nSo let's say we have this data type using Refined...\n\n...if we want to use it as an API request, sounds like a lot of work right?\nMaybe not! Because refined instances have fromJSON and toJSON instances\nfor Aeson (or for Argonaut in Purescript) then we can automatically decode\nthem from JSON and make the decoding fail if the predicate does not pass.\nThis way, anywhere in our app, name will always be non-empty. and age will\nalways be 18 or more.\nWell, shit.\nYep. For more details, check out the Refined Haskell\nlibrary or indeed the\npurescript-refined\nlibrary which I ported from the Haskell one.\n","id":"https://danieljharvey.github.io/refined-types/","title":"Refine, fine, fine"},"https://danieljharvey.github.io/tags-and-shit/":{"body":"So previously we've spoken about the idea of a newtype in Haskell. A\nnewtype is a wrapper you can put around a value to distinguish it from other\nitems. It's common to give value that has it's own domain meaning it's own\nnewtype, for instance:\n\nWe create values as such:\n\nAnd unwrap them to use like this:\n\nThis would stop different bits of names, that would usually be stored as\nstrings, getting mixed up. It's neat. What's really nice about it though, as although\nthese look like records with a single item inside, and in code we treat them as\nsuch, as runtime that shit gets erased and really it's just a String being\npassed around for #performance.\nThey have two benefits:\n\n\nFirstly, if you are a goof like me, you get this wrong all the time and put\narguments in the wrong order and generally make a mess of things from\n10x-ing all the time, and this makes such terrible errors a little trickier to\nmake.\n\n\nSecondly, and much more usefully, it allows us to practice Alexis King's\nParse, don't\nvalidate\npattern. It's well worth reading in full, but the very tl;dr is - if I check a\nString to see if it's a valid name, I should return a type that tells me\nthat fact, so I a) don't have to check again and b) don't mix it up with the\nunchecked version.\n\n\nAnyway. It all sounds like good stuff, and I have been thinking about the same\npatterns in Typescript as that's a place I often find myself these days.\nPrior art\nNow a good place to start when trying to reproduce any Haskell / Purescript\nconcept in Typescript is to crack open gcanti's\nGithub where, as usual, he does not disappoint:\nnewtype-ts is a pretty full featured\nlibrary for this built on top of his monocle-ts lens library.\nNow this is all very well, but does sort of require everybody working on your\ncodebase to buy in (especially as it requires you to use modify from\nmonocle-ts to change the values inside, and to explicitly wrap and unwrap\nthem). If everybody is into this, go for it, I am a big fan of the fp-ts\nstack and swear by io-ts at the moment. However, I often need something cheap and hacky, that doesn't leak complexity throughout the codebase.\nFortunately, good man and Habito colleague Mateusz (who I cannot find any links to on\nthe internet, somebody please help me remedy this), came up with a neat way of\ntagging types for cheap, which I'd like to share today.\nThe 10x solution\nHere is the whole library:\n\nThis means we can make unique tagged versions of regular datatypes like so:\n\nThe great thing is that when the Javascript is generated from this, we just\nend up with plain string and number values.\nNow, let's see what these buy us:\nStopping idiots like me mixing stuff up\nThe most basic use is just tagging our types with as:\n\nNow, we can make sure only the right tagged value:\n\nWhen you have a function like apiCall(url: string, token: string, accountId: string) =&gt; ... this really helps to stop you messing stupid things up.\nNow, how about that parsing stuff mentioned earlier?\nParse, don't validate\nSo, we can also use this tactic to tag data that we have validated, so that we\nknow certain properties about it have been validated.\nSay we have a Person type, because I lack imagination:\n\nNow, we want to check a few properties about these things to make sure they're\nnot terrible.\nThe naive version of this looks something like:\n\nBefore using Person anywhere, you could check it made sense:\n\n...and throw an error if it isn't. The thing is, it's nicer to do validation on the boundaries of\nour app and then know afterwards that things are OK. What if we could use our Tagged type\nto help us?\nLet's rewrite our validation functions:\n\nIt looks a bit more verbose, but that's mostly because I've broken each\nvalidation function out. What it means is that we can take our raw Person\ndata, run the validator and get a ValidPerson (because it's valid) or null\n(it wasn't valid).\n\nWe can then pass ValidPerson around the rest of the codebase, knowing that\nthe values are Good and Valid and not needing to check them again.\nDisclaimer\nNow, the disadvantage with such a technique is that there's nothing stopping me\njust using as to change, say a Firstname into a Surname and cheating the\nwhole thing.\n\nHowever, if that's really a problem in your codebase (and I would\ndelicately suggest that what you have there is more a social and not a coding\nproblem) - then perhaps it's time to go all in on newtype-ts or similar.\nMake sense? No? Don't care? Let me know!\n","id":"https://danieljharvey.github.io/tags-and-shit/","title":"Newtypes for Cheap"},"https://danieljharvey.github.io/testing-io/":{"body":"Let's say we have a function that uses the IO monad that we want to test. Now you may be aware that IO is the place in which all the bad things happen that aren't supposed to happen in Haskell. Things like Database Connections, and Mutable Global Variables and (worst of all) Actual User Interactions. It doesn't bear thinking about to be honest.\nHowever, mock dramatics aside, IO is the part of our code where Side Effects happen, meaning stuff is a lot more difficult to write tests for, given our functions may not always return the things we expect them to. Last time, we spoke about polymorphism - and this seems like a nice opportunity to expand on that and use our new polymorphic powers to make some code easier to test.\nContrived example\nHere is some code that uses getCurrentTime from the Data.Time.Clock library to fetch the current system time and then work out whether it is time to stop working and eat some lunch.\n\nThe getHour function is a simple pure function helper - mainly we'll be looking at isItLunchTime. Let's look at the type signature again:\n\nThis function has no inputs, and the IO Bool return type means that it will return True or False, wrapped in the IO type to remind us that evil has been done and the gods of referential transparency have not been appeased.\nIf you are thinking something like \"can we not just extract the pure functions, test those, and not bother about the rest?\", then Don't Read On because although that's Not A Terrible Idea we're absolutely Not Doing That.\nInjection-based solution\nIn other languages, the solution to making stuff more testable is to use Dependency Injection to pass in any functions that use side effects, allowing mock versions to be passed in when testing.\nThis version of the function lets us pass in a time fetching function (such as getCurrentTime) instead.\n\nNow, instead of calling isItLunchTime, we'd call injectableLunch Clock.getCurrentTime. It's still not much more testable though because of that IO though. Does it need to be IO though? What if we generalise the type signature though? Instead of IO, let's just use any old Monad and see if that works.\n\nBecause we're not actually running any functions that require the IO monad (ie, readFile, putStrLn) any monad is totally fine for this function. So long as the Monad m of our passed in time-getting function matches the Monad m of the return value, then this function is having a Great Time.\nAs a slight detour, let's make some fake UTCTime values for testing:\n\nExcellent. What a nice couple of examples. For more information about what these do, check out the time library.\nNow we have some test values, we can then make functions to test our testableLunch function with a safer Monad like Identity. Identity is the Do Nothing monad, it has no special characteristics and does nothing for any particular interest.\n\n\n(What's pure? It's just a function that wraps a value inside the default Monad context, so in this case, turns \"dog\" into Identity \"dog\" etc)\nThen when we want to export the function for use with IO, we can export this:\n\nSeems pretty OK. What about a more idiomatic Haskell approach using our pal typeclasses?\nTesting IO with a typeclass\nAnother way to do this is capture the idea of \"Monad That Knows What The Time Is\" using a typeclass.\nLet's call ours MonadTime, because we lack imagination:\n\nNote the constraint - we can only make instances of MonadTime for things that are already an instance of Monad. By writing instances of MonadTime for IO and Identity, we can tell Haskell what to do when it's asked for the time.\n\nIdentity will return a static value, and IO will use the actual function.\nHere's our new version of the lunch function. Notice we've changed our constraint from Monad m\n\nNow, depending on the context in which we use classyLunch, it'll do different things.\n\nHooray! Our contrived function is now testable and also ready for production. Great stuff.\nThis concept of different typeclasses for Monads is a key part of what is called mtl style of code, which we will come to once we've looked at Monad Transformers.\nFurther reading:\nTime library\nBetter IO testing through Monads\n","id":"https://danieljharvey.github.io/testing-io/","title":"IO, IO, it's off to test we go"},"https://danieljharvey.github.io/the-genius-of-concrete/":{"body":"Note: I have taken a break from whatever it is that I usually crap on about to\ndo some opinions. Beware.\nWhimsical Story\nWhen I was much younger I was what you might call \"quite a trying child\". Apparently, a thing I liked was to ask lots of questions.\nOne that I remember very clearly was this:\n\"Where do washing machines come from?\"\n(A reasonable, if somewhat tangental question I suppose. I can't remember why I\nwas interested.)\n\"A washing machine\", they told me, \"is made in a washing-machine-making-machine.\"\nVery well, I thought. But that wasn't enough.\n\"So where do the washing-machine-making-machines come from?\"\n(That'll fox them.)\n\"Ahh, well you see\", the reply went \"those washing-machine-making-machines are\nmade by washing-machine-making-machine-making-machines\"\nThis went on as you might predict. I won't bore you with what was obviously some sort of early lesson in the dangers of\nunsupervised recursion, but as you can imagine, it was machine-making-machines\nall the way down in my dreams for months after that.\n\nAnyway. There was a point to this. Or at least I thought there was when I\ncouldn't get to sleep and decided I needed to get up and write all this down.\nAbstractions\nSo when using the computers and things, we generally start with very concrete\nproblems, such as \"how we make a washing machine\", and then later, \"also, how can we put another light on this machine machine that\nblinks when the washing is ready?\".\nNow, being close to the metal, as such, the manual manufacturer of said washing machine\nis not going to have too much trouble (crudely, perhaps) adding such a light and making it work. After all,\nthey are equipped with washing machine making tools (hammer? wrench?\nscrewdriver? bear with me here) for the job.\nBut is the true work of an engineer?\nThe trouble is, nobody makes washing machines by hand anymore, at least not for\nlong. Once the maker has gotten the hang of things they think \"this work is\nvery manual and perhaps somewhat beneath me now, surely we can make this easier?\"\nSoon enough, their days with the hammer, the wrench and the\nscrewdriver are wasted, as they have constructed the washing-machine-maker.\n\nWe are all very pleased about this development.\nIt really is good stuff. We're making washing machines at a much quicker pace\nnow, and soon somebody hires in some consultants who point out that we could be\nScaling A Lot Better if we abstract further. Soon enough, they're right - and\nthrough a mixture of capitalism and boredom the  washing-machine-making-machine-maker is born.\n\nNice.\nOne thing we notice in making the even bigger machine is that many of the parts\nin the big machine aren't as specialised as we thought, and we replace them\nwith a combination of more general parts that are tried and tested. This is\ngenerally agreed to be good engineering practice, plus additionally the tried and tested stuff breaks less and is cheaper, so\neverybody involved is having a positive time.\nIt's not long until somebody points out that with a little tweaking, we can expand and have a higher level machine called the washing-machine-and-also-fridge-making-machine-maker-machine-maker that is also capable of making something that may at one point end up making a fridge as well. Business is booming.\n\nOh shit.\nBut wait. A new requirement has been found.\nThe washing machine needs Another Light on it. This one is a new colour, not\nfound in washing machines or fridges. The customer bought one of our first\nfridges and was impressed with how quickly they had worked for him. However now\nchanging the washing machine isn't a job for a hammer, a wrench or a\nscrewdriver anymore, it's going to require changes to the\nwashing-machine-and-also-fridge-making-machine-maker-machine-maker to\nchange the washing-machine-making-machine-maker to construct a  washing-machine-maker that will output the required washing-machine.\nIt'd probably be quicker to knock it all down and start over, but now we've got\na shitload of fridges to worry about too.\n\nGet to the point, you goddamn meandering jerk.\nMy point here is that the recursive levels of washing machine creating\nabstractions here are taking us further and further from our real aim here,\nwhich in this already stretched allegory seems to be \"maintain an ability to\nadd lights to washing machines in a timely manner as and when users of said\nmachine take an interest in such.\"\nThese building blocks, they're all very well, but why did we really start this?\nWas it because we needed to? Or because we were bored of building fridges?\nLet's talk about concrete.\nSo. Concrete is shit.\n(That is to say - it has very little value. I don't know what it's made of, and looking it up now on\nWikipedia would seem somewhat insincere, but I'm pretty sure it's not made of\nactual shit)\nHowever, I am pretty confident you can make things out of it.\nHole in the floor? Pour that shit in!\nNeed a wall? Slop that shit up!\nGot it wrong? Smash that shit to pieces!\n(People can visit the Barbican all they like, it does not change the fact that nobody in human history has been or ever will be emotionally attached to the stuff.)\n\nLet's not be mistaken - our collection of recursive white goods factories are very nice. They may be the solution sometimes.\nBut what I think bothers me most about them is just how much emotional investment we end up having in them. When they're wrong,\nwe don't abandon ship, but instead save our precious work, bending it to our new needs, however grossly deformed the result.\nSo, What Am I Suggesting?\nHow about just being boring? Would that be so wrong?\nSure, concrete code is boring code to write, and nobody wants to be bored, or worse, boring by association with it.\nIt is easy to understand though (and even easier to delete) because it's not wrapped up in 5 other levels of\nabstraction. Do you really need to solve the meta-problem of your problem? Perhaps! I'm not\nsuggesting there aren't generalised problems worth solving, but check you're\nnot just doing it because your actual problem isn't interesting enough.\nDon't wrap your self-worth up in your cleverness. That way lies, at best, sadness, and at worst, singletons.\nSolve the thing, have a nice time, go home.\nThere'll be another problem tomorrow, and this time you might be ready to\nsolve it rather than label it \"scope creep\" for not fitting yesterday's\nsolution.\nIf your work ends up getting thrown away (it will), fine.\nIt was made of shit anyway.\n","id":"https://danieljharvey.github.io/the-genius-of-concrete/","title":"The Genius Of Concrete"},"https://danieljharvey.github.io/total-functions/":{"body":"I recently read a piece of useful advice on Twitter about total functions which I enjoyed. The advice (which I will definitely accurately source at some point in the future, lol) goes something like this:\n\"You start making your functions total by adding Maybe, but then you move onto removing Maybe.\"\nLike all my favourite advice this sounds like it doesn't make any sense, so I figured I'd try and get to the bottom of this.\nFirstly, to clarify, a total function is a function that:\n\nAlways returns some valid data (rather than just when it feels like doing so) and\nDoes not go into an infinite loop.\n\nLet's start with a non-total function. The canonical example is Head from the Haskell Prelude, which returns you the first item in a list, and looks something like this:\n\nIf we pass along a list like [1,2,3], we get 1 back, all great.\nBut what if we pass it an empty list - [] ?\nIf you guessed \"giant heartbreaking error\"- then correct! Exactly the type of thing we were told would never ever happen again once we submitted to a life of functional purity. So what's the deal here?\nWell, firstly, some history - this function was there when Haskell was still growing up and learning what to do in the world, and it's very difficult to go and change something that is used in a million libraries, so it's still there but should be left well alone.\nSo what is the Proper Way To Do Things then?\nIt's to use a total version of the function, of course! Perhaps something like this:\n\nNow what happens? If we pass it [1,2,3] we get 'Just 1` back (the first item wrapped in a Maybe type). Great!\nAnd what about if we use the empty list [] ? We get Nothing, which is certainly not an error.\nSo far, so total, great stuff.\nHowever, our function is currently responsible for two things:\n\nChecking the inputs are even correct\nGetting the first value\n\nIdeally, we should be able to use types to make sure this doesn't happen, and make validating that data Somebody Else's Problem.\nTherefore, let's start by creating a new datatype...\n\nIt contains a first value and a list, therefore ensuring there is always a first value. What does this to do to our head function then?\n\nBecause the data type cannot be empty, our head function is guaranteed to return a value and is thus total.\nBut we've got a list! How do we get one of these new fangled data types? Let's make a helper function...\n\nA function like this allows us to turn a regular list into a NonEmpty list, by returning a Just NonEmpty for a list with one or more items, or a Nothing if the original List is empty. This still means we have a possibility of failure (expressed by the Maybe), however our head function expects that to be dealt with elsewhere before it gets involved with the data, and is thus total whilst always returning a value.\nLike all somewhat trivial examples, perhaps this seems like a lot of work for nothing (plus the overhead of dealing with a new datatype) - however this concept of doing a piece of validation once, capturing it in the type, and then having a much simpler time dealing with it onwards is very powerful indeed.\n(btw, Haskell actually has a NonEmpty list type, in Data.List.NonEmpty, but it's more fun to make our own)\nAnyway, that's quite enough for now I feel.\nMake sense? If not, get in touch!\nFurther reading:\nAre your functions total?\nData.Maybe\nData.List.NonEmpty\n","id":"https://danieljharvey.github.io/total-functions/","title":"Why The Hell Should I Care About Total Functions?"},"https://danieljharvey.github.io/typechecking-pt1/":{"body":"So I've been getting really interested in typechecking, and well, the best way\nto learn is to try and explain it in words, so here we go.\nThere are many kinds of typechecking, but today I want to explain a variation\non Hindley Milner (I've also seen it called Damas Milner, please feel free to\nping with the actual truth, fact fans). This kind of type system is the kind\nyou'll find under OCaml, Elm, Haskell and Purescript, although each language has their own variations (and in the case of Haskell, a terrifying number of extensions to it).\nA working example\nWe're going to start by typechecking the simplest stuff, and then build up\nfeatures as we go. There are three stages to our algorithm, Elaboration,\nUnification and Substitution. We'll introduce them as we need them.\n\n🥚 Elaboration 🥚\nHere go through the expression we'd like to typecheck, marking each\npart of the AST with the thing we think it is (and if we don't know, we sort of guess). We'll also produce\na set of constraints about the types we've worked out (a constraint is\nsomething like \"I don't know a or b are but I know they're the same\nthing\")\n\nLiterals\nLiterals are static values declared in code. Our toy language has the\nBoolean, Integer and String types. As this means there is no ambiguity\nbetween them, we can work out their types in the Elaboration stage alone.\n\nThe values are on the left in black, the types on the right in blue. No weird surprises here, hopefully.\nLet bindings\nIt is nice to be able to give things names, so we should have some let bindings\nin our language. These allow us to introduce a new concept - the typechecking\nenvironment. A let binding has two sub-expressions - the first is the one\nthat gets \"bound\" and assigned to the name, and then the body, which can refer\nto the bound expression by name.\n\nIn this example, our environment (shown in green) is initially empty, but as we were able to\nelaborate the type of a as Integer, the environment when typechecking the\nbody also includes a == Integer. However, this has no effect on the type of\nthe whole expression, as the body of the let binding is True which we know is of type Boolean.\nVariable\nIt's all well and good making variables, but it's even more useful to refer to\nthem later. Given a typechecking environment that already knows about b, we\ncan look it up:\n\nIf it's not there, we\nthrow a type error and tell the user they've made a typo or something. If it\nis, then we return the type from the environment.\nIf / Then / Else\nAn if statement in our language is an expression, meaning it must return\nsomething from both the then and the else branch. It contains three\nsub-expressions, one for the predicate we are testing (which must be of type\nBoolean), one for the then branch, and one for the else branch.\n\nBecause each of these sub-expressions are literal values, we can elaborate their\nvalues as we did above. The return type is Integer, as that is the type we\nhave worked out for the then branch (it could as well be the type of the\nelse branch, they should be the same).\nHow do we ensure all our rules work out? That's the job of the constraints that\nwe have generated (shown in red). We have one that ensures the type of True matches\nBoolean, and another that ensures the types of the then and else branches are the same.\n\n🥚 Unification 🥚\nNow that we have constraints, we need to check they make sense. Unification in the context of typechecking is about smashing two things\ntogether and seeing what we learn.\nThe outcome of unification is either a type error or a set of substitutions, such as \"replace all c values with String\".\n\nHere the two things are the same in both cases, so everything is fine and we\nlearn nothing new.\n\nLambda\nA lambda is a function abstraction. When elaborating lambdas, we don't know what the type of the argument will be. Different type systems have different approaches to this problem.\nOne solution is to make the programmer annotate the argument with a type (ie,\n\\(a: String) -&gt; ...). However, Hindley Milner typechecking is all about\nminimising type annotations, so instead we'll guess it. We do this by creating a fresh unknown type variable called a\n\"unification variable\". Each of these should be unique within the typechecking,\nso they often use numbers with an internal counter to generate fresh ones.\nWe're going to use the unimaginative unknown-1.\n\nThen, when we elaborate the body of the lambda, we add a == unknown-1 to the\nenvironment, which makes typechecking the variable a straightforward, making\nthe type of the whole lambda unknown-1 -&gt; unknown-1 (the -&gt; meaning \"a\nfunction from a to b\")\nFunction application\nElaboration\nWhat's the use in functions if we can't apply values to them? Given the id function has already been defined, let's apply a value to it.\n\nSince the function type is unknown-1 -&gt; unknown-1, we apply Boolean to it,\nby creating a constraint between the first unknown-1 and Boolean. Then the\nreturn type from elaboration is the second half of the function type (also\nunknown-1).\nSurely it should be Boolean though right? No, but also, yes, but also, it's\ncomplicated...\nUnifying our new constraint\nLet's look at the constraint we've generated during elaboration.\n\nAs we briefly mentioned earlier, we unify values to learn things about them. Because unknown-1 is a unification variable, it represents an unknown thing that we are trying to find out more about.\nUnifying it with Boolean tells us unknown-1 is actually Boolean, and therefore we can substitute any instance of unknown-1 for Boolean.\nApply the substitution\nWe apply a substitution by changing all instances of one thing in a type for another. Applying a substitution to the result of elaboration gives us our final type,\nBoolean\n\n\n🥚 Substitution 🥚\nAssuming we had no type errors in the previous step, then\nsubsitution is the process of taking all the things we have learned and\napplying them to both to expression and to the other substitutions.\nFor example, if we have learned \"a is an Integer\" then we can change any a\nvalues in our expression to Integer, and also change the substitution \"c\nis a pair of a and b\" into \"c is a pair of Integer and b\".\n\nA bigger example\nTo see Hindley Milner typechecking in action, here is a slightly bigger\nexample. Here we'll see how we can get full type inference without a type\nannotation in sight.\n\nWe start by elaborating the function argument, a. We have no idea what it is,\nso we create a unification variable, unknown-1, and use that instead.\nThen we move onto the body of the lambda, an if expression. The predicate\nexpression is a. Fortunately, we already have the type for a in the type\nenvironment - so we can grab it. We don't know what unknown-1 is yet, but we\nhave another piece of information on our side - the predicate for an if must\nbe a Boolean. We express this by creating a new constraint unknown-1 == Boolean.\nThe then and else expressions are both literals, so we can infer those\nquite simply, making Integer the return type of the if expression. There is\nalso another constraint here, that both branches should have the same type -\nInteger == Integer.\nUnifying our new constraints\nWe have two contraints from elaboration.\nFirst Integer == Integer, which teaches us nothing (but does type check).\n\nSecondly unknown-1 == Boolean gives us a substitution.\nApply the substitution\n\nSo, therefore, the type of \\a -&gt; if a then 1 else 2 is Boolean -&gt; Integer.\nThat's all folks\nThe writing that is, that is the end of the writing. There is a bunch more to\nHindley Milner typechecking, we've neatly sidestepped any complicated\npolymorphism, however rest assured that it doesn't make things too much\ncomplicated which is nice. I might write about that in future, so given the\nglacial pace of my writing, look forward to a sequel in 2024.\nMake sense? If not, get in touch!\nFurther reading:\ngiml\nWrite you a Haskell\nmimsa\n","id":"https://danieljharvey.github.io/typechecking-pt1/","title":"Hindley Milner typechecking by example"},"https://danieljharvey.github.io/typeclasses-alternative/":{"body":"Let's think about things that may or may not happen (again, I know, I'm sorry).\n\nA classic datatype, that we can use for expressing either Some Sort Of Value or The Entire Concept Of Failure. We can use it when getting the first item of a list, which may or may not actually exist.\n\nIf there IS a first item in the list we get the item wrapped in a Yeah, if not we get Nope.\nWe can make another very similar function for getting the second item as well...\n\nNow let's say that for some entirely incomprehensible reason, we'd like the second item in the list, if not, the first item. What would that function look like?\nFirst solution\n\nDoes it work?\n\nIt bloody does! Lovely stuff. Let's all go home and put our feet up, we've nailed it.\nOK. But hang on, that naiveImplementation function does seem a bit much though, especially if we start adding more cases to it. Plus that name kinda suggests, well, that the function might not represent the best way to go about this.\nWhat if there was a typeclass that was designed to make things like this easier to deal with?\nLet's meet Alternative!\nDefinition\nWhat does ghci have to say about this so-called Alternative?\n\n\nOK. So the most interesting thing is that any Alternative first needs to be a valid instance of Applicative first.\nSecondly, we can get one just by defining empty and &lt;|&gt;. What are those then?\n\n\nempty is the identity element. This is a bit like the mempty in Monoid - it is a value that when added to the datatype, does nothing to it.\n\n\n&lt;|&gt; is sort of an or for data types. Given two values, it returns the first valid one, as such. What valid means depends on the datatype, but usually that value won't be the same as empty.\n\n\nIf you're looking at this and thinking \"This Seems Very Similar To A Monoid\" then, yes, it sort of does, consisting as it does of one Smash Things Together function and one Sort Of Nothingy value.\nLet's define it for our exciting Perhaps type.\nInstances\nBefore we can have an Applicative we'll need a Functor instance. This one runs the function over the value if it's there, if not, it does nothing at all.\n\nOK. Great stuff. Let's make an Applicative instance next. The pure instance just wraps whatever it's passed in a Yeah. The &lt;*&gt; (or apply) function is written so that if we have a function inside f and a value in a then we'll get the function f applied to a and wrapped in Yeah, if not we'll get a Nope.\n\nYeah? Yeah.\nOK. Here is the exciting part:\n\nLook at that! An exciting Alternative instance. Nope is our empty (or identity) value, and our &lt;|&gt; function returns the first value if it's a Yeah (which represents valid data in the context of our Perhaps datatype), if not it returns whatever the second value is.\nLet's use it to make some contrived code ever so slightly smaller and more difficult to understand.\nBetter Solution\nHere is our Get The Second Item, Or If That Doesn't Work Out Then Let's Settle For The First Item function.\n\nMuch easier to understand! It almost looks like second || first, which I like a lot.\nDon't trust me?\n\nSee! And you doubted me!\nNow, that seems like a lot of instance writing for not much, but often the place you'll find Alternative is in stuff like routing for front end applications. Let's have a look at something like that:\nRouting Example\nHere's a datatype to describe all the pages in a completely fictional and somewhat limited website...\n\n...some type aliases to make the type signatures we're about to write easier to understand...\n\n...and a (rather basic) function for taking the passed url and matching it to the page we want to be looking at:\n\nWhat's going on here?\n\n\nFirst, it converts our match and url strings to lowercase by mapping toLower from Data.Char over.\n\n\nThen, it uses isInfixOf from Data.List which returns a Boolean telling us whether the match string can be found inside the url string.\n\n\nIf so, return the passed Route wrapped in a Yeah, if not, return Nope.\n\n\nGood stuff!\nAnd now here is our actual logic, that uses the matches function to find out where we should navigate to in our excellent website.\n\nAssuming we always want to navigate somewhere, we can also make a wrapper function that returns a default Route if we do not find a valid one.\n\nLet's use it to navigate to the Gallery, which I have no doubt is a very good example of the genre.\n\nOr default to the Index when we're passed a load of old rubbish.\n\nWe're basically front end development experts now. Great stuff.\nWrapping Up\nThe Control.Applicative documentation describes Alternative as a \"a Monoid on applicative functors\", and perhaps I could have just led with that and saved us all a bunch of trouble. This kind of typeclass mainly gives us a nicer syntax so that we can bend our code to closer match the domain we are working in, which is generally a Good Thing in my book.\n(You may notice we've done a lot of work here defining Perhaps when we could have just used Maybe and saved ourselves writing a lot of instances but it's my blog and I can do what I want.)\nMake sense? If not, why not get in touch?\nFurther reading:\nControl.Applicative\nAlternative and MonadPlus\n","id":"https://danieljharvey.github.io/typeclasses-alternative/","title":"Typeclasses - Alternative"},"https://danieljharvey.github.io/typeclasses-applicative/":{"body":"In my learning of Haskell and all the associated mathematical stuff attached to it, one of the tougher conceptual cookies to crack has been the Applicative Functor.\nComing from a background of fairly functional Javascript, functor is a very easy sell - it's array.map. Easy. If there's a thing in the box, do something to the thing, if there's nothing in the box, don't freak out about the lack of things or explode. Great!\n\nThese functions can even return lists of their own...\n\n\nTrying to understand the actual point of an Applicative Functor, especially to my Javascript-addled mind, was much trickier. The first explanations I heard were something like:\n\"Oh, applicative? It's for taking a function that in a box, and a value in a box, and then combining them to make a new value which is also in a box\"\nNow I am all up for putting values in boxes. Bloody love it. But functions? What are you playing at? Ridiculous talk.\nCould it help us with our list changing exercise? Sort of...\n\nOK, so instead of a list of lists, we have one list (and one new terrifyingly meaningless infix operator, &lt;*&gt;, wonderful). Seems like a lot more work too, and we could probably just have used concat on the result and saved ourselves a whole load of intellectual soup. Sure. I get it. Terrible example. I've let us both down. I'm sorry.\nLet's see if we can find a slightly more helpful example.\n\nThis data type is for describing calculations. The a contains the current total, and the [String] is used to describe what is happening. We've deriving standard Eq and Show instances for it, plus making our own fairly basic Functor instance that, as you might expected, maps the function f over any a inside the datatype and leaves everything else alone like a good functor should.\n\nWe also have this function, which we can use to print out the answer with our working.\n\nLet's try it out.\n\nSeems very reasonable.\nLet's try some mapping.\n\nNot so good. The answer is correct as we ran a +1 function over the 1 to get 2, however we were unable to add anything to our log and thus the string output makes no sense. Perhaps Functor is not powerful enough for our task.\nLet's give Applicative a go. Here's one of those functions in a box we were talking about. This time we can also include a description of what the function does.\n\nWe'll need an Applicative instance for our datatype too. What does that look like?\n\n\nThere's some pretty interesting jumping off points in there (such as the whole concept of lifting, but we'll come back to that), but fortunately we only need to implement two functions for this typeclass.\n\npure - which takes an a value and returns a sort of default value for that datatype. This is used internally in constructing new values.\n&lt;*&gt; (called apply IRL) - this takes one wrapped function and one wrapped value and combines them.\n\nConfused? Me too! Let's give it a pop.\n\nOK. So pure is reasonably straightforward - it just makes the most basic CalcFace imaginable and puts whatever a we pass inside it. The other function is a bit trickier though. Basically we are taking the function f and applying to a, but also taking the [String] called operation and plopping it on the end of the [String] named value.\nSeems weird? Sure. Let's see it in action though.\n\nNice!\n\nGreat stuff. The key here is that not only have we acted upon the values, the way that functor did, but we have also done something to the structure of the datatype too (in this case, adding to the list of operations). This seems trivial when the operators are just basic mathematics, but if the functions we are running are multiple database operations and calls to other servers, then you've got yourself the start of tidy little pure functional logging solution there, son.\nAnyway. This barely scratches the surface, but hopefully gives you the start of an intuition for these things. Applicative does lots of things. Go find them!\nMake sense? If not, why not get in touch?\nFurther reading:\nFunctors, Applicative and Monads in Pictures\n","id":"https://danieljharvey.github.io/typeclasses-applicative/","title":"Typeclasses - Applicative"},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"body":"Let's talk about things that could be one thing, or indeed could be another thing altogether.\n\nThis could be a This with an a inside, like a String.\n\nOr indeed a That with a b inside, like an Int.\n\nNow hopefully you are now thinking - \"Oh please, I do hope we map a function over one of these values soon\" - and worry not, we absolutely bloody can.\nMappity Mappity Map\nLet's really push the boat out, and add one to the value inside.\nFirst we'll need a Functor instance. Hopefully nothing too surprising here.\n\nNow we can map away to our heart's content:\n\nNice.\nBut what about `This \"Egg\"``? I'd like to get at that egg. Perhaps eat it.\n\nCan we do that with Functor?\n\nI'm afraid not. Looking back at our Functor instance we can see that the fmap function only lets us map over the values inside That, leaving poor This and our lonely egg very much map-less. But fear not! We have another weapon at hand that will let us get at it.\nEnter....Bifunctor!\n(cue lightning, thunder, explosions and sounds of a large crowd who are clearly quite impressed).\nDefinition\nLet's ask ghci what's up.\n\n\nOk. Three functions in here, and it looks like we can make something a Bifunctor by implementing instances of both first and second or just bimap.\nLet's take a look at them.\n\n\nfirst :: (a -&gt; b) -&gt; p a c -&gt; p b c - this takes a Bifunctor that may contain some a and c values, and a function that turns an a into some sort of b. It then runs the function on the a value, turning it into a b value. Sort of like doing an fmap over the a inside This from earlier. Pretty nice. Tl;dr - it's fmap but over the left value.\n\n\nsecond :: (b -&gt; c) -&gt; p a b -&gt; p a c - this takes a Bifunctor with an a and a b and a function that turns the b values into c values. In the case of our Things datatype of This and That, this let's us get at the That values, which we could anyway so big whoop. Tl;dr - it's our pal fmap again.\n\n\nbimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d - this takes a Bifunctor that may contain a and c values, and runs a function over both sides. It's doing first and second at the same time.\n\n\nOK. If you understand Functor there's hopefully nothing out of the ordinary going on here. Let's slop an instance together and get to work on that delicious egg.\nInstances\nLaziness dictates that we should define bimap because it is one function instead of two.\n\nSeems fairly sensible hopefully. Let's give it a spin.\n\nHooray! Although we defined bimap we got first for free, and that egg was pretty nice.\nWe can still map over the right hand value too!\n\nAgain, nice.\nTuples, Pooples\nAlthough our Things example is about sum types, we can also use it on product types like a Tuple, and use Bifunctor to mess with either value as we please.\n\nNow, we could go ahead and show you first and second but I think you can work out what's going to happen, so let's go absolutely bonkers and race straight to bimap.\n(but first, a helper function. Nothing untoward - it merely returns the first thing you give it and ignores the second.)\n\nNow we can turn our Tuple into a bestselling novel.\n\nI Bet You Did Not See That Coming.\nFor a bonus point, why not try and define first and second for Tuple types using bimap and myConst? Go on. You'll have a great time, I absolutely promise.\nThat's all, folks\nSo although helpful with Tuple and Either types, Bifunctor isn't particularly mindblowing, but comes into it's own when we combine it with Contravariant to make Profunctor. More on that in the future though!\nFurther reading:\nThe Extended Functor Family (video)\nData.Bifunctor\n","id":"https://danieljharvey.github.io/typeclasses-bifunctor/","title":"Typeclasses - Bifunctor"},"https://danieljharvey.github.io/typeclasses-contravariant/":{"body":"Let's think about Predicates.\n\nWhat the hell is this?\nOK. So it's a newtype. What is basically does is let's us take some sort of value (here, any function from a -&gt; Bool) and make a new type out of it so we can give it typeclasses and do magic shit to it.\nSo let's say we have a basic function that takes a number and let's us know whether that number is over 3.\n\nGreat!\nTo put this into a newtype (our Preddy one, to be exact) - we do this:\n\nThe type has changed - the a in a -&gt; Bool is Int so we get Preddy Int. We don't need to specify the Bool anywhere because that's sort of implicit in the Preddy-ness.\nOK. I get it, you're worried. My function is gone for ever. Can I get it out again? Sure.\n\nthreePred and isOverThree are completely the same thing. So now we're comfortable this newtype thing is basically doing nothing awful to our code, what it is good for?\nOh yeah. We said earlier. Because Preddy is a datatype of it's own we can make typeclass instances for it. Let's make a Contravariant instance, for no other reason than this being the name of the post and we're a long way into it without doing anything particularly useful.\nWhat will we need for doing that then?\n\nIf are typing along with all this and get an error, please skip to the bottom of the page for some useful links, however if you have the contravariant library floating around or are just happy to take my word for it then GREAT! You'll see this:\n\nThe key thing to look when starting out is this MINIMAL part - as it means the only functions we need to worry about for the time being.\nSo, contramap is it. What does this do?\nIt takes a function from (a -&gt; b) and then it takes an f b and returns an f a. Sure.\nWhat?\nAre you out of your fucking mind? How do I turn b into a using (a -&gt; b)?\nIs this...a backwards functor? Can I implement undo on all my functions? Is the special magic Haskell sauce I've been waiting for?\nSo it turns out no.\n\nSo a regular functor is actually a covariant functor which I guess means forwards functor. When we map over it, we changing what happens after it. Hence if I have a Maybe String and fmap a String -&gt; Int function like nameLength over it I get a Maybe Int and all is well in the world.\nHowever our pal Preddy, unbeknownst to him, is about to become a contravariant functor which sort of means backwards. What this means is if he's waiting for an Int to see if it's over 3, we can contramap that same String -&gt; Int function nameLength over it, and instead Preddy is waiting for a String so he can tell you whether the String has over 3 characters. The map happens beforehand, basically. That's how an (a -&gt; b) function turns a Preddy b (predicate waiting for a b) into a Preddy a (predicate waiting for an a).\nSeems weird? Sure. Let's look at an example.\n\nThis looks a lot like fmap, except our new f function happens BEFORE the p function that is already in there.\n\nHere we've turned our Preddy Int function overThree into a Preddy String function using a String -&gt; Int function and contramap.\nLet's use it!\n\nGreat! Now we can use it to see if words are Just Too Long.\nAll this wrapping and unwrapping seems a lot of work for that, but what if we start using contramap for more?\n\nHere are Steve and Lou. They are, at least syntactically, people.\nLet's use mathematics to judge whether their names are too long.\n\nExcellent! That will show them.\nYou will note that here we've somewhat rushed and combined the contramap-ing and unwrapping into one function. This was mostly to show that when you come to use these things, it doesn't need to be quite as laborious as our broken down examples above. Hopefully you can follow, the key thing is that (nameLength . name) means \"put the value into name and the pass the result to nameLength\".\nContravariant doesn't show up a huge amount on it's own, but it comes into it's own as part of Profunctor (lightning flashes, thunder, excitement!) which no doubt we'll flop towards at some unspecified future moment.\nMake sense? If not, why not get in touch?\nFurther reading:\nThe Extended Functor Family (video)\nData.Functor.Contravariant\nNOTE: If you happened to get this error:\n\n...then you will need to install the contravariant package from Hackage. I'm not going to go into Haskell package management at this point but here is a good starting point: Practical Haskell - Getting Started. It's all going to be fine, I promise. The documentation isn't great but the tools are pretty nice.\n","id":"https://danieljharvey.github.io/typeclasses-contravariant/","title":"Typeclasses - Contravariant"},"https://danieljharvey.github.io/typeclasses-eq/":{"body":"Let's think about horses. There are three kinds of Horse:\n\nLet's make a function to check whether two Horses are in fact equivalently sized.\n\nLooks like a classic. Let's run it!\n\nShit!\n\nThat's terrible news. What's wrong here? Apparently, we need to make an instance of the Eq (short for 'equality') typeclass for Horse before they can be compared. What's the Eq typeclass?\nWe can find out more by firing up ghci, the GHC repl.\nYou should see a prompt with the following:\n\nIf we enter :info Eq, we get the following:\n\nIt shows there are two functions in the Eq typeclass, == and /= (equals and not-equals), and that a \"minimal\" definition of Eq only needs one of those.\nLet's start again and make a better horse.\n\nLet's not make the same mistake this time - let's make an instance of the Eq typeclass for them. We are going to implement == which has a type of a -&gt; a -&gt; Bool.\n\nOK, seems fine. We've listed all the times two BetterHorse are the same and used _ == _ = False to mean \"anything else is not equal\" to save ourselves listing every alternative.\n\nNow our BetterHorse comparing function works. Let's give it a go.\n\n\nAll seems to be fine here. We even get the /= function for free by defining ==.\n\nIf you're thinking \"this seems laborious\", you'd be right. Fortunately, for basic data types like this, we can simply auto-generate an Eq instance in the data definition like this:\n\n\nGreat!\nMake sense? If not, why not get in touch?\nFurther reading:\nData.Eq\n","id":"https://danieljharvey.github.io/typeclasses-eq/","title":"Typeclasses - Eq"},"https://danieljharvey.github.io/typeclasses-foldable/":{"body":"Let's think about sets of things that we want to make into one thing.\nA classic example might be a list of numbers that we want to add up.\nIn Javascript we might do something like this:\n\nOr perhaps we could get the maximum of the same list.\n\nDefinition\nSo in Haskell we have the very similar foldr with the following signature:\n\n\n(there is actually loads more but these are the key ones)\n\nHere are the above JS functions using foldr.\n\n\nNot hugely different from the Javascript equivalent really. If you squint you can see the combining function, the initial value, and the data itself.\nfoldMap works a little differently. Instead of taking a custom combining function and using that to combine the items together, it takes a a -&gt; m function (where the m in question is any Monoid instance). It uses this to turn each item into a Monoid, and then uses the &lt;&gt; and mempty functions for that Monoid to combine the items.\nHere's a newtype I made earlier: MySum. It's Monoid instance adds numbers together when combined.\n\nNow we can use foldMap with the MySum constructor to add up a list of numbers.\n\nGreat stuff! Now our answer is still wrapped up in a MySum, but it's easy enough to take it out.\n\nExcellent!\nThis seems laborious, but actually MySum isn't my invention, I've just stolen a thing called Sum that comes with the Haskell Prelude. Therefore we can just do getSum $ foldMap Sum [1,2,3,4,5,6] to Monoidally combine the list items.\nIt also provides a similar invention for multiplying numbers called Product that works like this:\n\nFolding can also capture logic, here we are using foldMap to check all of a list is true.\n\n(I have also stolen MyAll, it is usually called just All. You can see the pattern here.)\nWe could also very easily make a MyAny type which uses or (ie, ||) which we could use to return a True whenever a single one of a collection of Bools happens to be True. You might want to have a think about what the mempty value would be for that to work though. That's up to you.\nAnyhow. I'm bored of typing now so I guess this is it for this one.\nMake sense? If not, why not get in touch?\nFurther reading:\nData.Foldable\n","id":"https://danieljharvey.github.io/typeclasses-foldable/","title":"Typeclasses - Foldable"},"https://danieljharvey.github.io/typeclasses-functor/":{"body":"Let's think about things that might or might not happen.\n\nPerhaps is a datatype that we can also use as a container for other data (by holding it inside a nice Yeah), or to show that we have no data with Nah.\nLet's put things in it.\n\nGreat job. John is having a nice time there. How might we express an absence of John?\n\nOK. No Johns here.\nSo what if we have a function that receives something wrapped in a Perhaps and wants to do stuff with it.\nI guess we have pattern matching, so we can use this to pull stuff out and do things with it. Let's add some question marks to this name, because that is always a valuable thing to do.\n\nOk. Seems good. What about adding a simple exclaimation point instead? (Remembering of course that anybody more than one at any point is a sure sign of insanity.)\n\nOk. Sure. So far, so functional. Feels like we're repeating ourselves though. What if we could abstract out away the unwrapping-and-then-wrapping-again and the function itself? Well sure we can! That typeclass is called Functor. Let's open ghci and take a look.\n\nHere's the definition:\n\nLooks like we can implement it by just using fmap. And that type signature kind of looks like what we want (if we squint very hard indeed). It's saying take a function of any a to any b (ie, (a -&gt; b)) and then pass me a functor with an a in it (ie, f a) and I will return the same functor but with the b from your function in it (ie, f b). So basically fmap is the \"unwrapping-and-then-wrapping-again\" we talked about earlier. Sounds good. Let's implement it.\n\nLooks great. The first thing you'll notice is that the fmap for Nah doesn't do anything. That's because although our Yeah can contains some a, our Nah contains nothing at all so cares very little for our a -&gt; b function. However, look! The second line is unwrapping the a from the Yeah, and then making a new Yeah b (because we make a b by running f, which is our a -&gt; b function). Therefore we can throw any old function at this and we should have a Nice Time.\nThis function for instance, is used on a String to make the caller look somewhat unhinged.\n\nBut using our new Functor instance means we can run it on our poor friend john from earlier, even though he is wrapped up in all that Yeah.\n\nSorry John.\nWhat if we run the same function over a Nah? Does everything explode?\n\nNah. Seems fine. Nah ignores the function altogether, as it has no a in it, so no interest.\nOk. So this seems pretty great. There is one thing to know about Functor however that can be a little bit brain bending at first, and that's the idea that they can be \"lawful\". That is to say, that when you fmap over something, it doesn't also break that thing, and that it unwraps and wraps in the right way. Haskell's type system can help you make sure your fmap has the right types, but it can't enforce that your Functor makes sense I'm afraid. That's up to you.\nThe first law is called Identity. It means that if you fmap using an Identity function, nothing will change. This is a trick I suppose - the Identity function looks like this:\n\nSo running it on anything does nothing - the Identity law is basically checking the Functor is up to no funny business. Our Perhaps functor is OK, but what about this chancer?\n\nIf we fmap identity Nerp we get Nerp, so that all seems fine. However, if we fmap identity Yeah \"Detroit\" then we also get Nerp which is an absolute bloody disaster. This functor is broken. Put it straight in the bin, and set the bin on fire.\nThe second law is called Composition. It means that if we fmap one function over our Functor and then fmap a second function over the result, it would be the same as combining the two functions and doing a single fmap.\nI'm sorry. What?\nOK, let's have an example of that.\nTherefore, if as well as our rather worrying \"exclaim\" function, we have one for shouting as well (don't be distracted by the &lt;$&gt; for now, we'll come to it in future...)\n\n...we can combine it to make one terrifying function...\n\n...which is exactly the same as this:\n\nThe Composition law just makes sure these are the same thing, so again, no funny business can take place.\n\nAnyway. This is just one introduction to a kind of functor. In short, hand-wavey terms:\n\"A functor is a thing that lets you safely crap around with the values inside it without breaking the thing itself\"\nA few important notes and disclaimers:\n\n\nThere doesn't have to be just one a in the functor for this pattern to work. Another goto example for this is List, which can have absolutely loads in. In that case, the fmap runs the (a -&gt; b) function on every item in the list, like array.map from Javascript, so it takes [a] and turns it into [b].\n\n\nThere are functor instances for many datatypes such as IO where the a inside might represents a value that isn't there yet (like perhaps it will come from some user input etc). Therefore doing fmap on such a datatype is just saying \"change the a inside to b whenever it happens to turn up\", like \"when the user types their name, change the string to have lots of exclamation marks so they look like a weirdo when we later print it back for them\" or similar. This kind of idea can get a bit brain bending but once it settles it's sort of magical to know you can crap around with the future just like you're working with an array.\n\n\n\nThe Perhaps data type we have invented is really called Maybe and it's all over the place. More on that another time, perhaps.\n\nThat's quite enough for now.\nMake sense? If not, why not get in touch?\nFurther reading:\nFunctors, Applicative and Monads in Pictures\n","id":"https://danieljharvey.github.io/typeclasses-functor/","title":"Typeclasses - Functor"},"https://danieljharvey.github.io/typeclasses-monad/":{"body":"The Monad is one of the most infamous things around Haskell, and indeed functional programming, and so writing tutorials around them has become something of a cliche. Let me be clear - I really did try and avoid writing one, but it's gotten to the point that it's difficult to talk about the other more interesting stuff without at least mentioning it.\nTo try and avoid falling into the regular pitfalls, we are instead going to define the simplest possible Monad, and then look at some examples of them in action. Hopefully you'll see that Monads aren't that complicated or interesting - it's actually the properties of the different datatypes that provide all the different behaviours and make it interesting.\nId\nSo. This is Id.\n\nIt is a container that contains any value that we give it.\n\nWhich we can take out at any time with getId.\n\nEvery Monad must first be a Functor, so let's define that for Id.\n\nIt must also be an Applicative.\n\nGreat stuff. Now we've got Functor and Applicative, we only need one more function to make a Monad instance, and thats bind (or &gt;&gt;=). Bind takes an Id a value, and a function of signature (a -&gt; Id b) that takes the value inside, does something to it, and adds another layer of Id. It then removes the extra layer, leaving us with Id b. In some places it's called flatMap, as it maps over the value and then flattens it.\nFor Id, it takes the value out, and then runs the function on it.\n\nPretty dull. Let's plop a few bind functions together. We're using Do Notation, which is a way of making using Monad values easier.\n\nOK! Not very interesting to be honest. Id doesn't really do anything other than make adding numbers up more confusing. Let's look at other Monad instances and try and see what they do.\nMaybe\nWe're going to use the Maybe monad to chain together a head-type function that returns the first item if it's there.\n\nNote that as soon as we get a Nothing, the calculation stops, as such.\nEither\nWe're going to use Either to do some string validation. Here is our error type:\n\nAnd here are a series of string validation functions that all return either Right String if the string is OK, or Left Error if not.\n\nThis validate function chains all the validations, returning either the String or the first Error.\n\nList\nThe List monad is interesting because the flattening effect of bind means functions that turn values into more lists get flattened into one big list.\n\nReader\nThe Reader monad is used to pass configuration around a program. Here we will define a type for Config and a value for it.\n\nThese functions use the Config value in the Reader to make strings, using the ask function to access the config.\n\nThe configReader function shows how we can combine different Reader instances with bind\n\nWriter\nThe Writer monad accumulates a log as it does computations, by using the tell function to add items.\n\nIO\nThe IO monad is a very interesting one. Each time we run bind, the value that comes out can be affected by stuff like user input, system time, or other side effects. This is how we can write effectful code in a relatively safe manner. This is how we write code like this that actually interacts with users.\n\nThat is all. I feel this somewhat rushes things a lot, and there is a lot to chew on, but hopefully these examples will help you build up an intuition for how these work.\nFurther Reading:\nYou've Been Using Monads\nLots More Of This Kind Of Thing\n","id":"https://danieljharvey.github.io/typeclasses-monad/","title":"Typeclasses - Monad"},"https://danieljharvey.github.io/typeclasses-monoid/":{"body":"In an exciting previous episode, we talked about the Semigroup type class that is used for smashing two things together.\nToday we're going to talk about the Monoid typeclass, which is a way of generalising a collection of things that can be combined together. Seems very similar, but the important difference between combining two things, and combining any number of things, is that that number of things might be zero things.\nTherefore as well as the append function &lt;&gt; we will need a way of expressing what no items looks like. Seems weird? Yeah, it kind of is. Some examples may help.\nCombining Lists\nWe need to combine a List of other List values, and we're all functional programmers, so let's go ahead and make a function for doing that.\n\nIf we use it on an actual value, then great job.\n\nBut what about if we use it on an empty list?\n\nAhh shit! We get this:\n\nThat's not great. Looks like we're going to need an empty value to use for empty lists.\n\n\nSo here the empty value is [] - and having this value is what means we have a Monoid as well as a Semigroup.\nDefinition\nWhat does ghci say about Monoid?\n\n\nOK. So firstly, whatever we want to make a Monoid must also be a Semigroup.\n(Incidentally, the terminology of the relationship between these two is that Semigroup is a superclass of Monoid, meaning anything that is a Monoid is also a Semigroup. Conversely Monoid is a subclass of Semigroup. You'll notice many of these relationships amongst Haskell classes, like between Eq and Ord, and between Functor and Applicative. More words! More confusion! Great!)\nSecondly, the only function we need to define (because of MINIMAL) is mempty - which defines our empty element (we also need mappend, but this is the same as &lt;&gt; and is supplied by our Semigroup unless we have a burning desire to write another one).\nTherefore, if we take a Semigroup and plop an mempty function on it too we can have a Monoid. Clear as mud!\nMore about mempty\nThe important test for this mempty value is that when we mappend it onto our Monoid it does nothing whatsoever.\nHere's an empty element for List...\n\n...and here it combined with another List and achieving absolutely nothing.\n\nDefining a List Monoid\nSo we need to make a List Monoid then?\n\nAn operation called mappend for combining two values - here ++ will do the trick.\nAn empty value called mempty - here we would use [].\n\nHere goes:\n\nGreat stuff!\nWe get mconcat for free\nOnce we've defined that, we get mconcat (or rather our nice combineList1) for free! All it does is a fold, starting with mempty and then applying mappend to each element in the list. Great!\nCombining Numbers\nThe empty element is interesting on our number Semigroup instances from before too.\nAddition works like this, with an empty element of 0.\n\nWhy zero? Because adding 0 to a number does nothing!\nMultiplication is not the same though.\n\nHere the mempty value must be 1, because multiplying anything by 1 changes nothing.\nSo What Does It All Mean?\nThis all seems a lot of work to get a free mconcat function, but the Monoid typeclass really comes into it's own when used with stuff like Foldable. Just by adding this empty value we get a hell of a lot more \"for free\", as such.\nMake sense? If not, why not get in touch?\nFurther reading:\nData.Monoid on Hackage\n5 minutes to Monoids\nMonoids tour on School of Haskell\n","id":"https://danieljharvey.github.io/typeclasses-monoid/","title":"Typeclasses - Monoid"},"https://danieljharvey.github.io/typeclasses-ord/":{"body":"Let's think about moods. Psychologists all agree there are only 5 real emotional states.\n\nWhich one is better? Is Great better than Awful?\n\nShit!\n\nThese cannot be ordered! We need to implement the Ord typeclass (short for \"ordering\") so that we can compare these values and sort them.\nWhat will we need to do that then?\nWe can find out more by firing up ghci, the GHC repl.\nYou should see a prompt with the following:\n\nPrelude is telling us that we've loaded the Haskell Prelude, a standard library of functions. Ord is part of that, so let's get some info.\nEnter :info Ord into the repl (and press enter). You should see something like this:\n\nThis is a list of functions that the Ord typeclass implements. Looks like hard work. What's interesting here?\nFirstly - the Eq a =&gt; constraint means that we can only define an Ord instance for something that has an Eq instance. I guess if we can't tell if two values are the same, how can we dream of putting them in some sort of order?\nSecondly - the slighly cryptic {-# MINIMAL compare | (&lt;=) #-} line is telling us that we can define Ord by either defining the compare or &lt;= functions. Haskell can generate the other functions by using either of these ones. That's great news because hard work is hard and we don't want to do hard work.\n\nWe're auto-generating the Eq because why have a bad time. Let's make our Ord instance.\n\nWe're implementing it in terms of &lt;= as it returns a Bool which is more straightforward than the Ordering datatype that compare uses).\n\n_ &lt;= Fine = True means that all values are equal to or less than Fine.\nWorse &lt;= PrettyAverage = True means that Worse is less than or equal to PrettyAverage.\n_ &lt;= _ = False means any other combination returns False.\n\nEven though we've only implemented one function, since the others can defined using it we get all of them for free:\n\n\n\n\nWe also get to use any function that requires an Ord instance for free, like sort from Data.List, which has the following type signature:\n\nThis means \"if you pass me a list of any a which is orderable, I can return you a sorted list\". Thanks!\n\nGreat job!\nStill seems like hard work though, can we auto generate this typeclass too? Yes!\n\nNice.\nMake sense? If not, why not get in touch?\nFurther reading:\nData.Ord\n","id":"https://danieljharvey.github.io/typeclasses-ord/","title":"Typeclasses - Ord"},"https://danieljharvey.github.io/typeclasses-profunctor/":{"body":"Hello. Let's make a box for putting functions in...\n\n...and a function...\n\n...and then let's put a function in this box:\n\nGreat. A function in a box. You may be concerned that something interesting is going on here, so just to assure you that it's not, let's run the function using runFuncBox, to reassure ourselves that this box is doing no funny business and we're really just unwrapping that newtype.\n\nOK. Good stuff. We now have a very longwinded way of running the length function. Good stuff. Big day.\n\nThe plot thickens\nNow what if want to run this weird function, but instead of having a String to hand, we only have an Animal...\n\nI can see you there. You're getting excited and jumping straight for our old pal Contravariant aren't you. But wait! That's not an entirely terrible decision but it turns out there are other problems that we must also solve.\nOh no\nThat's right. Heartbreaking, it also turns out that our somewhat contrived API can output numbers, but instead only lists full of a delicous datatype called Egg.\n\nWe can turn any Int into an [Egg] using this excellent function.\n\nOK. So somehow we need to turn an Animal into a List of Egg. We could contramap over our input to turn Animal into String, run the original length function, and then fmap over the result to turn Int into [Egg]. That could work. But what if we could solve this problem using a typeclass, that would be pretty fucking snazzy wouldn't it?\nHold on, he's only gone and done it\nLooks like a job for our new friend Profunctor I reckon. Let's have a wee look in ghci and see what what the hell it's deal is.\n\n\nLook at that! It gives a Contravariant with the lmap function, and a regular Functor with rmap, or everything smashed together in this new exciting dimap function. Let's look at that a little closer.\n\nThat's pretty beastly, let's put in some real concrete things.\n\nOK. Let's implement it for our FuncBox.\nInstances, binstances, dinstances\n\nThat's all really. The . is function composition, so therefore our function unwraps the original function and calls it f, then returns a new FuncBox which runs the before function (ie, the a -&gt; b one), then the original f function, and finally the after function (c -&gt; d). The resulting FuncBox can be used exactly as before, and nobody using it knows how secretly clever it is.\nLet's use it to make our all important function for turning an Animal in to a [Egg], using our length' and repeatEgg functions from earlier.\n\nThis gives us a new FuncBox that turns Animal into [Egg], but of course we all know that underneath the hood this function it's converting Animal -&gt; String -&gt; Int -&gt; [Egg]. Let's see it in action:\n\nBrilliant. What an absolutely useful non-waste-of-time. OK. So these are stupid examples, but hopefully they give you a rough idea what a Profunctor is under the hood. You often hear of their use in Lenses, as using dimap on a function for changing two small things can make it into a function that changes a small thing inside a much bigger thing, and they compose in the same nice way.\nGood stuff.\nFeel free to shout your brains about how stupid and wrong I am via the usual channels.\nFurther reading:\nEasier lenses\nData.Profunctor\n","id":"https://danieljharvey.github.io/typeclasses-profunctor/","title":"Typeclasses - Profunctor"},"https://danieljharvey.github.io/typeclasses-semigroup/":{"body":"Let's think about things that can be put together.\nHere's two lists, combined into one big list.\n\nGreat!\nWhat about two strings combined into one large excellent string?\n\nSure! Seems great. String is actually a List of Char so really that's just the same thing happening twice there. So what's Semigroup got to do with this? Semigroup is the generalisation of combining things together. How is it defined?\nDefinition\n\n...gets us...\n\nSo by the looks we can just define it with the &lt;&gt; function.\nTherefore we could write our string concat function as \"Great\" &lt;&gt; \"Job\" or combine lists like [1,2,3] &lt;&gt; [4,5,6].\nIt doesn't just involve putting sets of things together.\nMaybe Semigroup\nLet's define our own datatype MyMaybe which you may notice is very similar to Maybe. The Semigroup instance can be used to combine two of them.\n\nWhat's interesting about this one is that by insisting that the value inside is also a Semigroup, we can do some exciting multi-level combining.\n\nLet's see it at work.\n\nSure.\n\nPlausible.\n\nOK.\nAnd the more interesting one...\n\nWhat happened here? We combined two MyMaybe values AND the String values inside them as well, without really putting much effort in whatsoever. Great job, Semigroup.\nSum Semigroup\nWe can also use this pattern to describe combining numbers. Integers, for instance, can form several Monoids. One is addition. Let's build a newtype so that we can make a Semigroup instance.\n\nHere is a Semigroup instance, it uses pattern matching to take the original values out, adds them together, them wraps them in another MySum instance.\n\nWe can create several MySum instances, and then combine them together with &lt;&gt;.\n\nOr we could use the getMySum function in the newtype to unwrap it.\n\n(This is obviously quite an overwrought way to add 3 numbers together)\nProduct Semigroup\nWe could also combine numbers by multiplying them together.\n\n\n\n\nSo, yes.\nHopefully you get the idea of what's going on here. A Semigroup is a nice way of describing things we can smash together, and it becomes even better when we extend it into Monoid, that gets us a load of Foldable stuff for free. We'll come to that soon...\nMake sense? If not, why not get in touch?\nFurther reading:\nData.Semigroup\n","id":"https://danieljharvey.github.io/typeclasses-semigroup/","title":"Typeclasses - Semigroup"},"https://danieljharvey.github.io/typeclasses-show/":{"body":"Let's think about things.\n\nSeems great so far. Let's try and look at one in ghci.\n\nOh shit!\n\nTotally bogus!\nSo what's the problem? So for something to be shown in the console, we need to know how to convert it into a String. This is a pretty common thing to be able to do, so we have a typeclass for it, called Show. Let's check it out in ghci.\n\n\nA few more things than expected, tbh. Fortunately, that {-# MINIMAL showsPrec | show #-} means we can just define show, which takes any value of a type and turns it into a String.\nLet's make another data type.\n\nThis time, we'll create an instance of Show for it.\n\nNow we can show it as much as we like.\n\n\nGreat! What if we don't need particularly clever string output? Just the name of the type would be fine. Can we cheat and derive one?\n\nNothing seemed to complain there. Good stuff!\n\nSuccess! And, so, as one would expect...\n\nThat's better, but is there anything a bit more interesting we could do with this? Sure thing! What about a data type for creating HTML markup?\n\nThat type alias for Href just means it's a normal string, but it makes the intent a bit clearer. So this little markup type has four kinds of element.\n\nDiv has no content of it's own but is also a wrapper for a list of HTMLTree a elements.\nTitle also takes a String and has no child elements.\nP takes a String and has no child elements.\nA takes an Href (an alias for String) and a list of children of type HTMLTree a.\n\nLet's put it to work making an internet website.\n\nLooks like the beginnings of a world beating internet business to me. How can Show help us though?\n\nBy defining a show function for each of our tags (and recursively calling show for tags with child elements) we can generate HTML markup using one easy function:\n\nHooray! A website!\n\n(Actually it comes out in one big line, and then I added the line breaks to fit it on the page. Oh, the lies!)\nIt could do with a bit of sprucing up, and a few more tags, but in my by no means humble opinion we're on our way to creating the next React-beater. Great job, show.\n(Incidentally, although this is a more fun example of show, I'd probably recommend just using a normal function for this kind of thing. Something classic like renderTree :: (Show a) =&gt; Tree a -&gt; String maybe. This isn't strictly what the Show typeclass is for. There is also another type class called Read whose job is to turn the String output of show back into the original data type, and so making a clever show instance you're somewhat implicitly promising that you can turn it back somehow. This could end up being a Bad Time, and that's exactly the kind of time we don't want to have.)\nMake sense? If not, why not get in touch?\nFurther reading:\nText.Show\n","id":"https://danieljharvey.github.io/typeclasses-show/","title":"Typeclasses - Show"},"https://danieljharvey.github.io/typeclasses-traversable/":{"body":"Let's think about Trees.\n\nA tree can be either a Leaf with contains some of value, or a Branch that has two slots for either another Branch or perhaps a Leaf.\nWe can build up a tree like this:\n\nSo if you remember way back when when we talked about foldable, we can very easily teach this MyTree type we have created to fold over itself and do handy things.\n\nThen we can ask it to do helpful things like add up all the values in the tree.\n\nGreat!\nThis is all very well and good, but what if our tree contains more complex types that just a number? It is entirely plausible to end up with a bunch of optional values like this:\n\nWe could add up all the values without too much trouble, but what if we want to remove all the Just and Nothing from the MyTree but keep the structure intact? Enter Traversal!\nTraversable\nWhat does ghci have to say about it?\n\n\nA few things here:\n\nThe (Functor t, Foldable t) =&gt; part means we'll need to create Foldable and Functor instances for our datatype before it's allowed to be Traversable too.\nThe Applicative f =&gt; part means whichever other type we use it with must have an instance of Applicative. Fortunately many useful typeclasses are.\nWe can implement either traverse or sequenceA and the rest will sort itself out.\n\nWe'll choose traverse for our example.\nFirstly, let's make a Functor instance for MyTree. Nothing untoward here, we just recurse through the tree and run f on any as we find laying around. We'll not need to use this directly ourselves but it be used internally by other functions.\n\nNow let's implement a Traversable instance for MyTree.\n\nA few notes here:\n\n&lt;$&gt; is the infix version of fmap. (+1) &lt;$&gt; Just 2 is the same as fmap (+1) Just 2. Writing it this way shows us how similar it is to the functor instance.\n&lt;*&gt; is the infix version of apply from Applicative. Our Applicative f =&gt; constraint means this is supplied by whichever Applicative we are using in this function. As we will see, this means different applicatives give us very different outcomes.\n\nIt's perhaps not the most intuitive thing to look at and understand, so let's try using and see what's up. Although we've implemented the typeclass using traverse, the more intuitive function it provides us is sequence, which is sort of a \"swap the types around\" function. Let's try it with a few different instances of Applicative to get a feel for it.\nMaybe\nAlthough we just casually used Maybe, earlier, let's clarify what it is. The type definition looks something like this:\n\nIt is just for holding a value that might be there (Just \"i am a value\") or expressing a lack of value (Nothing). Let's put some in our MyTree.\n\n...and use sequence to pull them out and wrap the whole thing in a Maybe instead.\n\nWhat's gone on here then? All of the Just values inside the tree have gone, but have been replaced with a single Just at the start. If you squint, it kind of looks like we've turned the types inside out, and we kind of have. If this seems a bit odd to comprehend, it might remind you of this javascript:\n\nHere we can taken an array of Promises, and returned a single Promise returning an array of values. However, what happens if one of those promises fails?\n\nIt short circuits and fails! Going back to our tree, let's try putting a Nothing in there and see how that changes things.\n\nOk! So the same behaviour! Why is that though? There's nothing in our MyTree structure that does any checking of these sorts of things.\nThe key here is in how apply (or &lt;*&gt;) is implemented in Maybe itself:\n\nBasically, as soon as we find any Nothing, whatever we're doing becomes Nothing, so therefore Maybe is giving us our same short-circuiting behaviour from the javascript Promise.\nGood? Great. Let's look at another.\nList\nList is another interesting Applicative in that it treats every list like a set of possibilities.\nIt's defined as something like this:\n\nLook what happens when we sequence this small tree that contains a List in each of it's leaves...\n\nIt returns a List of every possible MyTree Int that could be made using the items in each list. If you look at the page on applicative - particularly the applicativeList - this may make more sense.\nThis sequence function we are using is merely traverse id by the way - so we can start to mess with it even more by using traverse with different functions. By passing the reverse function, we can get the same thing but backwards...\n\n(Why? I don't know, it's difficult coming up with useful examples all the time, give me a break.)\nWhat about Either?\nEither\nEither is used to express a value that could be one of two things. It's datatype looks something like:\n\nLeft usually expresses an error or something, whilst Right expresses everything being somewhat Hunky Dory.\nWhat happens when all the values are Right?\n\nOK, that seems reasonable, just like the Maybe really.\nWhat about if we throw a Left in there?\n\nOK - we get the Left value back, which seems reasonable (especially looking at the type signature of our new structure).\nWhat about if there are multiple Left values inside?\n\nOh. That seems somewhat counterintuitive. Even though we have many Left items in our tree, when we sequence them we only get the first one back. If you want to know why - sure - it's because of the way Either implements the &lt;*&gt; function. Is there an alterntaive in which we get more of the Left items back? Yes - see the bonus item at the bottom of the page.\nSo what does this mean?\nBasically (lol), what these examples hopefully start to show is that traverse let's us combine different types together. Whilst Foldable used a Monoid instance to combine values together with &lt;&gt;, Traversable lets us combine them together using their Applicative instance and &lt;*&gt;. Applicative is a pretty powerful typeclass that let's us do a lot of wild shit, so Traversable ends up pretty powerful as a result. A lot of the Lens package uses Traversable, so understanding this gives you a much better idea of what's doing.\nThere are plenty of Traversable instances in the wild to play with, so try smashing a few things together and see what happens. In case it's not entirely obvious, that's basically all I did in writing this article.\nAnyhow, that's enough for now I think.\nMake sense? If not, why not get in touch?\nFurther reading:\nData.Traversable\nBonus item: Validation\nIf you were enjoying the Either example but wondering if there's a way to gather all of the Left values in a tree, then, firstly, yes, and secondly, it's done using a different datatype called Validation. We won't go into it in depth now, but it's much like an Either that let's you collect Left items together.\n\n\n","id":"https://danieljharvey.github.io/typeclasses-traversable/","title":"Typeclasses - Traversable"},"https://danieljharvey.github.io/typescript-contract-tests/":{"body":"Hello. In our last article we described how to generate test cases for contract\ntesting in Haskell. This time, we are going to look at generating the front end\nportion of these in Typescript. This will probably be a lot briefer because I\nam a very lazy person at heart.\nFirst, some rambling\nThe main differences with the type system of Haskell or Purescript compared\nto that of Typescript is that typeclasses allow the types of things to affect\nthe code that is generated or used. That's how a newtype like Sum or\nProduct can change the Monoid function used to combine two values, even\nthough both are just Int values underneath.\nThe same thing applied to our arbitrary instances - we set a type, derived\nthe necessary instances, and then all the code was generated for us.\nTypescript is different. Because all the type info is destroyed at runtime,\nwe have to create run-time (or value level) descriptions of our types, and\nthen derive the types from those. Make sense? No? Doesn't really matter\nanyway.\n\nSome datatypes\nFortunately, generating run-time validators and types for them is exactly what\nthe excellent io-ts is for. It allows to\ncreate validators for our datatypes using runtime functions, but then also\nderive types from that. Let's see an example:\n\nHere we have defined Pet and User and created validators for them both.\nWhat does this mean?\n\nThis means that we can validate JSON we receive into our application and ensure\nthat when Typescript says we are talking about a User, we really are.\n\nReading sample JSON\nTherefore, hopefully you can work out how we're going to check our generated\nbackend responses from earlier.\n\nThis Jest test loads each .json file from a given folder and checks that it\ndecodes correctly with our UserShape validator. If they do, then we know, at\nleast for this particular endpoint, that our frontend and backend agree with\none another.\n\nGenerating sample JSON\nWhat has traditionally been a bit harder in Typescript in generating\narbitrary responses. Since we can't use out types to inform which values are\nmade, we have to be a bit creative.\nBut that's hard work. What if somebody else had already solved this and we\ncould just piggyback off their great work?\nEnter fast-check and\nio-ts-fast-check.\nfast-check is a property testing tool for Typescript. Essentially, for our\npurposes, it's QuickCheck. io-ts-fast-check is the secret sauce that says\n\"if you can give me a validator, I can generate you random values that satisfy\nit.\"\nTherefore, we can use it to create our random front end requests, ready for our\nbackend to decode and validate. Great!\n\n\nGreat stuff!\nNow we can read our sample requests into the backend and see that everything is\nfine. Running tests like this before each deploy of either front or back end\nservice is a great way to make sure nothing will explode. Source code is\navailable here if you\ncan't get it to do what you want for some reason.\nMake sense? No? Yes? Let me know!\n","id":"https://danieljharvey.github.io/typescript-contract-tests/","title":"Contract testing with Typescript"},"https://danieljharvey.github.io/what-is-a-typeclass/":{"body":"So recently I have become one of those jerks that has sailed through Read A Couple Of Chapters Of A Book About Haskell, by way of Snuck Maybe Types Into My Work Project to arrive at full-blown Good Morning Sir/Madam, Have You Got A Spare Moment To Talk About Monads™?. That is to say, by selfishly forcing these concepts upon my colleagues I have ended up spending a lot of my working life explaining them and why I think they are good to stop everybody hating me for making their lives unnecessary complicated. In doing so, I think I have come across one of the main conceptual stumbling blocks, which I hope to make less-stumble-able.\nSo the problem, as I see it, isn't grasping what a Monad is (it's a burrito, it's a poster tube, it's a snobby waste of time, easy!), or even what a Functor is (it's mappable, right?), but whether they are even \"things\" at all. It's one thing to see words like Monad, Functor, Monoid or Traversable around the place but it's a little unclear how to make, or god forbid, actually use one in something approaching real life code. Are they objects? Do I make a new Monad object just like I'd make a new Promise?\n\nIs is a Functor a method I can run on something to increase the amount of maths?\n\nThe short answer is \"no\", and the long answer, well, that's also \"no\", followed by \"ok, let me tell you what typeclasses are and hopefully the other stuff will sort of get cleared up along the way.\"\nMaths is sadness\nReading about type theory, particularly materials written from a very mathematical perspective, can often make it feel even worse, with explanations that feel so broad and simple that they feel either a) meaningless or b) like they must contain some unseen trap we mere mortals do not understand.\n\nAnyhow, I thought perhaps a better approach here is to explain what these things are not and work from there. Because the aim here is to end up with some real life knowledge we can use to write real code, instead of using examples from the world of computers, let's use them from the world of crime dramas, because I have been watching a lot of those recently.\nTime for a tenuous analogy\nSo we have a police officer. In this case, it's Detective Sergeant Kate Fleming from Jed Mercurio's surprisingly gripping Line Of Duty series (I too struggled with the series title's almost Clancy-ian levels of Really Must We Spell This Out, do persevere with it though, it really is OK, you probably only need to watch the first couple of seasons to follow this article)\n\nDS Kate Fleming is a Police Officer in AC-12, a unit in the police force somewhere in London that investigates Bent Coppers and makes sure there is no Dodgy Dealings or Underhand Business. DS Kate Fleming was not born a police officer, but certainly displays all the characteristics of one - she Catches Criminals, Likes A Pint, and Her Marriage Is In Tatters because of course she is Married To The Job.\n![DC Nigel \"Nige\" Morton, a human&nbsp;man](/images/typeclass4.png \"DC Nigel \"Nige\" Morton, a human&nbsp;man\")\nHere is another Police Officer - in this case Detective Constable Nigel \"Nige\" Morton, played by 90s lad hero and renowned bounding frown Neil Morrissey. \"Nige\" was also not born a copper, but he is certainly one now as he Likes A Pint and also, to some extent, Catches Criminals. \"Nige\", however, is a bit of a sneaky prick, and has been known from time to time to take a few backhanders in exchange for leaking information to the press and to other criminals. Therefore, to some extent, as well being a Police Officer, \"Nige\" is a Bent Copper because of his Underhand Business and Dodgy Dealings.\nHow does this relate to typeclasses then?\nDS Kate Fleming is not a typeclass.\nDC Nigel \"Nige\" Morton is also not a typeclass.\nLiking A Pint is not a typeclass.\nNeither is Underhand Business.\nTypeclass examples\nSo what are?\n\nHuman Person\n\nBoth DS Kate Fleming and DC Nigel \"Nige\" Morton can have instances of the typeclass Human Person, because they Breath, Eat and Poo. They are 'lawful' instances of Human Person because I am too lazy to think of a reason that they are not.\n\nPolice Officer\n\nDS Kate Fleming can be an instance of the typeclass of Police Officer because she Catches Criminals and Likes A Pint. She is also a 'lawful' instance, we can say, because as well as this, she does no Underhand Business or Dodgy Dealings.\nDC Nigel \"Nige\" Morton is, to the innocent eye, an instance of the typeclass Police Officer. He also Likes A Pint, Catches Criminals, and although he is seen to have a marriage earlier in the show, later he is seen to be mowing his lawn in a solitary fashion shot through a lens tinged with regret. However, he is not a 'lawful' instance of the typeclass Police Officer, because of his Underhand Business or Dodgy Dealings.\n\nBent Copper\n\nDS Kate Fleming is not in the typeclass Bent Copper, because (spoiler alert!) throughout the show she is seen to behave in a moral fashion befitting an officer working for AC-12, the anti-corruption unit at the centre of the whole show.\nDC Nigel \"Nige\" Morton however is in the typeclass Bent Copper, exactly because of his Underhand Business, Dodgy Dealings and Perhaps Not Really Needing That Walking Stick But Claiming Disability Benefits Regardless. He is probably also a lawful instance of Bent Copper (although I understand at this juncture that this makes the whole analogy somewhat confusing) - simply because Bent Coppers Don't Really Have Rules, And If They Did, Playing By Them Would Somewhat Defeat The Point.\n\nAnti-Corruption Police Officer\n\nDS Kate Fleming is also in this typeclass because she Nicks Bent Coppers, whilst DC Nigel \"Nige\" Morton is not because he wouldn't Dob In One Of Our Own. Clear? As mud? Great.\nBack to stupid code\nSo how does this relate to computers and showing our colleagues how incredibly intellectual we are?\n\nLet's take an array. That's a thing you have probably used.\n\narr is not a typeclass, it is an object (or more broadly, a value).\nA Functor is a typeclass though, and arr can be an instance of Functor.\nThe rules of a 'lawful' Functor is that we can run a Map function over the contents of the array and afterward The Length Of The Array Remains The Same and It's Still An Array and Basically Nothing Really Weird Has Happened.\n\nAs you see here, our array is the same length and the function has been applied to each item without any Funny Business. To tie it back to our police-based analogy - if DS Kate Fleming was given some important evidence to take back to the station, this result constitutes the evidence arriving at the station untampered for some forensic analysis that will pull the case together in the final nail-biting moments of the series.\nHowever, what if DC Nigel \"Nige\" Morton was given that same evidence? That's a nice 65 value in there, surely nobody would notice if he snuck it for himself? Surely he's Done His Bit Over The Years And Deserves It, after all.\n\nIf you can follow this code (and forgive the use of a mutable variable in an article that is, despite severely beating around the bush about the fact, written about the subject of functional programming) I think we can all agree that \"Nige\" here is a bit of a swine.\n\n\"Nige\"'s horrible law-breaking evidence-stealing map function does not make a 'lawful' Functor, as it breaks the Basically Nothing Really Weird Has Happened rule above by doing a massive side-effect and mutating an outside variable when it should just be doing nothing outside of the arr. However, if there is a TotallyAwfulFunctor typeclass, this would make an excellent instance of it.\nOK, I'm exhausted, please, tell me, what is a typeclass?\nSure.\n\nObjects and datatypes can be made instances of the typeclass Functor, provided they implement map without any funny business. These could be arrays, tree structure, Maybe and Either, and loads more. You can map over them all and expect the same behaviour.\nPeople are instances of the typeclass Human Being, as in general they implement the Breath, Eat and Poo functions. (todo: add javascript example)\nAnything that can be compared to another thing to check whether it is the same or not can be an instance of the typeclass Eq.\nMany objects and datatypes can be made instances of the typeclass Monad, if they are also lawful Functors and Applicative Functors and implement bind and return functions. (What? Not now...)\nTherefore...\nA typeclass is a way of categorising things based not on what they are but what they can and can't do.\n(Thanks Riku for helping me put that more succinctly. You may find it hard to believe that I have a tendency to ramble).\nMake sense? If not, why not get in touch?\nFurther reading:\nTypeclassopedia\nMore about Typeclasses\n","id":"https://danieljharvey.github.io/what-is-a-typeclass/","title":"Why The Hell Should I Care About Typeclasses?"}},"docInfo":{"https://danieljharvey.github.io/":{"body":0,"title":3},"https://danieljharvey.github.io/announcing-wasm-calc/":{"body":243,"title":7},"https://danieljharvey.github.io/content-addressed-languages/":{"body":497,"title":4},"https://danieljharvey.github.io/contract-testing/":{"body":663,"title":3},"https://danieljharvey.github.io/data-migrations/":{"body":1028,"title":2},"https://danieljharvey.github.io/datatypes-either/":{"body":512,"title":1},"https://danieljharvey.github.io/datatypes-maybe/":{"body":401,"title":2},"https://danieljharvey.github.io/do-notation/":{"body":172,"title":3},"https://danieljharvey.github.io/free-like-pizza/":{"body":642,"title":3},"https://danieljharvey.github.io/fuck-it-lets-write-a-database/":{"body":425,"title":5},"https://danieljharvey.github.io/getting-started-pt-1/":{"body":702,"title":5},"https://danieljharvey.github.io/lets-write-a-database-part-2/":{"body":191,"title":5},"https://danieljharvey.github.io/lets-write-a-database-part-3/":{"body":269,"title":5},"https://danieljharvey.github.io/llvm-compiler-part-1/":{"body":942,"title":6},"https://danieljharvey.github.io/llvm-compiler-part-2/":{"body":871,"title":6},"https://danieljharvey.github.io/llvm-compiler-part-3/":{"body":673,"title":6},"https://danieljharvey.github.io/new-types/":{"body":328,"title":3},"https://danieljharvey.github.io/optics-pt-1-lens/":{"body":278,"title":5},"https://danieljharvey.github.io/optics-pt-2-prism/":{"body":382,"title":5},"https://danieljharvey.github.io/ordering-and-limits/":{"body":80,"title":5},"https://danieljharvey.github.io/polymorphism/":{"body":289,"title":3},"https://danieljharvey.github.io/property-testing-mimsa/":{"body":596,"title":5},"https://danieljharvey.github.io/purescript-aff/":{"body":772,"title":6},"https://danieljharvey.github.io/purescript-semigroups/":{"body":684,"title":5},"https://danieljharvey.github.io/refined-types/":{"body":555,"title":3},"https://danieljharvey.github.io/tags-and-shit/":{"body":426,"title":2},"https://danieljharvey.github.io/testing-io/":{"body":403,"title":5},"https://danieljharvey.github.io/the-genius-of-concrete/":{"body":605,"title":2},"https://danieljharvey.github.io/total-functions/":{"body":311,"title":4},"https://danieljharvey.github.io/typechecking-pt1/":{"body":704,"title":4},"https://danieljharvey.github.io/typeclasses-alternative/":{"body":473,"title":2},"https://danieljharvey.github.io/typeclasses-applicative/":{"body":372,"title":2},"https://danieljharvey.github.io/typeclasses-bifunctor/":{"body":373,"title":2},"https://danieljharvey.github.io/typeclasses-contravariant/":{"body":420,"title":2},"https://danieljharvey.github.io/typeclasses-eq/":{"body":150,"title":2},"https://danieljharvey.github.io/typeclasses-foldable/":{"body":205,"title":2},"https://danieljharvey.github.io/typeclasses-functor/":{"body":521,"title":2},"https://danieljharvey.github.io/typeclasses-monad/":{"body":335,"title":2},"https://danieljharvey.github.io/typeclasses-monoid/":{"body":309,"title":2},"https://danieljharvey.github.io/typeclasses-ord/":{"body":214,"title":2},"https://danieljharvey.github.io/typeclasses-profunctor/":{"body":319,"title":2},"https://danieljharvey.github.io/typeclasses-semigroup/":{"body":214,"title":2},"https://danieljharvey.github.io/typeclasses-show/":{"body":276,"title":2},"https://danieljharvey.github.io/typeclasses-traversable/":{"body":628,"title":2},"https://danieljharvey.github.io/typescript-contract-tests/":{"body":275,"title":3},"https://danieljharvey.github.io/what-is-a-typeclass/":{"body":815,"title":3}},"length":46},"lang":"English"}