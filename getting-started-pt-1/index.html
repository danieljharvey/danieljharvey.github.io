<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - My First Haskell Project - Part 1</title>
    <link rel="stylesheet" href="https://danieljharvey.github.io/main.css">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="/">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="/">Posts</a>
        </nav>
    </header>

    <main role="main">
        
<h1 class="title">
  My First Haskell Project - Part 1
</h1>
<p class="subtitle"><strong>2018-12-26</strong></p>
<p>
 <p class="blog-meta">
        
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/haskell/"
          >#haskell</a
        > 
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/stack/"
          >#stack</a
        >
         
      </p>

<p>I have not always found it clear how to get started with Haskell, and I have a small library I want to make as an experiment so I figured I'd document the process as a sort of Getting Started. The tiny library I wish to make is for reading environment variables, which can be used for database connections or similar. I use MacOS but will try not to make anything too platform specific, and link to docs where info for other systems can be found where possible.</p>
<p>First, let's assume we have nothing Haskell-based on the system whatsoever, and start by installing Stack.</p>
<p>On MacOS this is as easy as running</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">brew</span><span> install stack
</span></code></pre>
<p>but for other systems you will need to look at the <a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/">Stack docs</a>.</p>
<p>Assuming that's all gone swimmingly, let's start a new project, which we will call <code>simple-env</code>.</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">stack</span><span> new simple-env
</span></code></pre>
<p>This will create a new folder called <code>simple-env</code> containing the following:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">.gitignore
</span><span style="color:#bf616a;">ChangeLog.md
</span><span style="color:#bf616a;">LICENSE
</span><span style="color:#bf616a;">README.md
</span><span style="color:#bf616a;">Setup.hs
</span><span style="color:#bf616a;">app
</span><span style="color:#bf616a;">package.yaml
</span><span style="color:#bf616a;">simple-env.cabal
</span><span style="color:#bf616a;">src
</span><span style="color:#bf616a;">stack.yaml
</span><span style="color:#bf616a;">test
</span></code></pre>
<p>Looks great. There are two files here that describe our project... <code>simple-env.cabal</code> generated by Cabal, and <code>package.yaml</code> generated by Stack. Don't make the mistake I made and change the Cabal one directly - instead use <code>package.yaml</code> as the source of truth and allow Stack to auto-generate sensible <code>.cabal</code> files.</p>
<p>Here is our default <code>package.yaml</code> file:</p>
<pre data-lang="yaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-yaml "><code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">name</span><span>: </span><span style="color:#a3be8c;">simple-env
</span><span style="color:#bf616a;">version</span><span>: </span><span style="color:#d08770;">0.1.0.0
</span><span style="color:#bf616a;">github</span><span>: &quot;</span><span style="color:#a3be8c;">githubuser/simple-env</span><span>&quot;
</span><span style="color:#bf616a;">license</span><span>: </span><span style="color:#a3be8c;">BSD3
</span><span style="color:#bf616a;">author</span><span>: &quot;</span><span style="color:#a3be8c;">Author name here</span><span>&quot;
</span><span style="color:#bf616a;">maintainer</span><span>: &quot;</span><span style="color:#a3be8c;">example@example.com</span><span>&quot;
</span><span style="color:#bf616a;">copyright</span><span>: &quot;</span><span style="color:#a3be8c;">2018 Author name here</span><span>&quot;
</span><span>
</span><span style="color:#bf616a;">extra-source-files</span><span>:
</span><span>  - </span><span style="color:#a3be8c;">README.md
</span><span>  - </span><span style="color:#a3be8c;">ChangeLog.md
</span><span>
</span><span style="color:#65737e;"># Metadata used when publishing your package
</span><span style="color:#65737e;"># synopsis:            Short description of your package
</span><span style="color:#65737e;"># category:            Web
</span><span>
</span><span style="color:#65737e;"># To avoid duplicated efforts in documentation and dealing with the
</span><span style="color:#65737e;"># complications of embedding Haddock markup inside cabal files, it is
</span><span style="color:#65737e;"># common to point users to the README.md file.
</span><span style="color:#bf616a;">description</span><span>: </span><span style="color:#a3be8c;">Please see the README on GitHub at &lt;https://github.com/githubuser/simple-env#readme&gt;
</span><span>
</span><span style="color:#bf616a;">dependencies</span><span>:
</span><span>  - </span><span style="color:#a3be8c;">base &gt;= 4.7 &amp;&amp; &lt; 5
</span><span>
</span><span style="color:#bf616a;">library</span><span>:
</span><span>  </span><span style="color:#bf616a;">source-dirs</span><span>: </span><span style="color:#a3be8c;">src
</span><span>
</span><span style="color:#bf616a;">executables</span><span>:
</span><span>  </span><span style="color:#bf616a;">simple-env-exe</span><span>:
</span><span>    </span><span style="color:#bf616a;">main</span><span>: </span><span style="color:#a3be8c;">Main.hs
</span><span>    </span><span style="color:#bf616a;">source-dirs</span><span>: </span><span style="color:#a3be8c;">app
</span><span>    </span><span style="color:#bf616a;">ghc-options</span><span>:
</span><span>      - </span><span style="color:#a3be8c;">-threaded
</span><span>      - </span><span style="color:#a3be8c;">-rtsopts
</span><span>      - </span><span style="color:#a3be8c;">-with-rtsopts=-N
</span><span>    </span><span style="color:#bf616a;">dependencies</span><span>:
</span><span>      - </span><span style="color:#a3be8c;">simple-env
</span><span>
</span><span style="color:#bf616a;">tests</span><span>:
</span><span>  </span><span style="color:#bf616a;">simple-env-test</span><span>:
</span><span>    </span><span style="color:#bf616a;">main</span><span>: </span><span style="color:#a3be8c;">Spec.hs
</span><span>    </span><span style="color:#bf616a;">source-dirs</span><span>: </span><span style="color:#a3be8c;">test
</span><span>    </span><span style="color:#bf616a;">ghc-options</span><span>:
</span><span>      - </span><span style="color:#a3be8c;">-threaded
</span><span>      - </span><span style="color:#a3be8c;">-rtsopts
</span><span>      - </span><span style="color:#a3be8c;">-with-rtsopts=-N
</span><span>    </span><span style="color:#bf616a;">dependencies</span><span>:
</span><span>      - </span><span style="color:#a3be8c;">simple-env
</span></code></pre>
<p>If you're familar with the Javascript world, this isn't a million miles away from a <code>package.json</code> file.</p>
<p>We aren't going to need any new libraries for our project, but it seems sensible to explain how that's done. Let's install <a href="http://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant.html">contravariant</a> package, because why not.</p>
<p>Let's add it to here:</p>
<pre data-lang="yaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-yaml "><code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">dependencies</span><span>:
</span><span>  - </span><span style="color:#a3be8c;">base &gt;= 4.7 &amp;&amp; &lt; 5
</span></code></pre>
<p>so we have</p>
<pre data-lang="yaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-yaml "><code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">dependencies</span><span>:
</span><span>  - </span><span style="color:#a3be8c;">base &gt;= 4.7 &amp;&amp; &lt; 5
</span><span>  - </span><span style="color:#a3be8c;">contravariant
</span></code></pre>
<p>We don't mind what version in this case - Stack will choose us a sensible one that fits with our other dependencies, that's what it's for.</p>
<p>Let's run</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">stack</span><span> build
</span></code></pre>
<p>and watch the action.</p>
<p>The first time you run this on any given project, Stack will download the GHC compiler and all the libraries so you may wish to take a break and go and read War and Peace or something. After the initial wait subsequent builds will be very quick, but this one is a bit of a stinker.</p>
<p>Ok. Great, we have filled our hard drive with nonsense and we are ready to Haskell.</p>
<p>What else have we got in this folder?</p>
<p>Firstly, we have the <code>app</code> folder which contains one file, <code>Main.hs</code>. This is the entry-point to our application, and looks like this:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">module </span><span>Main </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#b48ead;">import </span><span>Lib
</span><span>
</span><span style="color:#8fa1b3;">main </span><span style="color:#b48ead;">:: IO </span><span>()
</span><span>main = someFunc
</span></code></pre>
<p>When a Haskell program is run the <code>main</code> function in a module called <code>Main</code> is run, and then it is responsible for everything else that happens. Therefore we can deduce that this program is importing <code>someFunc</code> from somewhere and running that. Seems plausible. Let's run it and see what happens.</p>
<p>If we look back in <code>package.yaml</code> we have a section that looks like this:</p>
<pre data-lang="yaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-yaml "><code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">executables</span><span>:
</span><span>  </span><span style="color:#bf616a;">simple-env-exe</span><span>:
</span><span>    </span><span style="color:#bf616a;">main</span><span>: </span><span style="color:#a3be8c;">Main.hs
</span><span>    </span><span style="color:#bf616a;">source-dirs</span><span>: </span><span style="color:#a3be8c;">app
</span><span>    </span><span style="color:#bf616a;">ghc-options</span><span>:
</span><span>      - </span><span style="color:#a3be8c;">-threaded
</span><span>      - </span><span style="color:#a3be8c;">-rtsopts
</span><span>      - </span><span style="color:#a3be8c;">-with-rtsopts=-N
</span><span>    </span><span style="color:#bf616a;">dependencies</span><span>:
</span><span>      - </span><span style="color:#a3be8c;">simple-env
</span></code></pre>
<p>What it telling us? Well, a bunch of things, but two that stick out.</p>
<ol>
<li>Firstly, yes, our assumptions were correct - our main source directory is <code>app</code> and the main file is <code>Main.hs</code>.</li>
<li>Secondly, that our executable file is called <code>simple-env-exe</code></li>
</ol>
<p>Let's run it then!</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">stack</span><span> exec simple-env-exe
</span></code></pre>
<p>It should just print "someFunc" to the screen and exit, which is admittedly quite underwhelming.</p>
<p>We can do better than this.</p>
<p>So it looks like <code>someFunc</code> is a function in <code>src/Lib.hs</code>. The whole file looks like this. Let's start work in here.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">module </span><span>Lib
</span><span>    ( </span><span style="color:#8fa1b3;">someFunc
</span><span>    ) </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#8fa1b3;">someFunc </span><span style="color:#b48ead;">:: IO </span><span>()
</span><span>someFunc = putStrLn &quot;</span><span style="color:#a3be8c;">someFunc</span><span>&quot;
</span></code></pre>
<p>Our library is going to extract environment variables so they can be used in programs. This is helpful for stuff like database credentials that we don't want to save in version control.</p>
<p>Here is the MVP version:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">module </span><span>Lib
</span><span>    ( </span><span style="color:#8fa1b3;">someFunc
</span><span>    ) </span><span style="color:#b48ead;">where
</span><span>
</span><span style="color:#b48ead;">import           </span><span>System.Environment (</span><span style="color:#8fa1b3;">lookupEnv</span><span>)
</span><span>
</span><span style="color:#8fa1b3;">someFunc </span><span style="color:#b48ead;">:: IO </span><span>()
</span><span>someFunc = </span><span style="color:#b48ead;">do
</span><span>    testValue &lt;- lookupEnv &quot;</span><span style="color:#a3be8c;">TEST_VALUE</span><span>&quot;
</span><span>    putStrLn (showResult testValue)
</span><span>
</span><span style="color:#8fa1b3;">showResult </span><span style="color:#b48ead;">:: Maybe String -&gt; String
</span><span>showResult maybeValue = </span><span style="color:#b48ead;">case</span><span> maybeValue </span><span style="color:#b48ead;">of
</span><span>    </span><span style="color:#d08770;">Just</span><span> value -&gt; &quot;</span><span style="color:#a3be8c;">TEST_VALUE</span><span>&quot; ++ &quot;</span><span style="color:#a3be8c;">: </span><span>&quot; ++ value
</span><span>    _          -&gt; &quot;</span><span style="color:#a3be8c;">TEST_VALUE could not found!</span><span>&quot;
</span></code></pre>
<p>Let's take this apart a bit.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">import           </span><span>System.Environment (</span><span style="color:#8fa1b3;">lookupEnv</span><span>)
</span></code></pre>
<p>Firstly, we have an import. We are using the <code>lookupEnv</code> function from System.Environment. If we look in the docs for it in <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/System-Environment.html">Hackage</a> we can see it has the following type signature:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">lookupEnv </span><span style="color:#b48ead;">:: String -&gt; IO</span><span> (</span><span style="color:#b48ead;">Maybe String</span><span>)
</span></code></pre>
<p>This means we need to give it a <code>String</code> (the name of the environment variable we wish to check for) and it will return a <code>Maybe String</code>. This means if it CAN find a <code>String</code> it will return it, if not, it won't explode or anything, which is handy. However, that <code>Maybe String</code> is wrapped in an <code>IO</code>. What does this mean?</p>
<p>It means that this function needs to do interaction with the outside world, therefore it must also be run from another <code>IO</code> function using <code>bind</code>. Think of <code>IO</code> like the electricity that allows access to side-effects and the outside world. It's where the problems are most likely to come from, so Haskell forces us to be very explicit about where it is and more importantly, where it isn't. Our <code>main</code> functions have access to <code>IO</code>, and they must pass the <code>IO</code>-ness to wherever else needs it.</p>
<p>Opinionated note: <code>IO</code> is one of the more complicated parts of Haskell, and it's somewhat unfortunate for adoption of the language that we have to deal with it in the first lines of any program. I would wager that this is why so many tutorials and books start with hacking in the <code>ghci</code> repl instead, as it saves having to have The IO Chat. I am a firm believer in uncomfortable truths, moreso if they are explained terribly like this, but if you are starting out, feel utterly free just to accept this part is a bit weird, learn to live with it, and come back to in depth later. The <code>IO</code> concept really is quite a good thing, it just presents something of a Learning Kerb.</p>
<p>We also have a helper function called <code>showResult</code>.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">showResult </span><span style="color:#b48ead;">:: Maybe String -&gt; String
</span><span>showResult maybeValue = </span><span style="color:#b48ead;">case</span><span> maybeValue </span><span style="color:#b48ead;">of
</span><span>    </span><span style="color:#d08770;">Just</span><span> value -&gt; &quot;</span><span style="color:#a3be8c;">TEST_VALUE</span><span>&quot; ++ &quot;</span><span style="color:#a3be8c;">: </span><span>&quot; ++ value
</span><span>    _          -&gt; &quot;</span><span style="color:#a3be8c;">TEST_VALUE could not found!</span><span>&quot;
</span></code></pre>
<p>This function just takes our <code>Maybe String</code> and turns it into a <code>String</code> ready for us to print to the console. It uses pattern matching of the <code>maybeValue</code> to display either the result (<code>value</code>) that the environment variable was set to, or a fallback message. Therefore we should get:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>showResult (</span><span style="color:#d08770;">Just </span><span>&quot;</span><span style="color:#a3be8c;">horses</span><span>&quot;)
</span><span style="color:#65737e;">-- &quot;TEST_VALUE: horses&quot;
</span><span>
</span><span>showResult (</span><span style="color:#d08770;">Nothing</span><span>)
</span><span style="color:#65737e;">-- &quot;TEST_VALUE could not be found!
</span></code></pre>
<p>Pretty OK, huh?</p>
<p>OK, lastly the glue function, <code>someFunc</code>.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">someFunc </span><span style="color:#b48ead;">:: IO </span><span>()
</span><span>someFunc = </span><span style="color:#b48ead;">do
</span><span>    testValue &lt;- lookupEnv &quot;</span><span style="color:#a3be8c;">TEST_VALUE</span><span>&quot;
</span><span>    putStrLn (showResult testValue)
</span></code></pre>
<p>What's the deal here? Ok. So firstly, the <code>Do</code> - it says that we're starting some <code>Do notation</code> which allows us to write in a slightly more imperative style. Like the <code>IO</code> concept in general it's a bit of a heavy concept to throw at beginners in the first few lines so let's also make a mental note to just nod and come back to the concept later. Again, it is a pretty neat thing, but confusing to start with.</p>
<p>Moving on, this line is more interesting:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>testValue &lt;- lookupEnv &quot;</span><span style="color:#a3be8c;">TEST_VALUE</span><span>&quot;
</span></code></pre>
<p>So as discussed earlier, our <code>lookupEnv</code> takes a <code>String</code> (in this case "TEST_VALUE") and returns <code>Maybe String</code> wrapped in <code>IO</code>. This <code>&lt;-</code> pulls it out of the <code>IO</code> so that in effect, this line is setting <code>testValue</code> to <code>Maybe String</code>. If <code>lookupEnv</code> finds an environment variable called "TEST_VALUE" then <code>testValue</code> will be <code>Just "whatever_the_value_was"</code>, but if it fails, it'll be <code>Nothing</code>. Note that we were only able to even use the <code>lookupEnv</code> function because <code>someFunc</code> is also an <code>IO</code> function, so in effect we have passed the <code>IO</code> power along to <code>lookupEnv</code> to let it do it's magic.</p>
<p>Great stuff. We have done a thing. Now let's tell our wonderful user all about it.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>putStrLn (showResult testValue)
</span></code></pre>
<p>OK. So this line just takes <code>testValue</code> (a <code>Maybe String</code>), uses <code>showResult</code> to turn it into a nice <code>String</code> that tells us what happened, and then uses <code>putStrLn</code> (put string line) to show it on the screen. <code>putStrLn</code> is another <code>IO</code> action, with this type signature:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">putStrLn </span><span style="color:#b48ead;">:: String -&gt; IO </span><span>()
</span></code></pre>
<p>This means it takes a <code>String</code>, and then returns <code>()</code> (unit, the nothing value) inside an <code>IO</code>. Again, it must be run inside another <code>IO</code> context to get it's "power", as such. Also, the fact it returns <code>()</code> is helpful - our <code>someFunc</code> is of type <code>IO ()</code> meaning it should also return nothing, so <code>putStrLn</code> is also doing that for us. Tidy.</p>
<p>Great stuff.</p>
<p>Let's try our program.</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">stack</span><span> build
</span><span style="color:#bf616a;">stack</span><span> exec simple-env-exe
</span></code></pre>
<p>Assuming you've not got an environment variable called "TEST_VALUE" set you should see:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">stack</span><span> exec simple-env-exe
</span><span>&quot;</span><span style="color:#a3be8c;">TEST_VALUE could not found!</span><span>&quot;
</span></code></pre>
<p>Let's set one (assuming you're in Bash or Zsh):</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#b48ead;">export </span><span style="color:#bf616a;">TEST_VALUE</span><span>=&quot;</span><span style="color:#a3be8c;">horses!</span><span>&quot;
</span></code></pre>
<p>...and run the program again.</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">stack</span><span> exec simple-env-exe
</span><span>&quot;</span><span style="color:#a3be8c;">TEST_VALUE: horses!</span><span>&quot;
</span></code></pre>
<p>Great stuff. It's not much of a library, but it's a start. Next time we'll make a nicer API for fetching multiple variables at once so it's actually a bit more helpful for our users.</p>
<p>Make sense? If not, why not <a href="/contact.html">get in touch</a>?</p>
<p>Further reading:</p>
<p><a href="https://docs.haskellstack.org/en/stable/README/">The Haskell Stack Tool</a></p>
<p><a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/System-Environment.html">System.Environment</a></p>
<p><a href="https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions">Intro to IO</a></p>
<p><a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html">System.IO</a></p>
<p><a href="http://learnyouahaskell.com/input-and-output">Learn You A Haskell: IO</a></p>


    </main>

    <footer>
      <p><a href="mailto:danieljamesharvey@gmail.com">Contact</a> |
      <a href="https://github.com/danieljharvey">Github</a></p>
      <p>Links for nerds:
        <a href="/atom.xml">atom</a>
        <a href="/rss.xml">rss</a></p>

    </footer>
</body>

</html>
