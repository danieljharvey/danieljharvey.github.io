<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Property testing a content-addressed language</title>
    <link rel="stylesheet" href="https://danieljharvey.github.io/main.css">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="/">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="/">Posts</a>
        </nav>
    </header>

    <main role="main">
        
<h1 class="title">
  Property testing a content-addressed language
</h1>
<p class="subtitle"><strong>2021-12-28</strong></p>
<p>
 <p class="blog-meta">
        
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/plt/"
          >#plt</a
        > 
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/mimsa/"
          >#mimsa</a
        > 
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/testing/"
          >#testing</a
        >
         
      </p>

<p>So in the <a href="/posts/2021-12-28-content-addressed-languages.html">last post</a> I quickly introduced the project I've been working on for a
while called <a href="https://github.com/danieljharvey/mimsa">mimsa</a>. The reason I did this was so that I could write this post
about recently adding property tests to the language, and what was good/bad
about that, so without further ado here are many words:</p>
<h3 id="tests-in-mimsa">Tests in mimsa</h3>
<p>So, for context, unit tests work as follows in <code>mimsa</code>:</p>
<ul>
<li>We create a (broken) <code>add</code> function:</li>
</ul>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :bind add = \a -&gt; \b -&gt; a + b + </span><span style="color:#d08770;">1
</span><span style="color:#d08770;">Bound</span><span> add.
</span></code></pre>
<ul>
<li>We create a unit tests that confirms that <code>add</code> is indeed broken:</li>
</ul>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">2 + 2 == 4</span><span>&quot; add </span><span style="color:#d08770;">2 2 </span><span>== </span><span style="color:#d08770;">4
</span><span style="color:#65737e;">--- FAIL --- 2 + 2 == 4
</span></code></pre>
<ul>
<li>We update <code>add</code> to a working implementation, and now the test passes:</li>
</ul>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :bind add = \a -&gt; \b -&gt; a + b
</span><span style="color:#d08770;">Updated</span><span> binding </span><span style="color:#b48ead;">of</span><span> add.
</span><span>+++ </span><span style="color:#d08770;">PASS </span><span>+++ </span><span style="color:#d08770;">2 </span><span>+ </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">4 
</span></code></pre>
<p>What is really neat is that what looks like <strong>one test being run twice</strong> is
actually <strong>two tests being run once each</strong>.</p>
<p>Why? The reason is immutability - once the first test is
created it can't be changed. It also doesn't need re-running - it always has
the same arguments, and it's only dependency, the original <code>add</code> function,
never changes, so the test stands as a static assertion of the behaviour of
said function.</p>
<p>And where does the second test come from? When we bind a new version of <code>add</code>, it stands to reason we might
want to run the same tests on it, therefore a new copy of any test is created
that uses the new <code>add</code> function as it's dependency.</p>
<blockquote>
<p>A really nice property of testing in this way is that we could also make it
run in reverse. If I add another test to the new <code>add</code> function there is no
reason not to auto-create versions of it for the old <code>add</code> bindings too. This
is super helpful when finding a new regression, as we can write a new test for
old code to find out when said regression occurred, a sort of super-powered
git bisect. I say <em>could</em> here because I have not done this yet because I am
lazy.</p>
</blockquote>
<h3 id="property-testing-a-recap">Property testing, a recap</h3>
<p>Property testing is a kind of testing where instead of confirming our code
works against known good values we confirms that it obeys certain rules.</p>
<p>A non-property test could be <code>add 2 2 == 4</code> - we know this should be the answer
because we have checked on a calculator that <code>2 + 2</code> does indeed equal <code>4</code>.</p>
<p>A property test might be <code>add 0 a == a</code>, given any <code>a</code>. When this is run by
<a href="https://hackage.haskell.org/package/QuickCheck">quickcheck</a> or
<a href="https://github.com/dubzzz/fast-check">fast-check</a> the property testing
framework will run the test with loads and loads of different values for <code>a</code>,
and return all the ones that break it (in this case, none of them). If the
tests all pass then we know the property <strong>adding zero to a number returns the same
number</strong> holds.</p>
<p>Property testing is very useful for finding edge cases in functions, and used
well, can be a lot more thorough than unit tests, for not a lot more effort.</p>
<h3 id="the-current-implementation">The current implementation</h3>
<p>For a unit test to be valid in <code>mimsa</code>, it must have the type <code>Boolean</code> (There
is a lot wrong with this, as it doesn't let you see what went wrong, but we
can't just go around making things "good" all the time).</p>
<p>Therefore this are the simplest possible tests:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">true</span><span>&quot; </span><span style="color:#d08770;">True
</span><span>+++ </span><span style="color:#d08770;">PASS </span><span>+++ true
</span><span>
</span><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">false</span><span>&quot; </span><span style="color:#d08770;">False
</span><span style="color:#65737e;">--- FAIL --- false
</span></code></pre>
<p>To make a property test, we provide an expression with the type <code>something -&gt; Boolean</code>, like:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">or true is always true</span><span>&quot; \bool -&gt; or bool </span><span style="color:#d08770;">True
</span><span>+++ </span><span style="color:#d08770;">PASS </span><span>+++ or true is always true
</span></code></pre>
<p>What's happened here?</p>
<p>The <code>mimsa</code> typechecker has inferred that <code>bool</code> must be a <code>Boolean</code>, generated
a big bucket of booleans, and then checked that each time <code>or bool True == True</code>. This returns <code>True</code> everytime so the test passes.</p>
<blockquote>
<p>The <code>or</code> function has type <code>Boolean -&gt; Boolean -&gt; Boolean</code> and looks something like <code>\a -&gt; \b -&gt; if a then True else b</code>. It is
similar to the <code>||</code> operator in most programming languages.</p>
</blockquote>
<p>Let's try another:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">and true is always true</span><span>&quot; \bool -&gt; and bool </span><span style="color:#d08770;">True
</span><span style="color:#65737e;">--- FAIL --- and true is always true
</span><span style="color:#d08770;">Failing</span><span> inputs:
</span><span> - </span><span style="color:#d08770;">False
</span></code></pre>
<p>This property test has failed, and it's telling us that when you pass <code>False</code>
to the test function, it does not return <code>True</code>. The <code>and</code> function here is
equivalent to <code>&amp;&amp;</code>, so this makes sense, as <code>False &amp;&amp; True</code> equals <code>False</code>.</p>
<p>As the input is a <code>Boolean</code> there are only two inputs, and the <code>mimsa</code> property
test generates <code>1000</code> sample inputs, it's fairly likely we'll get both a <code>False</code>
and a <code>True</code> input.</p>
<h3 id="breaking-it">Breaking it</h3>
<p>However, it's not too difficult to make a less definitive test:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :bind flakyTest = 
</span><span>  \val -&gt; match val with 
</span><span>    (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just True</span><span>)))) -&gt; </span><span style="color:#d08770;">False 
</span><span>  | _ -&gt; </span><span style="color:#d08770;">True
</span><span style="color:#d08770;">Bound</span><span> flakyTest.
</span><span>
</span><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">Flaky</span><span>&quot; flakyTest
</span><span>+++ </span><span style="color:#d08770;">PASS </span><span>+++ </span><span style="color:#d08770;">Flaky
</span><span>
</span><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">Flaky 2</span><span>&quot; flakyTest
</span><span style="color:#65737e;">--- FAIL --- Flaky 2
</span><span style="color:#d08770;">Failing</span><span> inputs:
</span><span> - </span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just True</span><span>)))
</span></code></pre>
<p>Because the input type here would be <code>Maybe (Maybe (Maybe (Maybe Boolean)))</code> there are a lot of potential inputs,
and it's quite possible that <code>Just (Just (Just (Just True)))</code> is not amongst
the generated values.</p>
<p>Another type of flaky test can be generated like this:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>:&gt; :addTest &quot;</span><span style="color:#a3be8c;">flaky string</span><span>&quot; \str -&gt; not (str == &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;)
</span><span>+++ </span><span style="color:#d08770;">PASS </span><span>+++ flaky string
</span></code></pre>
<p>It passes every time I have tried it, although as a statement it makes no
sense - <em>there is no string that equals "dog"</em>. This kind of test is hard just
because there are so many potential strings out there that a total search of
the space is close to impossible.</p>
<h3 id="the-problems-solutions">The problems / solutions</h3>
<h4 id="simple-tests-could-be-non-deterministic-and-aren-t">Simple tests could be non-deterministic and aren't:</h4>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>\bool -&gt; and bool </span><span style="color:#d08770;">True
</span></code></pre>
<p>This could be two unit tests that are run once and never again, however as a
property test it must be run over and over. This is the least of the problems
but worth mentioning.</p>
<h4 id="complex-finite-tests-become-flaky">Complex finite tests become flaky</h4>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>\val -&gt; match val with
</span><span>    (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just</span><span> (</span><span style="color:#d08770;">Just True</span><span>)))) -&gt; </span><span style="color:#d08770;">False
</span><span>  | _ -&gt; </span><span style="color:#d08770;">True
</span></code></pre>
<p>Given that a <code>Maybe</code> is either <code>Nothing</code> or the value inside, and <code>Boolean</code> can
be 1 of 2 values, there are <code>1 + 1 + 1 + 1 + 2 == 6</code> potential inputs here.
It doesn't seem out of the question to auto-generate all the possible values
here and run tests against them all. This would ensure a) the same results each
time and b) that we could cache the results once and never run them again.</p>
<p>However, if the input type contains an <code>Int</code>, <code>String</code>, <code>Array</code> or any recursive
type then generating a complete set of inputs is no longer practical.</p>
<blockquote>
<p>A recursive type is one that contains itself. For instance, a linked list is
defined in <code>mimsa</code> as <code>type List a = Nil | Cons a (List a)</code>. The second <code>List a</code> argument to <code>Cons</code> means "and another list" so this datatype can grow and
grow and grow.</p>
</blockquote>
<h4 id="string-and-number-spaces-just-too-huge">String and number spaces just too huge</h4>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>\str -&gt; not (str == &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;)
</span></code></pre>
<p>Due to the way the <code>mimsa</code> web client works, we can't really fall back to brute
forcing an absolute shit ton of inputs for <code>String</code> and <code>Int</code> inputs. However,
we have access to the AST when running the test. Would it be so terrible to add all of the string and number literals found in the
expression into the test values? For instance, if we used the input <code>"dog"</code>
above we'd find the breaking case immediately.</p>
<h3 id="no-more-words">No more words</h3>
<p>That is the end of the words. It's a bit of a braindump, and pretty much only
for my own benefit, but I hope it is perhaps vaguely interesting. Who knows?</p>
<p>Make sense? If not, <a href="/contact.html">get in touch</a>!</p>
<p>Further reading:</p>
<p><a href="https://hackage.haskell.org/package/QuickCheck">quickcheck</a></p>
<p><a href="https://github.com/dubzzz/fast-check">fast-check</a></p>
<p><a href="https://github.com/danieljharvey/mimsa">mimsa</a></p>


    </main>

    <footer>
      <p><a href="mailto:danieljamesharvey@gmail.com">Contact</a> |
      <a href="https://github.com/danieljharvey">Github</a></p>
      <p>Links for nerds:
        <a href="/atom.xml">atom</a>
        <a href="/rss.xml">rss</a></p>

    </footer>
</body>

</html>
