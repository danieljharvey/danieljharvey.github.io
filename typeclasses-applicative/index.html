<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Daniel J. Harvey - Typeclasses - Applicative</title>
    <link rel="stylesheet" href="https://danieljharvey.github.io/main.css">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RKDYZB38Z0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RKDYZB38Z0');
    </script>
</head>

<body>
    <header>
        <div class="logo">
            <a href="/">Daniel J. Harvey</a>
        </div>
        <nav>
            <a href="/">Posts</a>
        </nav>
    </header>

    <main role="main">
        
<h1 class="title">
  Typeclasses - Applicative
</h1>
<p class="subtitle"><strong>2018-11-17</strong></p>
<p>
 <p class="blog-meta">
        
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/haskell/"
          >#haskell</a
        > 
        <a href="https:&#x2F;&#x2F;danieljharvey.github.io/tags/typeclasses/"
          >#typeclasses</a
        >
         
      </p>

<p>In my learning of Haskell and all the associated mathematical stuff attached to it, one of the tougher conceptual cookies to crack has been the Applicative Functor.</p>
<p>Coming from a background of fairly functional Javascript, functor is a very easy sell - it's <code>array.map</code>. Easy. If there's a thing in the box, do something to the thing, if there's nothing in the box, don't freak out about the lack of things or explode. Great!</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">increase </span><span style="color:#b48ead;">:: Int -&gt; Int
</span><span>increase i = i + </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#65737e;">-- fmap increase [1,2,3] == [2,3,4]
</span></code></pre>
<p>These functions can even return lists of their own...</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">moreList </span><span style="color:#b48ead;">:: Int -&gt;</span><span> [</span><span style="color:#b48ead;">Int</span><span>]
</span><span>moreList a = [a -</span><span style="color:#d08770;">1</span><span>, a, a + </span><span style="color:#d08770;">1</span><span>]
</span></code></pre>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">listOfLists </span><span style="color:#b48ead;">::</span><span> [[</span><span style="color:#b48ead;">Int</span><span>]]
</span><span>listOfLists = fmap moreList [</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>]
</span><span style="color:#65737e;">-- listOfLists = [[0,1,2], [1,2,3], [2,3,4]]
</span></code></pre>
<p>Trying to understand the actual point of an Applicative Functor, especially to my Javascript-addled mind, was much trickier. The first explanations I heard were something like:</p>
<h4 id="oh-applicative-it-s-for-taking-a-function-that-in-a-box-and-a-value-in-a-box-and-then-combining-them-to-make-a-new-value-which-is-also-in-a-box">"Oh, applicative? It's for taking a function that in a box, and a value in a box, and then combining them to make a new value which is also in a box"</h4>
<p>Now I am all up for putting values in boxes. Bloody love it. But functions? What are you playing at? Ridiculous talk.</p>
<p>Could it help us with our list changing exercise? Sort of...</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">minusOne </span><span style="color:#b48ead;">:: Int -&gt; Int
</span><span>minusOne i = i - </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#8fa1b3;">doNothing </span><span style="color:#b48ead;">:: Int -&gt; Int
</span><span>doNothing = id
</span><span>
</span><span style="color:#8fa1b3;">plusOne </span><span style="color:#b48ead;">:: Int -&gt; Int
</span><span>plusOne i = i + </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#8fa1b3;">applicativeList </span><span style="color:#b48ead;">::</span><span> [</span><span style="color:#b48ead;">Int</span><span>]
</span><span>applicativeList = [minusOne, doNothing, plusOne] &lt;*&gt; [</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>]
</span><span style="color:#65737e;">-- applicativeList == [0,1,2,1,2,3,2,3,4]
</span></code></pre>
<p>OK, so instead of a list of lists, we have one list (and one new terrifyingly meaningless infix operator, <code>&lt;*&gt;</code>, wonderful). Seems like a lot more work too, and we could probably just have used <code>concat</code> on the result and saved ourselves a whole load of intellectual soup. Sure. I get it. Terrible example. I've let us both down. I'm sorry.</p>
<p>Let's see if we can find a slightly more helpful example.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">CalcFace</span><span> a = </span><span style="color:#d08770;">CalcFace</span><span> [</span><span style="color:#d08770;">String</span><span>] a </span><span style="color:#b48ead;">deriving</span><span> (</span><span style="color:#a3be8c;">Eq</span><span>, </span><span style="color:#a3be8c;">Show</span><span>)
</span></code></pre>
<p>This data type is for describing calculations. The <code>a</code> contains the current total, and the <code>[String]</code> is used to describe what is happening. We've deriving standard <code>Eq</code> and <code>Show</code> instances for it, plus making our own fairly basic <code>Functor</code> instance that, as you might expected, maps the function <code>f</code> over any <code>a</code> inside the datatype and leaves everything else alone like a good functor should.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">instance Functor CalcFace where
</span><span>   fmap f (</span><span style="color:#d08770;">CalcFace</span><span> names a) = </span><span style="color:#d08770;">CalcFace</span><span> names $ f a
</span></code></pre>
<p>We also have this function, which we can use to print out the answer with our working.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">showCalculation </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#b48ead;">Show </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">=&gt; CalcFace </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; String
</span><span>showCalculation (</span><span style="color:#d08770;">CalcFace</span><span> names a) =
</span><span>        concat parts ++ &quot;</span><span style="color:#a3be8c;"> equals </span><span>&quot; ++ show a </span><span style="color:#b48ead;">where
</span><span>        parts = intersperse &quot; &quot; names
</span></code></pre>
<p>Let's try it out.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">one </span><span style="color:#b48ead;">:: CalcFace Int
</span><span>one = </span><span style="color:#d08770;">CalcFace</span><span> [&quot;</span><span style="color:#a3be8c;">1</span><span>&quot;] </span><span style="color:#d08770;">1
</span><span>
</span><span>showCalculation one
</span><span style="color:#65737e;">-- == &quot;1 equals 1&quot;
</span></code></pre>
<p>Seems very reasonable.</p>
<p>Let's try some mapping.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">two </span><span style="color:#b48ead;">:: CalcFace Int
</span><span>two = fmap (+</span><span style="color:#d08770;">1</span><span>) one
</span><span>
</span><span>showCalculation two
</span><span style="color:#65737e;">-- == &quot;1 equals 2&quot;
</span></code></pre>
<p>Not so good. The answer is correct as we ran a <code>+1</code> function over the <code>1</code> to get <code>2</code>, however we were unable to add anything to our log and thus the string output makes no sense. Perhaps <code>Functor</code> is not powerful enough for our task.</p>
<p>Let's give Applicative a go. Here's one of those functions in a box we were talking about. This time we can also include a description of what the function does.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">addOne </span><span style="color:#b48ead;">:: CalcFace</span><span> (</span><span style="color:#b48ead;">Int -&gt; Int</span><span>)
</span><span>addOne = </span><span style="color:#d08770;">CalcFace</span><span> [&quot;</span><span style="color:#a3be8c;">add 1</span><span>&quot;] (+</span><span style="color:#d08770;">1</span><span>)
</span></code></pre>
<p>We'll need an <code>Applicative</code> instance for our datatype too. What does that look like?</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#d08770;">Prelude</span><span>&gt; :i </span><span style="color:#d08770;">Applicative
</span></code></pre>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Functor </span><span style="color:#bf616a;">f</span><span> =&gt; </span><span style="color:#ebcb8b;">Applicative</span><span> (</span><span style="color:#bf616a;">f</span><span> :: * -&gt; *) </span><span style="color:#b48ead;">where
</span><span>  </span><span style="color:#8fa1b3;">pure </span><span style="color:#b48ead;">:: </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f a
</span><span>  </span><span style="color:#8fa1b3;">(&lt;*&gt;) </span><span>:: f (a -&gt; b) -&gt; f a -&gt; f b
</span><span>  </span><span style="color:#d08770;">GHC</span><span>.</span><span style="color:#d08770;">Base</span><span>.liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span>  </span><span style="color:#8fa1b3;">(*&gt;) </span><span>:: f a -&gt; f b -&gt; f b
</span><span>  </span><span style="color:#8fa1b3;">(&lt;*) </span><span>:: f a -&gt; f b -&gt; f a
</span><span>  {-# </span><span style="color:#b48ead;">MINIMAL</span><span> pure, ((&lt;*&gt;) | liftA2) #-}
</span></code></pre>
<p>There's some pretty interesting jumping off points in there (such as the whole concept of <code>lifting</code>, but we'll come back to that), but fortunately we only need to implement two functions for this typeclass.</p>
<ol>
<li><code>pure</code> - which takes an <code>a</code> value and returns a sort of default value for that datatype. This is used internally in constructing new values.</li>
<li><code>&lt;*&gt;</code> (called <code>apply</code> IRL) - this takes one wrapped function and one wrapped value and combines them.</li>
</ol>
<p>Confused? Me too! Let's give it a pop.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">instance Applicative CalcFace where
</span><span>    pure a = </span><span style="color:#d08770;">CalcFace []</span><span> a
</span><span>    (</span><span style="color:#d08770;">CalcFace</span><span> operation f) &lt;*&gt; (</span><span style="color:#d08770;">CalcFace</span><span> value a) =
</span><span>        </span><span style="color:#d08770;">CalcFace</span><span> newNames (f a) </span><span style="color:#b48ead;">where
</span><span>            newNames = value &lt;&gt; operation
</span></code></pre>
<p>OK. So <code>pure</code> is reasonably straightforward - it just makes the most basic <code>CalcFace</code> imaginable and puts whatever <code>a</code> we pass inside it. The other function is a bit trickier though. Basically we are taking the function <code>f</code> and applying to <code>a</code>, but also taking the <code>[String]</code> called <code>operation</code> and plopping it on the end of the <code>[String]</code> named <code>value</code>.</p>
<p>Seems weird? Sure. Let's see it in action though.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">oneAddOne </span><span style="color:#b48ead;">:: CalcFace Int
</span><span>oneAddOne = addOne &lt;*&gt; one
</span><span>
</span><span style="color:#65737e;">-- showCalculation oneAddOne == &quot;1 add 1 equals 2&quot;
</span></code></pre>
<p>Nice!</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">oneAddOneAddOne </span><span style="color:#b48ead;">:: CalcFace Int
</span><span>oneAddOneAddOne = addOne &lt;*&gt; oneAddOne
</span><span>
</span><span style="color:#65737e;">-- showCalculation oneAddOneAddOne == &quot;1 add 1 add 1 equals 3&quot;
</span></code></pre>
<p>Great stuff. The key here is that not only have we acted upon the values, the way that <code>functor</code> did, but we have also done something to the structure of the datatype too (in this case, adding to the list of operations). This seems trivial when the operators are just basic mathematics, but if the functions we are running are multiple database operations and calls to other servers, then you've got yourself the start of tidy little pure functional logging solution there, son.</p>
<p>Anyway. This barely scratches the surface, but hopefully gives you the start of an intuition for these things. Applicative does lots of things. Go find them!</p>
<p>Make sense? If not, why not <a href="/contact.html">get in touch</a>?</p>
<p>Further reading:</p>
<p><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicative and Monads in Pictures</a></p>


    </main>

    <footer>
      <p><a href="mailto:danieljamesharvey@gmail.com">Contact</a> |
      <a href="https://github.com/danieljharvey">Github</a></p>
      <p>Links for nerds:
        <a href="/atom.xml">atom</a>
        <a href="/rss.xml">rss</a></p>

    </footer>
</body>

</html>
